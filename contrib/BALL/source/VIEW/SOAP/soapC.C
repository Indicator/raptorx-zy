/* soapC.cpp
   Generated by gSOAP 2.7.9a from eutils_lite.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.9a 2006-11-20 15:13:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__ns7__IdType_HasNeighbor:
		return soap_in__ns7__IdType_HasNeighbor(soap, NULL, NULL, "ns7:IdType-HasNeighbor");
	case SOAP_TYPE__ns7__IdType_HasLinkOut:
		return soap_in__ns7__IdType_HasLinkOut(soap, NULL, NULL, "ns7:IdType-HasLinkOut");
	case SOAP_TYPE__ns6__ItemType_Type:
		return soap_in__ns6__ItemType_Type(soap, NULL, NULL, "ns6:ItemType-Type");
	case SOAP_TYPE_ns8__eSpellResultType:
		return soap_in_ns8__eSpellResultType(soap, NULL, NULL, "ns8:eSpellResultType");
	case SOAP_TYPE_ns8__SpelledQueryType:
		return soap_in_ns8__SpelledQueryType(soap, NULL, NULL, "ns8:SpelledQueryType");
	case SOAP_TYPE_ns7__eLinkResultType:
		return soap_in_ns7__eLinkResultType(soap, NULL, NULL, "ns7:eLinkResultType");
	case SOAP_TYPE_ns7__ProviderType:
		return soap_in_ns7__ProviderType(soap, NULL, NULL, "ns7:ProviderType");
	case SOAP_TYPE_ns7__ObjUrlType:
		return soap_in_ns7__ObjUrlType(soap, NULL, NULL, "ns7:ObjUrlType");
	case SOAP_TYPE_ns7__LinkSetDbType:
		return soap_in_ns7__LinkSetDbType(soap, NULL, NULL, "ns7:LinkSetDbType");
	case SOAP_TYPE_ns7__LinkSetType:
		return soap_in_ns7__LinkSetType(soap, NULL, NULL, "ns7:LinkSetType");
	case SOAP_TYPE_ns7__LinkInfoType:
		return soap_in_ns7__LinkInfoType(soap, NULL, NULL, "ns7:LinkInfoType");
	case SOAP_TYPE_ns7__LinkType:
		return soap_in_ns7__LinkType(soap, NULL, NULL, "ns7:LinkType");
	case SOAP_TYPE_ns7__IdUrlSetType:
		return soap_in_ns7__IdUrlSetType(soap, NULL, NULL, "ns7:IdUrlSetType");
	case SOAP_TYPE_ns7__IdUrlListType:
		return soap_in_ns7__IdUrlListType(soap, NULL, NULL, "ns7:IdUrlListType");
	case SOAP_TYPE_ns7__IdListType:
		return soap_in_ns7__IdListType(soap, NULL, NULL, "ns7:IdListType");
	case SOAP_TYPE_ns7__IdLinkSetType:
		return soap_in_ns7__IdLinkSetType(soap, NULL, NULL, "ns7:IdLinkSetType");
	case SOAP_TYPE_ns7__IdCheckListType:
		return soap_in_ns7__IdCheckListType(soap, NULL, NULL, "ns7:IdCheckListType");
	case SOAP_TYPE_ns7__IdType:
		return soap_in_ns7__IdType(soap, NULL, NULL, "ns7:IdType");
	case SOAP_TYPE_ns6__eSummaryResultType:
		return soap_in_ns6__eSummaryResultType(soap, NULL, NULL, "ns6:eSummaryResultType");
	case SOAP_TYPE_ns6__ItemType:
		return soap_in_ns6__ItemType(soap, NULL, NULL, "ns6:ItemType");
	case SOAP_TYPE_ns6__DocSumType:
		return soap_in_ns6__DocSumType(soap, NULL, NULL, "ns6:DocSumType");
	case SOAP_TYPE_ns5__eSearchResultType:
		return soap_in_ns5__eSearchResultType(soap, NULL, NULL, "ns5:eSearchResultType");
	case SOAP_TYPE_ns5__WarningListType:
		return soap_in_ns5__WarningListType(soap, NULL, NULL, "ns5:WarningListType");
	case SOAP_TYPE_ns5__TranslationStackType:
		return soap_in_ns5__TranslationStackType(soap, NULL, NULL, "ns5:TranslationStackType");
	case SOAP_TYPE_ns5__TranslationSetType:
		return soap_in_ns5__TranslationSetType(soap, NULL, NULL, "ns5:TranslationSetType");
	case SOAP_TYPE_ns5__TranslationType:
		return soap_in_ns5__TranslationType(soap, NULL, NULL, "ns5:TranslationType");
	case SOAP_TYPE_ns5__TermSetType:
		return soap_in_ns5__TermSetType(soap, NULL, NULL, "ns5:TermSetType");
	case SOAP_TYPE_ns5__IdListType:
		return soap_in_ns5__IdListType(soap, NULL, NULL, "ns5:IdListType");
	case SOAP_TYPE_ns5__ErrorListType:
		return soap_in_ns5__ErrorListType(soap, NULL, NULL, "ns5:ErrorListType");
	case SOAP_TYPE_ns4__eInfoResultType:
		return soap_in_ns4__eInfoResultType(soap, NULL, NULL, "ns4:eInfoResultType");
	case SOAP_TYPE_ns4__LinkListType:
		return soap_in_ns4__LinkListType(soap, NULL, NULL, "ns4:LinkListType");
	case SOAP_TYPE_ns4__LinkType:
		return soap_in_ns4__LinkType(soap, NULL, NULL, "ns4:LinkType");
	case SOAP_TYPE_ns4__FieldListType:
		return soap_in_ns4__FieldListType(soap, NULL, NULL, "ns4:FieldListType");
	case SOAP_TYPE_ns4__FieldType:
		return soap_in_ns4__FieldType(soap, NULL, NULL, "ns4:FieldType");
	case SOAP_TYPE_ns4__DbListType:
		return soap_in_ns4__DbListType(soap, NULL, NULL, "ns4:DbListType");
	case SOAP_TYPE_ns4__DbInfoType:
		return soap_in_ns4__DbInfoType(soap, NULL, NULL, "ns4:DbInfoType");
	case SOAP_TYPE_ns3__GQueryResultType:
		return soap_in_ns3__GQueryResultType(soap, NULL, NULL, "ns3:GQueryResultType");
	case SOAP_TYPE_ns3__eGQueryResultType:
		return soap_in_ns3__eGQueryResultType(soap, NULL, NULL, "ns3:eGQueryResultType");
	case SOAP_TYPE_ns3__ResultItemType:
		return soap_in_ns3__ResultItemType(soap, NULL, NULL, "ns3:ResultItemType");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns8__eSpellResultMS:
		return soap_in_PointerTo_ns8__eSpellResultMS(soap, NULL, NULL, "ns8:eSpellResultMS");
	case SOAP_TYPE_PointerTo_ns8__eSpellRequestMS:
		return soap_in_PointerTo_ns8__eSpellRequestMS(soap, NULL, NULL, "ns8:eSpellRequestMS");
	case SOAP_TYPE_PointerTo_ns8__eSpellResult:
		return soap_in_PointerTo_ns8__eSpellResult(soap, NULL, NULL, "ns8:eSpellResult");
	case SOAP_TYPE_PointerTo_ns8__eSpellRequest:
		return soap_in_PointerTo_ns8__eSpellRequest(soap, NULL, NULL, "ns8:eSpellRequest");
	case SOAP_TYPE_PointerTo_ns7__eLinkResultMS:
		return soap_in_PointerTo_ns7__eLinkResultMS(soap, NULL, NULL, "ns7:eLinkResultMS");
	case SOAP_TYPE_PointerTo_ns7__eLinkRequestMS:
		return soap_in_PointerTo_ns7__eLinkRequestMS(soap, NULL, NULL, "ns7:eLinkRequestMS");
	case SOAP_TYPE_PointerTo_ns7__eLinkResult:
		return soap_in_PointerTo_ns7__eLinkResult(soap, NULL, NULL, "ns7:eLinkResult");
	case SOAP_TYPE_PointerTo_ns7__eLinkRequest:
		return soap_in_PointerTo_ns7__eLinkRequest(soap, NULL, NULL, "ns7:eLinkRequest");
	case SOAP_TYPE_PointerTo_ns6__eSummaryResultMS:
		return soap_in_PointerTo_ns6__eSummaryResultMS(soap, NULL, NULL, "ns6:eSummaryResultMS");
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequestMS:
		return soap_in_PointerTo_ns6__eSummaryRequestMS(soap, NULL, NULL, "ns6:eSummaryRequestMS");
	case SOAP_TYPE_PointerTo_ns6__eSummaryResult:
		return soap_in_PointerTo_ns6__eSummaryResult(soap, NULL, NULL, "ns6:eSummaryResult");
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequest:
		return soap_in_PointerTo_ns6__eSummaryRequest(soap, NULL, NULL, "ns6:eSummaryRequest");
	case SOAP_TYPE_PointerTo_ns5__eSearchResultMS:
		return soap_in_PointerTo_ns5__eSearchResultMS(soap, NULL, NULL, "ns5:eSearchResultMS");
	case SOAP_TYPE_PointerTo_ns5__eSearchRequestMS:
		return soap_in_PointerTo_ns5__eSearchRequestMS(soap, NULL, NULL, "ns5:eSearchRequestMS");
	case SOAP_TYPE_PointerTo_ns5__eSearchResult:
		return soap_in_PointerTo_ns5__eSearchResult(soap, NULL, NULL, "ns5:eSearchResult");
	case SOAP_TYPE_PointerTo_ns5__eSearchRequest:
		return soap_in_PointerTo_ns5__eSearchRequest(soap, NULL, NULL, "ns5:eSearchRequest");
	case SOAP_TYPE_PointerTo_ns4__eInfoResultMS:
		return soap_in_PointerTo_ns4__eInfoResultMS(soap, NULL, NULL, "ns4:eInfoResultMS");
	case SOAP_TYPE_PointerTo_ns4__eInfoRequestMS:
		return soap_in_PointerTo_ns4__eInfoRequestMS(soap, NULL, NULL, "ns4:eInfoRequestMS");
	case SOAP_TYPE_PointerTo_ns4__eInfoResult:
		return soap_in_PointerTo_ns4__eInfoResult(soap, NULL, NULL, "ns4:eInfoResult");
	case SOAP_TYPE_PointerTo_ns4__eInfoRequest:
		return soap_in_PointerTo_ns4__eInfoRequest(soap, NULL, NULL, "ns4:eInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__ResultMS:
		return soap_in_PointerTo_ns3__ResultMS(soap, NULL, NULL, "ns3:ResultMS");
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequestMS:
		return soap_in_PointerTo_ns3__eGqueryRequestMS(soap, NULL, NULL, "ns3:eGqueryRequestMS");
	case SOAP_TYPE_PointerTo_ns3__Result:
		return soap_in_PointerTo_ns3__Result(soap, NULL, NULL, "ns3:Result");
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequest:
		return soap_in_PointerTo_ns3__eGqueryRequest(soap, NULL, NULL, "ns3:eGqueryRequest");
	case SOAP_TYPE_PointerTons8__eSpellResultType:
		return soap_in_PointerTons8__eSpellResultType(soap, NULL, NULL, "ns8:eSpellResultType");
	case SOAP_TYPE_PointerTons8__SpelledQueryType:
		return soap_in_PointerTons8__SpelledQueryType(soap, NULL, NULL, "ns8:SpelledQueryType");
	case SOAP_TYPE_PointerTons7__eLinkResultType:
		return soap_in_PointerTons7__eLinkResultType(soap, NULL, NULL, "ns7:eLinkResultType");
	case SOAP_TYPE_PointerTons7__LinkSetType:
		return soap_in_PointerTons7__LinkSetType(soap, NULL, NULL, "ns7:LinkSetType");
	case SOAP_TYPE_PointerTons7__ProviderType:
		return soap_in_PointerTons7__ProviderType(soap, NULL, NULL, "ns7:ProviderType");
	case SOAP_TYPE_PointerTons7__LinkType:
		return soap_in_PointerTons7__LinkType(soap, NULL, NULL, "ns7:LinkType");
	case SOAP_TYPE_PointerTons7__IdCheckListType:
		return soap_in_PointerTons7__IdCheckListType(soap, NULL, NULL, "ns7:IdCheckListType");
	case SOAP_TYPE_PointerTons7__IdUrlListType:
		return soap_in_PointerTons7__IdUrlListType(soap, NULL, NULL, "ns7:IdUrlListType");
	case SOAP_TYPE_PointerTons7__LinkSetDbType:
		return soap_in_PointerTons7__LinkSetDbType(soap, NULL, NULL, "ns7:LinkSetDbType");
	case SOAP_TYPE_PointerTons7__IdListType:
		return soap_in_PointerTons7__IdListType(soap, NULL, NULL, "ns7:IdListType");
	case SOAP_TYPE_PointerTons7__ObjUrlType:
		return soap_in_PointerTons7__ObjUrlType(soap, NULL, NULL, "ns7:ObjUrlType");
	case SOAP_TYPE_PointerTons7__IdUrlSetType:
		return soap_in_PointerTons7__IdUrlSetType(soap, NULL, NULL, "ns7:IdUrlSetType");
	case SOAP_TYPE_PointerTons7__LinkInfoType:
		return soap_in_PointerTons7__LinkInfoType(soap, NULL, NULL, "ns7:LinkInfoType");
	case SOAP_TYPE_PointerTons7__IdLinkSetType:
		return soap_in_PointerTons7__IdLinkSetType(soap, NULL, NULL, "ns7:IdLinkSetType");
	case SOAP_TYPE_PointerTons7__IdType:
		return soap_in_PointerTons7__IdType(soap, NULL, NULL, "ns7:IdType");
	case SOAP_TYPE_PointerTons6__eSummaryResultType:
		return soap_in_PointerTons6__eSummaryResultType(soap, NULL, NULL, "ns6:eSummaryResultType");
	case SOAP_TYPE_PointerTons6__DocSumType:
		return soap_in_PointerTons6__DocSumType(soap, NULL, NULL, "ns6:DocSumType");
	case SOAP_TYPE_PointerTons6__ItemType:
		return soap_in_PointerTons6__ItemType(soap, NULL, NULL, "ns6:ItemType");
	case SOAP_TYPE_PointerTons5__eSearchResultType:
		return soap_in_PointerTons5__eSearchResultType(soap, NULL, NULL, "ns5:eSearchResultType");
	case SOAP_TYPE_PointerTons5__TranslationStackType:
		return soap_in_PointerTons5__TranslationStackType(soap, NULL, NULL, "ns5:TranslationStackType");
	case SOAP_TYPE_PointerTons5__TranslationSetType:
		return soap_in_PointerTons5__TranslationSetType(soap, NULL, NULL, "ns5:TranslationSetType");
	case SOAP_TYPE_PointerTons5__IdListType:
		return soap_in_PointerTons5__IdListType(soap, NULL, NULL, "ns5:IdListType");
	case SOAP_TYPE_PointerTons5__WarningListType:
		return soap_in_PointerTons5__WarningListType(soap, NULL, NULL, "ns5:WarningListType");
	case SOAP_TYPE_PointerTons5__ErrorListType:
		return soap_in_PointerTons5__ErrorListType(soap, NULL, NULL, "ns5:ErrorListType");
	case SOAP_TYPE_PointerTons5__TermSetType:
		return soap_in_PointerTons5__TermSetType(soap, NULL, NULL, "ns5:TermSetType");
	case SOAP_TYPE_PointerTons5__TranslationType:
		return soap_in_PointerTons5__TranslationType(soap, NULL, NULL, "ns5:TranslationType");
	case SOAP_TYPE_PointerTons4__eInfoResultType:
		return soap_in_PointerTons4__eInfoResultType(soap, NULL, NULL, "ns4:eInfoResultType");
	case SOAP_TYPE_PointerTons4__DbInfoType:
		return soap_in_PointerTons4__DbInfoType(soap, NULL, NULL, "ns4:DbInfoType");
	case SOAP_TYPE_PointerTons4__DbListType:
		return soap_in_PointerTons4__DbListType(soap, NULL, NULL, "ns4:DbListType");
	case SOAP_TYPE_PointerTons4__LinkType:
		return soap_in_PointerTons4__LinkType(soap, NULL, NULL, "ns4:LinkType");
	case SOAP_TYPE_PointerTons4__FieldType:
		return soap_in_PointerTons4__FieldType(soap, NULL, NULL, "ns4:FieldType");
	case SOAP_TYPE_PointerTons4__LinkListType:
		return soap_in_PointerTons4__LinkListType(soap, NULL, NULL, "ns4:LinkListType");
	case SOAP_TYPE_PointerTons4__FieldListType:
		return soap_in_PointerTons4__FieldListType(soap, NULL, NULL, "ns4:FieldListType");
	case SOAP_TYPE_PointerTons3__GQueryResultType:
		return soap_in_PointerTons3__GQueryResultType(soap, NULL, NULL, "ns3:GQueryResultType");
	case SOAP_TYPE_PointerTons3__eGQueryResultType:
		return soap_in_PointerTons3__eGQueryResultType(soap, NULL, NULL, "ns3:eGQueryResultType");
	case SOAP_TYPE_PointerTons3__ResultItemType:
		return soap_in_PointerTons3__ResultItemType(soap, NULL, NULL, "ns3:ResultItemType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdType-HasNeighbor"))
		{	*type = SOAP_TYPE__ns7__IdType_HasNeighbor;
			return soap_in__ns7__IdType_HasNeighbor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdType-HasLinkOut"))
		{	*type = SOAP_TYPE__ns7__IdType_HasLinkOut;
			return soap_in__ns7__IdType_HasLinkOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ItemType-Type"))
		{	*type = SOAP_TYPE__ns6__ItemType_Type;
			return soap_in__ns6__ItemType_Type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:eSpellResultType"))
		{	*type = SOAP_TYPE_ns8__eSpellResultType;
			return soap_in_ns8__eSpellResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:SpelledQueryType"))
		{	*type = SOAP_TYPE_ns8__SpelledQueryType;
			return soap_in_ns8__SpelledQueryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:eLinkResultType"))
		{	*type = SOAP_TYPE_ns7__eLinkResultType;
			return soap_in_ns7__eLinkResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ProviderType"))
		{	*type = SOAP_TYPE_ns7__ProviderType;
			return soap_in_ns7__ProviderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ObjUrlType"))
		{	*type = SOAP_TYPE_ns7__ObjUrlType;
			return soap_in_ns7__ObjUrlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:LinkSetDbType"))
		{	*type = SOAP_TYPE_ns7__LinkSetDbType;
			return soap_in_ns7__LinkSetDbType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:LinkSetType"))
		{	*type = SOAP_TYPE_ns7__LinkSetType;
			return soap_in_ns7__LinkSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:LinkInfoType"))
		{	*type = SOAP_TYPE_ns7__LinkInfoType;
			return soap_in_ns7__LinkInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:LinkType"))
		{	*type = SOAP_TYPE_ns7__LinkType;
			return soap_in_ns7__LinkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdUrlSetType"))
		{	*type = SOAP_TYPE_ns7__IdUrlSetType;
			return soap_in_ns7__IdUrlSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdUrlListType"))
		{	*type = SOAP_TYPE_ns7__IdUrlListType;
			return soap_in_ns7__IdUrlListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdListType"))
		{	*type = SOAP_TYPE_ns7__IdListType;
			return soap_in_ns7__IdListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdLinkSetType"))
		{	*type = SOAP_TYPE_ns7__IdLinkSetType;
			return soap_in_ns7__IdLinkSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdCheckListType"))
		{	*type = SOAP_TYPE_ns7__IdCheckListType;
			return soap_in_ns7__IdCheckListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:IdType"))
		{	*type = SOAP_TYPE_ns7__IdType;
			return soap_in_ns7__IdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:eSummaryResultType"))
		{	*type = SOAP_TYPE_ns6__eSummaryResultType;
			return soap_in_ns6__eSummaryResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ItemType"))
		{	*type = SOAP_TYPE_ns6__ItemType;
			return soap_in_ns6__ItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocSumType"))
		{	*type = SOAP_TYPE_ns6__DocSumType;
			return soap_in_ns6__DocSumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:eSearchResultType"))
		{	*type = SOAP_TYPE_ns5__eSearchResultType;
			return soap_in_ns5__eSearchResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:WarningListType"))
		{	*type = SOAP_TYPE_ns5__WarningListType;
			return soap_in_ns5__WarningListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TranslationStackType"))
		{	*type = SOAP_TYPE_ns5__TranslationStackType;
			return soap_in_ns5__TranslationStackType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TranslationSetType"))
		{	*type = SOAP_TYPE_ns5__TranslationSetType;
			return soap_in_ns5__TranslationSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TranslationType"))
		{	*type = SOAP_TYPE_ns5__TranslationType;
			return soap_in_ns5__TranslationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TermSetType"))
		{	*type = SOAP_TYPE_ns5__TermSetType;
			return soap_in_ns5__TermSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:IdListType"))
		{	*type = SOAP_TYPE_ns5__IdListType;
			return soap_in_ns5__IdListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ErrorListType"))
		{	*type = SOAP_TYPE_ns5__ErrorListType;
			return soap_in_ns5__ErrorListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:eInfoResultType"))
		{	*type = SOAP_TYPE_ns4__eInfoResultType;
			return soap_in_ns4__eInfoResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LinkListType"))
		{	*type = SOAP_TYPE_ns4__LinkListType;
			return soap_in_ns4__LinkListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LinkType"))
		{	*type = SOAP_TYPE_ns4__LinkType;
			return soap_in_ns4__LinkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FieldListType"))
		{	*type = SOAP_TYPE_ns4__FieldListType;
			return soap_in_ns4__FieldListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FieldType"))
		{	*type = SOAP_TYPE_ns4__FieldType;
			return soap_in_ns4__FieldType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DbListType"))
		{	*type = SOAP_TYPE_ns4__DbListType;
			return soap_in_ns4__DbListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DbInfoType"))
		{	*type = SOAP_TYPE_ns4__DbInfoType;
			return soap_in_ns4__DbInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GQueryResultType"))
		{	*type = SOAP_TYPE_ns3__GQueryResultType;
			return soap_in_ns3__GQueryResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:eGQueryResultType"))
		{	*type = SOAP_TYPE_ns3__eGQueryResultType;
			return soap_in_ns3__eGQueryResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResultItemType"))
		{	*type = SOAP_TYPE_ns3__ResultItemType;
			return soap_in_ns3__ResultItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns8:eSpellRequestMS"))
		{	*type = SOAP_TYPE__ns8__eSpellRequestMS;
			return soap_in__ns8__eSpellRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:eSpellResultMS"))
		{	*type = SOAP_TYPE__ns8__eSpellResultMS;
			return soap_in__ns8__eSpellResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:eSpellRequest"))
		{	*type = SOAP_TYPE__ns8__eSpellRequest;
			return soap_in__ns8__eSpellRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:eSpellResult"))
		{	*type = SOAP_TYPE__ns8__eSpellResult;
			return soap_in__ns8__eSpellResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:eLinkRequestMS"))
		{	*type = SOAP_TYPE__ns7__eLinkRequestMS;
			return soap_in__ns7__eLinkRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:eLinkRequest"))
		{	*type = SOAP_TYPE__ns7__eLinkRequest;
			return soap_in__ns7__eLinkRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:eLinkResultMS"))
		{	*type = SOAP_TYPE__ns7__eLinkResultMS;
			return soap_in__ns7__eLinkResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:eLinkResult"))
		{	*type = SOAP_TYPE__ns7__eLinkResult;
			return soap_in__ns7__eLinkResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:eSummaryResultMS"))
		{	*type = SOAP_TYPE__ns6__eSummaryResultMS;
			return soap_in__ns6__eSummaryResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:eSummaryRequestMS"))
		{	*type = SOAP_TYPE__ns6__eSummaryRequestMS;
			return soap_in__ns6__eSummaryRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:eSummaryRequest"))
		{	*type = SOAP_TYPE__ns6__eSummaryRequest;
			return soap_in__ns6__eSummaryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:eSummaryResult"))
		{	*type = SOAP_TYPE__ns6__eSummaryResult;
			return soap_in__ns6__eSummaryResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:eSearchResultMS"))
		{	*type = SOAP_TYPE__ns5__eSearchResultMS;
			return soap_in__ns5__eSearchResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:eSearchRequestMS"))
		{	*type = SOAP_TYPE__ns5__eSearchRequestMS;
			return soap_in__ns5__eSearchRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:eSearchRequest"))
		{	*type = SOAP_TYPE__ns5__eSearchRequest;
			return soap_in__ns5__eSearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:eSearchResult"))
		{	*type = SOAP_TYPE__ns5__eSearchResult;
			return soap_in__ns5__eSearchResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:eInfoResultMS"))
		{	*type = SOAP_TYPE__ns4__eInfoResultMS;
			return soap_in__ns4__eInfoResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:eInfoRequestMS"))
		{	*type = SOAP_TYPE__ns4__eInfoRequestMS;
			return soap_in__ns4__eInfoRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:eInfoRequest"))
		{	*type = SOAP_TYPE__ns4__eInfoRequest;
			return soap_in__ns4__eInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:eInfoResult"))
		{	*type = SOAP_TYPE__ns4__eInfoResult;
			return soap_in__ns4__eInfoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResultMS"))
		{	*type = SOAP_TYPE__ns3__ResultMS;
			return soap_in__ns3__ResultMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:eGqueryRequestMS"))
		{	*type = SOAP_TYPE__ns3__eGqueryRequestMS;
			return soap_in__ns3__eGqueryRequestMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:eGqueryRequest"))
		{	*type = SOAP_TYPE__ns3__eGqueryRequest;
			return soap_in__ns3__eGqueryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Result"))
		{	*type = SOAP_TYPE__ns3__Result;
			return soap_in__ns3__Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns7__IdType_HasNeighbor:
		return soap_out__ns7__IdType_HasNeighbor(soap, tag, id, (const enum _ns7__IdType_HasNeighbor *)ptr, "ns7:IdType-HasNeighbor");
	case SOAP_TYPE__ns7__IdType_HasLinkOut:
		return soap_out__ns7__IdType_HasLinkOut(soap, tag, id, (const enum _ns7__IdType_HasLinkOut *)ptr, "ns7:IdType-HasLinkOut");
	case SOAP_TYPE__ns6__ItemType_Type:
		return soap_out__ns6__ItemType_Type(soap, tag, id, (const enum _ns6__ItemType_Type *)ptr, "ns6:ItemType-Type");
	case SOAP_TYPE__ns8__eSpellRequestMS:
		return ((_ns8__eSpellRequestMS *)ptr)->soap_out(soap, "ns8:eSpellRequestMS", id, NULL);
	case SOAP_TYPE__ns8__eSpellResultMS:
		return ((_ns8__eSpellResultMS *)ptr)->soap_out(soap, "ns8:eSpellResultMS", id, NULL);
	case SOAP_TYPE__ns8__eSpellRequest:
		return ((_ns8__eSpellRequest *)ptr)->soap_out(soap, "ns8:eSpellRequest", id, NULL);
	case SOAP_TYPE__ns8__eSpellResult:
		return ((_ns8__eSpellResult *)ptr)->soap_out(soap, "ns8:eSpellResult", id, NULL);
	case SOAP_TYPE_ns8__eSpellResultType:
		return ((ns8__eSpellResultType *)ptr)->soap_out(soap, tag, id, "ns8:eSpellResultType");
	case SOAP_TYPE_ns8__SpelledQueryType:
		return ((ns8__SpelledQueryType *)ptr)->soap_out(soap, tag, id, "ns8:SpelledQueryType");
	case SOAP_TYPE__ns7__eLinkRequestMS:
		return ((_ns7__eLinkRequestMS *)ptr)->soap_out(soap, "ns7:eLinkRequestMS", id, NULL);
	case SOAP_TYPE__ns7__eLinkRequest:
		return ((_ns7__eLinkRequest *)ptr)->soap_out(soap, "ns7:eLinkRequest", id, NULL);
	case SOAP_TYPE__ns7__eLinkResultMS:
		return ((_ns7__eLinkResultMS *)ptr)->soap_out(soap, "ns7:eLinkResultMS", id, NULL);
	case SOAP_TYPE__ns7__eLinkResult:
		return ((_ns7__eLinkResult *)ptr)->soap_out(soap, "ns7:eLinkResult", id, NULL);
	case SOAP_TYPE_ns7__eLinkResultType:
		return ((ns7__eLinkResultType *)ptr)->soap_out(soap, tag, id, "ns7:eLinkResultType");
	case SOAP_TYPE_ns7__ProviderType:
		return ((ns7__ProviderType *)ptr)->soap_out(soap, tag, id, "ns7:ProviderType");
	case SOAP_TYPE_ns7__ObjUrlType:
		return ((ns7__ObjUrlType *)ptr)->soap_out(soap, tag, id, "ns7:ObjUrlType");
	case SOAP_TYPE_ns7__LinkSetDbType:
		return ((ns7__LinkSetDbType *)ptr)->soap_out(soap, tag, id, "ns7:LinkSetDbType");
	case SOAP_TYPE_ns7__LinkSetType:
		return ((ns7__LinkSetType *)ptr)->soap_out(soap, tag, id, "ns7:LinkSetType");
	case SOAP_TYPE_ns7__LinkInfoType:
		return ((ns7__LinkInfoType *)ptr)->soap_out(soap, tag, id, "ns7:LinkInfoType");
	case SOAP_TYPE_ns7__LinkType:
		return ((ns7__LinkType *)ptr)->soap_out(soap, tag, id, "ns7:LinkType");
	case SOAP_TYPE_ns7__IdUrlSetType:
		return ((ns7__IdUrlSetType *)ptr)->soap_out(soap, tag, id, "ns7:IdUrlSetType");
	case SOAP_TYPE_ns7__IdUrlListType:
		return ((ns7__IdUrlListType *)ptr)->soap_out(soap, tag, id, "ns7:IdUrlListType");
	case SOAP_TYPE_ns7__IdListType:
		return ((ns7__IdListType *)ptr)->soap_out(soap, tag, id, "ns7:IdListType");
	case SOAP_TYPE_ns7__IdLinkSetType:
		return ((ns7__IdLinkSetType *)ptr)->soap_out(soap, tag, id, "ns7:IdLinkSetType");
	case SOAP_TYPE_ns7__IdCheckListType:
		return ((ns7__IdCheckListType *)ptr)->soap_out(soap, tag, id, "ns7:IdCheckListType");
	case SOAP_TYPE_ns7__IdType:
		return ((ns7__IdType *)ptr)->soap_out(soap, tag, id, "ns7:IdType");
	case SOAP_TYPE__ns6__eSummaryResultMS:
		return ((_ns6__eSummaryResultMS *)ptr)->soap_out(soap, "ns6:eSummaryResultMS", id, NULL);
	case SOAP_TYPE__ns6__eSummaryRequestMS:
		return ((_ns6__eSummaryRequestMS *)ptr)->soap_out(soap, "ns6:eSummaryRequestMS", id, NULL);
	case SOAP_TYPE__ns6__eSummaryRequest:
		return ((_ns6__eSummaryRequest *)ptr)->soap_out(soap, "ns6:eSummaryRequest", id, NULL);
	case SOAP_TYPE__ns6__eSummaryResult:
		return ((_ns6__eSummaryResult *)ptr)->soap_out(soap, "ns6:eSummaryResult", id, NULL);
	case SOAP_TYPE_ns6__eSummaryResultType:
		return ((ns6__eSummaryResultType *)ptr)->soap_out(soap, tag, id, "ns6:eSummaryResultType");
	case SOAP_TYPE_ns6__ItemType:
		return ((ns6__ItemType *)ptr)->soap_out(soap, tag, id, "ns6:ItemType");
	case SOAP_TYPE_ns6__DocSumType:
		return ((ns6__DocSumType *)ptr)->soap_out(soap, tag, id, "ns6:DocSumType");
	case SOAP_TYPE__ns5__eSearchResultMS:
		return ((_ns5__eSearchResultMS *)ptr)->soap_out(soap, "ns5:eSearchResultMS", id, NULL);
	case SOAP_TYPE__ns5__eSearchRequestMS:
		return ((_ns5__eSearchRequestMS *)ptr)->soap_out(soap, "ns5:eSearchRequestMS", id, NULL);
	case SOAP_TYPE__ns5__eSearchRequest:
		return ((_ns5__eSearchRequest *)ptr)->soap_out(soap, "ns5:eSearchRequest", id, NULL);
	case SOAP_TYPE__ns5__eSearchResult:
		return ((_ns5__eSearchResult *)ptr)->soap_out(soap, "ns5:eSearchResult", id, NULL);
	case SOAP_TYPE_ns5__eSearchResultType:
		return ((ns5__eSearchResultType *)ptr)->soap_out(soap, tag, id, "ns5:eSearchResultType");
	case SOAP_TYPE_ns5__WarningListType:
		return ((ns5__WarningListType *)ptr)->soap_out(soap, tag, id, "ns5:WarningListType");
	case SOAP_TYPE_ns5__TranslationStackType:
		return ((ns5__TranslationStackType *)ptr)->soap_out(soap, tag, id, "ns5:TranslationStackType");
	case SOAP_TYPE_ns5__TranslationSetType:
		return ((ns5__TranslationSetType *)ptr)->soap_out(soap, tag, id, "ns5:TranslationSetType");
	case SOAP_TYPE_ns5__TranslationType:
		return ((ns5__TranslationType *)ptr)->soap_out(soap, tag, id, "ns5:TranslationType");
	case SOAP_TYPE_ns5__TermSetType:
		return ((ns5__TermSetType *)ptr)->soap_out(soap, tag, id, "ns5:TermSetType");
	case SOAP_TYPE_ns5__IdListType:
		return ((ns5__IdListType *)ptr)->soap_out(soap, tag, id, "ns5:IdListType");
	case SOAP_TYPE_ns5__ErrorListType:
		return ((ns5__ErrorListType *)ptr)->soap_out(soap, tag, id, "ns5:ErrorListType");
	case SOAP_TYPE__ns4__eInfoResultMS:
		return ((_ns4__eInfoResultMS *)ptr)->soap_out(soap, "ns4:eInfoResultMS", id, NULL);
	case SOAP_TYPE__ns4__eInfoRequestMS:
		return ((_ns4__eInfoRequestMS *)ptr)->soap_out(soap, "ns4:eInfoRequestMS", id, NULL);
	case SOAP_TYPE__ns4__eInfoRequest:
		return ((_ns4__eInfoRequest *)ptr)->soap_out(soap, "ns4:eInfoRequest", id, NULL);
	case SOAP_TYPE__ns4__eInfoResult:
		return ((_ns4__eInfoResult *)ptr)->soap_out(soap, "ns4:eInfoResult", id, NULL);
	case SOAP_TYPE_ns4__eInfoResultType:
		return ((ns4__eInfoResultType *)ptr)->soap_out(soap, tag, id, "ns4:eInfoResultType");
	case SOAP_TYPE_ns4__LinkListType:
		return ((ns4__LinkListType *)ptr)->soap_out(soap, tag, id, "ns4:LinkListType");
	case SOAP_TYPE_ns4__LinkType:
		return ((ns4__LinkType *)ptr)->soap_out(soap, tag, id, "ns4:LinkType");
	case SOAP_TYPE_ns4__FieldListType:
		return ((ns4__FieldListType *)ptr)->soap_out(soap, tag, id, "ns4:FieldListType");
	case SOAP_TYPE_ns4__FieldType:
		return ((ns4__FieldType *)ptr)->soap_out(soap, tag, id, "ns4:FieldType");
	case SOAP_TYPE_ns4__DbListType:
		return ((ns4__DbListType *)ptr)->soap_out(soap, tag, id, "ns4:DbListType");
	case SOAP_TYPE_ns4__DbInfoType:
		return ((ns4__DbInfoType *)ptr)->soap_out(soap, tag, id, "ns4:DbInfoType");
	case SOAP_TYPE__ns3__ResultMS:
		return ((_ns3__ResultMS *)ptr)->soap_out(soap, "ns3:ResultMS", id, NULL);
	case SOAP_TYPE__ns3__eGqueryRequestMS:
		return ((_ns3__eGqueryRequestMS *)ptr)->soap_out(soap, "ns3:eGqueryRequestMS", id, NULL);
	case SOAP_TYPE__ns3__eGqueryRequest:
		return ((_ns3__eGqueryRequest *)ptr)->soap_out(soap, "ns3:eGqueryRequest", id, NULL);
	case SOAP_TYPE__ns3__Result:
		return ((_ns3__Result *)ptr)->soap_out(soap, "ns3:Result", id, NULL);
	case SOAP_TYPE_ns3__GQueryResultType:
		return ((ns3__GQueryResultType *)ptr)->soap_out(soap, tag, id, "ns3:GQueryResultType");
	case SOAP_TYPE_ns3__eGQueryResultType:
		return ((ns3__eGQueryResultType *)ptr)->soap_out(soap, tag, id, "ns3:eGQueryResultType");
	case SOAP_TYPE_ns3__ResultItemType:
		return ((ns3__ResultItemType *)ptr)->soap_out(soap, tag, id, "ns3:ResultItemType");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::string *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns8__eSpellResultMS:
		return soap_out_PointerTo_ns8__eSpellResultMS(soap, tag, id, (_ns8__eSpellResultMS *const*)ptr, "ns8:eSpellResultMS");
	case SOAP_TYPE_PointerTo_ns8__eSpellRequestMS:
		return soap_out_PointerTo_ns8__eSpellRequestMS(soap, tag, id, (_ns8__eSpellRequestMS *const*)ptr, "ns8:eSpellRequestMS");
	case SOAP_TYPE_PointerTo_ns8__eSpellResult:
		return soap_out_PointerTo_ns8__eSpellResult(soap, tag, id, (_ns8__eSpellResult *const*)ptr, "ns8:eSpellResult");
	case SOAP_TYPE_PointerTo_ns8__eSpellRequest:
		return soap_out_PointerTo_ns8__eSpellRequest(soap, tag, id, (_ns8__eSpellRequest *const*)ptr, "ns8:eSpellRequest");
	case SOAP_TYPE_PointerTo_ns7__eLinkResultMS:
		return soap_out_PointerTo_ns7__eLinkResultMS(soap, tag, id, (_ns7__eLinkResultMS *const*)ptr, "ns7:eLinkResultMS");
	case SOAP_TYPE_PointerTo_ns7__eLinkRequestMS:
		return soap_out_PointerTo_ns7__eLinkRequestMS(soap, tag, id, (_ns7__eLinkRequestMS *const*)ptr, "ns7:eLinkRequestMS");
	case SOAP_TYPE_PointerTo_ns7__eLinkResult:
		return soap_out_PointerTo_ns7__eLinkResult(soap, tag, id, (_ns7__eLinkResult *const*)ptr, "ns7:eLinkResult");
	case SOAP_TYPE_PointerTo_ns7__eLinkRequest:
		return soap_out_PointerTo_ns7__eLinkRequest(soap, tag, id, (_ns7__eLinkRequest *const*)ptr, "ns7:eLinkRequest");
	case SOAP_TYPE_PointerTo_ns6__eSummaryResultMS:
		return soap_out_PointerTo_ns6__eSummaryResultMS(soap, tag, id, (_ns6__eSummaryResultMS *const*)ptr, "ns6:eSummaryResultMS");
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequestMS:
		return soap_out_PointerTo_ns6__eSummaryRequestMS(soap, tag, id, (_ns6__eSummaryRequestMS *const*)ptr, "ns6:eSummaryRequestMS");
	case SOAP_TYPE_PointerTo_ns6__eSummaryResult:
		return soap_out_PointerTo_ns6__eSummaryResult(soap, tag, id, (_ns6__eSummaryResult *const*)ptr, "ns6:eSummaryResult");
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequest:
		return soap_out_PointerTo_ns6__eSummaryRequest(soap, tag, id, (_ns6__eSummaryRequest *const*)ptr, "ns6:eSummaryRequest");
	case SOAP_TYPE_PointerTo_ns5__eSearchResultMS:
		return soap_out_PointerTo_ns5__eSearchResultMS(soap, tag, id, (_ns5__eSearchResultMS *const*)ptr, "ns5:eSearchResultMS");
	case SOAP_TYPE_PointerTo_ns5__eSearchRequestMS:
		return soap_out_PointerTo_ns5__eSearchRequestMS(soap, tag, id, (_ns5__eSearchRequestMS *const*)ptr, "ns5:eSearchRequestMS");
	case SOAP_TYPE_PointerTo_ns5__eSearchResult:
		return soap_out_PointerTo_ns5__eSearchResult(soap, tag, id, (_ns5__eSearchResult *const*)ptr, "ns5:eSearchResult");
	case SOAP_TYPE_PointerTo_ns5__eSearchRequest:
		return soap_out_PointerTo_ns5__eSearchRequest(soap, tag, id, (_ns5__eSearchRequest *const*)ptr, "ns5:eSearchRequest");
	case SOAP_TYPE_PointerTo_ns4__eInfoResultMS:
		return soap_out_PointerTo_ns4__eInfoResultMS(soap, tag, id, (_ns4__eInfoResultMS *const*)ptr, "ns4:eInfoResultMS");
	case SOAP_TYPE_PointerTo_ns4__eInfoRequestMS:
		return soap_out_PointerTo_ns4__eInfoRequestMS(soap, tag, id, (_ns4__eInfoRequestMS *const*)ptr, "ns4:eInfoRequestMS");
	case SOAP_TYPE_PointerTo_ns4__eInfoResult:
		return soap_out_PointerTo_ns4__eInfoResult(soap, tag, id, (_ns4__eInfoResult *const*)ptr, "ns4:eInfoResult");
	case SOAP_TYPE_PointerTo_ns4__eInfoRequest:
		return soap_out_PointerTo_ns4__eInfoRequest(soap, tag, id, (_ns4__eInfoRequest *const*)ptr, "ns4:eInfoRequest");
	case SOAP_TYPE_PointerTo_ns3__ResultMS:
		return soap_out_PointerTo_ns3__ResultMS(soap, tag, id, (_ns3__ResultMS *const*)ptr, "ns3:ResultMS");
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequestMS:
		return soap_out_PointerTo_ns3__eGqueryRequestMS(soap, tag, id, (_ns3__eGqueryRequestMS *const*)ptr, "ns3:eGqueryRequestMS");
	case SOAP_TYPE_PointerTo_ns3__Result:
		return soap_out_PointerTo_ns3__Result(soap, tag, id, (_ns3__Result *const*)ptr, "ns3:Result");
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequest:
		return soap_out_PointerTo_ns3__eGqueryRequest(soap, tag, id, (_ns3__eGqueryRequest *const*)ptr, "ns3:eGqueryRequest");
	case SOAP_TYPE_PointerTons8__eSpellResultType:
		return soap_out_PointerTons8__eSpellResultType(soap, tag, id, (ns8__eSpellResultType *const*)ptr, "ns8:eSpellResultType");
	case SOAP_TYPE_PointerTons8__SpelledQueryType:
		return soap_out_PointerTons8__SpelledQueryType(soap, tag, id, (ns8__SpelledQueryType *const*)ptr, "ns8:SpelledQueryType");
	case SOAP_TYPE_PointerTons7__eLinkResultType:
		return soap_out_PointerTons7__eLinkResultType(soap, tag, id, (ns7__eLinkResultType *const*)ptr, "ns7:eLinkResultType");
	case SOAP_TYPE_PointerTons7__LinkSetType:
		return soap_out_PointerTons7__LinkSetType(soap, tag, id, (ns7__LinkSetType *const*)ptr, "ns7:LinkSetType");
	case SOAP_TYPE_PointerTons7__ProviderType:
		return soap_out_PointerTons7__ProviderType(soap, tag, id, (ns7__ProviderType *const*)ptr, "ns7:ProviderType");
	case SOAP_TYPE_PointerTons7__LinkType:
		return soap_out_PointerTons7__LinkType(soap, tag, id, (ns7__LinkType *const*)ptr, "ns7:LinkType");
	case SOAP_TYPE_PointerTons7__IdCheckListType:
		return soap_out_PointerTons7__IdCheckListType(soap, tag, id, (ns7__IdCheckListType *const*)ptr, "ns7:IdCheckListType");
	case SOAP_TYPE_PointerTons7__IdUrlListType:
		return soap_out_PointerTons7__IdUrlListType(soap, tag, id, (ns7__IdUrlListType *const*)ptr, "ns7:IdUrlListType");
	case SOAP_TYPE_PointerTons7__LinkSetDbType:
		return soap_out_PointerTons7__LinkSetDbType(soap, tag, id, (ns7__LinkSetDbType *const*)ptr, "ns7:LinkSetDbType");
	case SOAP_TYPE_PointerTons7__IdListType:
		return soap_out_PointerTons7__IdListType(soap, tag, id, (ns7__IdListType *const*)ptr, "ns7:IdListType");
	case SOAP_TYPE_PointerTons7__ObjUrlType:
		return soap_out_PointerTons7__ObjUrlType(soap, tag, id, (ns7__ObjUrlType *const*)ptr, "ns7:ObjUrlType");
	case SOAP_TYPE_PointerTons7__IdUrlSetType:
		return soap_out_PointerTons7__IdUrlSetType(soap, tag, id, (ns7__IdUrlSetType *const*)ptr, "ns7:IdUrlSetType");
	case SOAP_TYPE_PointerTons7__LinkInfoType:
		return soap_out_PointerTons7__LinkInfoType(soap, tag, id, (ns7__LinkInfoType *const*)ptr, "ns7:LinkInfoType");
	case SOAP_TYPE_PointerTons7__IdLinkSetType:
		return soap_out_PointerTons7__IdLinkSetType(soap, tag, id, (ns7__IdLinkSetType *const*)ptr, "ns7:IdLinkSetType");
	case SOAP_TYPE_PointerTons7__IdType:
		return soap_out_PointerTons7__IdType(soap, tag, id, (ns7__IdType *const*)ptr, "ns7:IdType");
	case SOAP_TYPE_PointerTons6__eSummaryResultType:
		return soap_out_PointerTons6__eSummaryResultType(soap, tag, id, (ns6__eSummaryResultType *const*)ptr, "ns6:eSummaryResultType");
	case SOAP_TYPE_PointerTons6__DocSumType:
		return soap_out_PointerTons6__DocSumType(soap, tag, id, (ns6__DocSumType *const*)ptr, "ns6:DocSumType");
	case SOAP_TYPE_PointerTons6__ItemType:
		return soap_out_PointerTons6__ItemType(soap, tag, id, (ns6__ItemType *const*)ptr, "ns6:ItemType");
	case SOAP_TYPE_PointerTons5__eSearchResultType:
		return soap_out_PointerTons5__eSearchResultType(soap, tag, id, (ns5__eSearchResultType *const*)ptr, "ns5:eSearchResultType");
	case SOAP_TYPE_PointerTons5__TranslationStackType:
		return soap_out_PointerTons5__TranslationStackType(soap, tag, id, (ns5__TranslationStackType *const*)ptr, "ns5:TranslationStackType");
	case SOAP_TYPE_PointerTons5__TranslationSetType:
		return soap_out_PointerTons5__TranslationSetType(soap, tag, id, (ns5__TranslationSetType *const*)ptr, "ns5:TranslationSetType");
	case SOAP_TYPE_PointerTons5__IdListType:
		return soap_out_PointerTons5__IdListType(soap, tag, id, (ns5__IdListType *const*)ptr, "ns5:IdListType");
	case SOAP_TYPE_PointerTons5__WarningListType:
		return soap_out_PointerTons5__WarningListType(soap, tag, id, (ns5__WarningListType *const*)ptr, "ns5:WarningListType");
	case SOAP_TYPE_PointerTons5__ErrorListType:
		return soap_out_PointerTons5__ErrorListType(soap, tag, id, (ns5__ErrorListType *const*)ptr, "ns5:ErrorListType");
	case SOAP_TYPE_PointerTons5__TermSetType:
		return soap_out_PointerTons5__TermSetType(soap, tag, id, (ns5__TermSetType *const*)ptr, "ns5:TermSetType");
	case SOAP_TYPE_PointerTons5__TranslationType:
		return soap_out_PointerTons5__TranslationType(soap, tag, id, (ns5__TranslationType *const*)ptr, "ns5:TranslationType");
	case SOAP_TYPE_PointerTons4__eInfoResultType:
		return soap_out_PointerTons4__eInfoResultType(soap, tag, id, (ns4__eInfoResultType *const*)ptr, "ns4:eInfoResultType");
	case SOAP_TYPE_PointerTons4__DbInfoType:
		return soap_out_PointerTons4__DbInfoType(soap, tag, id, (ns4__DbInfoType *const*)ptr, "ns4:DbInfoType");
	case SOAP_TYPE_PointerTons4__DbListType:
		return soap_out_PointerTons4__DbListType(soap, tag, id, (ns4__DbListType *const*)ptr, "ns4:DbListType");
	case SOAP_TYPE_PointerTons4__LinkType:
		return soap_out_PointerTons4__LinkType(soap, tag, id, (ns4__LinkType *const*)ptr, "ns4:LinkType");
	case SOAP_TYPE_PointerTons4__FieldType:
		return soap_out_PointerTons4__FieldType(soap, tag, id, (ns4__FieldType *const*)ptr, "ns4:FieldType");
	case SOAP_TYPE_PointerTons4__LinkListType:
		return soap_out_PointerTons4__LinkListType(soap, tag, id, (ns4__LinkListType *const*)ptr, "ns4:LinkListType");
	case SOAP_TYPE_PointerTons4__FieldListType:
		return soap_out_PointerTons4__FieldListType(soap, tag, id, (ns4__FieldListType *const*)ptr, "ns4:FieldListType");
	case SOAP_TYPE_PointerTons3__GQueryResultType:
		return soap_out_PointerTons3__GQueryResultType(soap, tag, id, (ns3__GQueryResultType *const*)ptr, "ns3:GQueryResultType");
	case SOAP_TYPE_PointerTons3__eGQueryResultType:
		return soap_out_PointerTons3__eGQueryResultType(soap, tag, id, (ns3__eGQueryResultType *const*)ptr, "ns3:eGQueryResultType");
	case SOAP_TYPE_PointerTons3__ResultItemType:
		return soap_out_PointerTons3__ResultItemType(soap, tag, id, (ns3__ResultItemType *const*)ptr, "ns3:ResultItemType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns8__eSpellRequestMS:
		((_ns8__eSpellRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns8__eSpellResultMS:
		((_ns8__eSpellResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns8__eSpellRequest:
		((_ns8__eSpellRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns8__eSpellResult:
		((_ns8__eSpellResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns8__eSpellResultType:
		((ns8__eSpellResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns8__SpelledQueryType:
		((ns8__SpelledQueryType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__eLinkRequestMS:
		((_ns7__eLinkRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__eLinkRequest:
		((_ns7__eLinkRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__eLinkResultMS:
		((_ns7__eLinkResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__eLinkResult:
		((_ns7__eLinkResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__eLinkResultType:
		((ns7__eLinkResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ProviderType:
		((ns7__ProviderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__ObjUrlType:
		((ns7__ObjUrlType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__LinkSetDbType:
		((ns7__LinkSetDbType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__LinkSetType:
		((ns7__LinkSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__LinkInfoType:
		((ns7__LinkInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__LinkType:
		((ns7__LinkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdUrlSetType:
		((ns7__IdUrlSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdUrlListType:
		((ns7__IdUrlListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdListType:
		((ns7__IdListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdLinkSetType:
		((ns7__IdLinkSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdCheckListType:
		((ns7__IdCheckListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__IdType:
		((ns7__IdType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__eSummaryResultMS:
		((_ns6__eSummaryResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__eSummaryRequestMS:
		((_ns6__eSummaryRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__eSummaryRequest:
		((_ns6__eSummaryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__eSummaryResult:
		((_ns6__eSummaryResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__eSummaryResultType:
		((ns6__eSummaryResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ItemType:
		((ns6__ItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DocSumType:
		((ns6__DocSumType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__eSearchResultMS:
		((_ns5__eSearchResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__eSearchRequestMS:
		((_ns5__eSearchRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__eSearchRequest:
		((_ns5__eSearchRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__eSearchResult:
		((_ns5__eSearchResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__eSearchResultType:
		((ns5__eSearchResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__WarningListType:
		((ns5__WarningListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TranslationStackType:
		((ns5__TranslationStackType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TranslationSetType:
		((ns5__TranslationSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TranslationType:
		((ns5__TranslationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TermSetType:
		((ns5__TermSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__IdListType:
		((ns5__IdListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ErrorListType:
		((ns5__ErrorListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__eInfoResultMS:
		((_ns4__eInfoResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__eInfoRequestMS:
		((_ns4__eInfoRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__eInfoRequest:
		((_ns4__eInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__eInfoResult:
		((_ns4__eInfoResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__eInfoResultType:
		((ns4__eInfoResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__LinkListType:
		((ns4__LinkListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__LinkType:
		((ns4__LinkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FieldListType:
		((ns4__FieldListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__FieldType:
		((ns4__FieldType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__DbListType:
		((ns4__DbListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__DbInfoType:
		((ns4__DbInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ResultMS:
		((_ns3__ResultMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__eGqueryRequestMS:
		((_ns3__eGqueryRequestMS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__eGqueryRequest:
		((_ns3__eGqueryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Result:
		((_ns3__Result *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__GQueryResultType:
		((ns3__GQueryResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__eGQueryResultType:
		((ns3__eGQueryResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ResultItemType:
		((ns3__ResultItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSpell_USCOREMS:
		soap_serialize___ns1__run_USCOREeSpell_USCOREMS(soap, (const struct __ns1__run_USCOREeSpell_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSpell:
		soap_serialize___ns1__run_USCOREeSpell(soap, (const struct __ns1__run_USCOREeSpell *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeLink_USCOREMS:
		soap_serialize___ns1__run_USCOREeLink_USCOREMS(soap, (const struct __ns1__run_USCOREeLink_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeLink:
		soap_serialize___ns1__run_USCOREeLink(soap, (const struct __ns1__run_USCOREeLink *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSummary_USCOREMS:
		soap_serialize___ns1__run_USCOREeSummary_USCOREMS(soap, (const struct __ns1__run_USCOREeSummary_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSummary:
		soap_serialize___ns1__run_USCOREeSummary(soap, (const struct __ns1__run_USCOREeSummary *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSearch_USCOREMS:
		soap_serialize___ns1__run_USCOREeSearch_USCOREMS(soap, (const struct __ns1__run_USCOREeSearch_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeSearch:
		soap_serialize___ns1__run_USCOREeSearch(soap, (const struct __ns1__run_USCOREeSearch *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeInfo_USCOREMS:
		soap_serialize___ns1__run_USCOREeInfo_USCOREMS(soap, (const struct __ns1__run_USCOREeInfo_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeInfo:
		soap_serialize___ns1__run_USCOREeInfo(soap, (const struct __ns1__run_USCOREeInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeGquery_USCOREMS:
		soap_serialize___ns1__run_USCOREeGquery_USCOREMS(soap, (const struct __ns1__run_USCOREeGquery_USCOREMS *)ptr);
		break;
	case SOAP_TYPE___ns1__run_USCOREeGquery:
		soap_serialize___ns1__run_USCOREeGquery(soap, (const struct __ns1__run_USCOREeGquery *)ptr);
		break;
	case SOAP_TYPE___ns8__union_SpelledQueryType:
		soap_serialize___ns8__union_SpelledQueryType(soap, (const struct __ns8__union_SpelledQueryType *)ptr);
		break;
	case SOAP_TYPE___ns7__union_IdCheckListType:
		soap_serialize___ns7__union_IdCheckListType(soap, (const struct __ns7__union_IdCheckListType *)ptr);
		break;
	case SOAP_TYPE___ns6__union_ItemType:
		soap_serialize___ns6__union_ItemType(soap, (const struct __ns6__union_ItemType *)ptr);
		break;
	case SOAP_TYPE___ns5__union_TranslationStackType:
		soap_serialize___ns5__union_TranslationStackType(soap, (const struct __ns5__union_TranslationStackType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns8__eSpellResultMS:
		soap_serialize_PointerTo_ns8__eSpellResultMS(soap, (_ns8__eSpellResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns8__eSpellRequestMS:
		soap_serialize_PointerTo_ns8__eSpellRequestMS(soap, (_ns8__eSpellRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns8__eSpellResult:
		soap_serialize_PointerTo_ns8__eSpellResult(soap, (_ns8__eSpellResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns8__eSpellRequest:
		soap_serialize_PointerTo_ns8__eSpellRequest(soap, (_ns8__eSpellRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__eLinkResultMS:
		soap_serialize_PointerTo_ns7__eLinkResultMS(soap, (_ns7__eLinkResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__eLinkRequestMS:
		soap_serialize_PointerTo_ns7__eLinkRequestMS(soap, (_ns7__eLinkRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__eLinkResult:
		soap_serialize_PointerTo_ns7__eLinkResult(soap, (_ns7__eLinkResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__eLinkRequest:
		soap_serialize_PointerTo_ns7__eLinkRequest(soap, (_ns7__eLinkRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__eSummaryResultMS:
		soap_serialize_PointerTo_ns6__eSummaryResultMS(soap, (_ns6__eSummaryResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequestMS:
		soap_serialize_PointerTo_ns6__eSummaryRequestMS(soap, (_ns6__eSummaryRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__eSummaryResult:
		soap_serialize_PointerTo_ns6__eSummaryResult(soap, (_ns6__eSummaryResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__eSummaryRequest:
		soap_serialize_PointerTo_ns6__eSummaryRequest(soap, (_ns6__eSummaryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__eSearchResultMS:
		soap_serialize_PointerTo_ns5__eSearchResultMS(soap, (_ns5__eSearchResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__eSearchRequestMS:
		soap_serialize_PointerTo_ns5__eSearchRequestMS(soap, (_ns5__eSearchRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__eSearchResult:
		soap_serialize_PointerTo_ns5__eSearchResult(soap, (_ns5__eSearchResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__eSearchRequest:
		soap_serialize_PointerTo_ns5__eSearchRequest(soap, (_ns5__eSearchRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__eInfoResultMS:
		soap_serialize_PointerTo_ns4__eInfoResultMS(soap, (_ns4__eInfoResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__eInfoRequestMS:
		soap_serialize_PointerTo_ns4__eInfoRequestMS(soap, (_ns4__eInfoRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__eInfoResult:
		soap_serialize_PointerTo_ns4__eInfoResult(soap, (_ns4__eInfoResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__eInfoRequest:
		soap_serialize_PointerTo_ns4__eInfoRequest(soap, (_ns4__eInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__ResultMS:
		soap_serialize_PointerTo_ns3__ResultMS(soap, (_ns3__ResultMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequestMS:
		soap_serialize_PointerTo_ns3__eGqueryRequestMS(soap, (_ns3__eGqueryRequestMS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__Result:
		soap_serialize_PointerTo_ns3__Result(soap, (_ns3__Result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__eGqueryRequest:
		soap_serialize_PointerTo_ns3__eGqueryRequest(soap, (_ns3__eGqueryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons8__eSpellResultType:
		soap_serialize_PointerTons8__eSpellResultType(soap, (ns8__eSpellResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons8__SpelledQueryType:
		soap_serialize_PointerTons8__SpelledQueryType(soap, (ns8__SpelledQueryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns8__union_SpelledQueryType:
		soap_serialize_PointerTo__ns8__union_SpelledQueryType(soap, (struct __ns8__union_SpelledQueryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__eLinkResultType:
		soap_serialize_PointerTons7__eLinkResultType(soap, (ns7__eLinkResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__LinkSetType:
		soap_serialize_PointerTons7__LinkSetType(soap, (ns7__LinkSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ProviderType:
		soap_serialize_PointerTons7__ProviderType(soap, (ns7__ProviderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__LinkType:
		soap_serialize_PointerTons7__LinkType(soap, (ns7__LinkType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdCheckListType:
		soap_serialize_PointerTons7__IdCheckListType(soap, (ns7__IdCheckListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdUrlListType:
		soap_serialize_PointerTons7__IdUrlListType(soap, (ns7__IdUrlListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__LinkSetDbType:
		soap_serialize_PointerTons7__LinkSetDbType(soap, (ns7__LinkSetDbType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdListType:
		soap_serialize_PointerTons7__IdListType(soap, (ns7__IdListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__ObjUrlType:
		soap_serialize_PointerTons7__ObjUrlType(soap, (ns7__ObjUrlType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdUrlSetType:
		soap_serialize_PointerTons7__IdUrlSetType(soap, (ns7__IdUrlSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__LinkInfoType:
		soap_serialize_PointerTons7__LinkInfoType(soap, (ns7__LinkInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns7__union_IdCheckListType:
		soap_serialize_PointerTo__ns7__union_IdCheckListType(soap, (struct __ns7__union_IdCheckListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdLinkSetType:
		soap_serialize_PointerTons7__IdLinkSetType(soap, (ns7__IdLinkSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__IdType:
		soap_serialize_PointerTons7__IdType(soap, (ns7__IdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__eSummaryResultType:
		soap_serialize_PointerTons6__eSummaryResultType(soap, (ns6__eSummaryResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DocSumType:
		soap_serialize_PointerTons6__DocSumType(soap, (ns6__DocSumType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns6__union_ItemType:
		soap_serialize_PointerTo__ns6__union_ItemType(soap, (struct __ns6__union_ItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ItemType:
		soap_serialize_PointerTons6__ItemType(soap, (ns6__ItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__eSearchResultType:
		soap_serialize_PointerTons5__eSearchResultType(soap, (ns5__eSearchResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TranslationStackType:
		soap_serialize_PointerTons5__TranslationStackType(soap, (ns5__TranslationStackType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TranslationSetType:
		soap_serialize_PointerTons5__TranslationSetType(soap, (ns5__TranslationSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__IdListType:
		soap_serialize_PointerTons5__IdListType(soap, (ns5__IdListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__WarningListType:
		soap_serialize_PointerTons5__WarningListType(soap, (ns5__WarningListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ErrorListType:
		soap_serialize_PointerTons5__ErrorListType(soap, (ns5__ErrorListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns5__union_TranslationStackType:
		soap_serialize_PointerTo__ns5__union_TranslationStackType(soap, (struct __ns5__union_TranslationStackType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TermSetType:
		soap_serialize_PointerTons5__TermSetType(soap, (ns5__TermSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TranslationType:
		soap_serialize_PointerTons5__TranslationType(soap, (ns5__TranslationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__eInfoResultType:
		soap_serialize_PointerTons4__eInfoResultType(soap, (ns4__eInfoResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DbInfoType:
		soap_serialize_PointerTons4__DbInfoType(soap, (ns4__DbInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DbListType:
		soap_serialize_PointerTons4__DbListType(soap, (ns4__DbListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__LinkType:
		soap_serialize_PointerTons4__LinkType(soap, (ns4__LinkType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FieldType:
		soap_serialize_PointerTons4__FieldType(soap, (ns4__FieldType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__LinkListType:
		soap_serialize_PointerTons4__LinkListType(soap, (ns4__LinkListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FieldListType:
		soap_serialize_PointerTons4__FieldListType(soap, (ns4__FieldListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__GQueryResultType:
		soap_serialize_PointerTons3__GQueryResultType(soap, (ns3__GQueryResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__eGQueryResultType:
		soap_serialize_PointerTons3__eGQueryResultType(soap, (ns3__eGQueryResultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ResultItemType:
		soap_serialize_PointerTons3__ResultItemType(soap, (ns3__ResultItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ResultItemType:
		return (void*)soap_instantiate_ns3__ResultItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__eGQueryResultType:
		return (void*)soap_instantiate_ns3__eGQueryResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__GQueryResultType:
		return (void*)soap_instantiate_ns3__GQueryResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Result:
		return (void*)soap_instantiate__ns3__Result(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__eGqueryRequest:
		return (void*)soap_instantiate__ns3__eGqueryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__eGqueryRequestMS:
		return (void*)soap_instantiate__ns3__eGqueryRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ResultMS:
		return (void*)soap_instantiate__ns3__ResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DbInfoType:
		return (void*)soap_instantiate_ns4__DbInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DbListType:
		return (void*)soap_instantiate_ns4__DbListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FieldType:
		return (void*)soap_instantiate_ns4__FieldType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__FieldListType:
		return (void*)soap_instantiate_ns4__FieldListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__LinkType:
		return (void*)soap_instantiate_ns4__LinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__LinkListType:
		return (void*)soap_instantiate_ns4__LinkListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__eInfoResultType:
		return (void*)soap_instantiate_ns4__eInfoResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__eInfoResult:
		return (void*)soap_instantiate__ns4__eInfoResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__eInfoRequest:
		return (void*)soap_instantiate__ns4__eInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__eInfoRequestMS:
		return (void*)soap_instantiate__ns4__eInfoRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__eInfoResultMS:
		return (void*)soap_instantiate__ns4__eInfoResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ErrorListType:
		return (void*)soap_instantiate_ns5__ErrorListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__IdListType:
		return (void*)soap_instantiate_ns5__IdListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TermSetType:
		return (void*)soap_instantiate_ns5__TermSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TranslationType:
		return (void*)soap_instantiate_ns5__TranslationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TranslationSetType:
		return (void*)soap_instantiate_ns5__TranslationSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__union_TranslationStackType:
		return (void*)soap_instantiate___ns5__union_TranslationStackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TranslationStackType:
		return (void*)soap_instantiate_ns5__TranslationStackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__WarningListType:
		return (void*)soap_instantiate_ns5__WarningListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__eSearchResultType:
		return (void*)soap_instantiate_ns5__eSearchResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__eSearchResult:
		return (void*)soap_instantiate__ns5__eSearchResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__eSearchRequest:
		return (void*)soap_instantiate__ns5__eSearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__eSearchRequestMS:
		return (void*)soap_instantiate__ns5__eSearchRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__eSearchResultMS:
		return (void*)soap_instantiate__ns5__eSearchResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DocSumType:
		return (void*)soap_instantiate_ns6__DocSumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__union_ItemType:
		return (void*)soap_instantiate___ns6__union_ItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ItemType:
		return (void*)soap_instantiate_ns6__ItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__eSummaryResultType:
		return (void*)soap_instantiate_ns6__eSummaryResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__eSummaryResult:
		return (void*)soap_instantiate__ns6__eSummaryResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__eSummaryRequest:
		return (void*)soap_instantiate__ns6__eSummaryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__eSummaryRequestMS:
		return (void*)soap_instantiate__ns6__eSummaryRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__eSummaryResultMS:
		return (void*)soap_instantiate__ns6__eSummaryResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__union_IdCheckListType:
		return (void*)soap_instantiate___ns7__union_IdCheckListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdCheckListType:
		return (void*)soap_instantiate_ns7__IdCheckListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdLinkSetType:
		return (void*)soap_instantiate_ns7__IdLinkSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdListType:
		return (void*)soap_instantiate_ns7__IdListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdUrlListType:
		return (void*)soap_instantiate_ns7__IdUrlListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdUrlSetType:
		return (void*)soap_instantiate_ns7__IdUrlSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__LinkType:
		return (void*)soap_instantiate_ns7__LinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__LinkInfoType:
		return (void*)soap_instantiate_ns7__LinkInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__LinkSetType:
		return (void*)soap_instantiate_ns7__LinkSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__LinkSetDbType:
		return (void*)soap_instantiate_ns7__LinkSetDbType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ObjUrlType:
		return (void*)soap_instantiate_ns7__ObjUrlType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ProviderType:
		return (void*)soap_instantiate_ns7__ProviderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__eLinkResultType:
		return (void*)soap_instantiate_ns7__eLinkResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__eLinkResult:
		return (void*)soap_instantiate__ns7__eLinkResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__eLinkResultMS:
		return (void*)soap_instantiate__ns7__eLinkResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__eLinkRequest:
		return (void*)soap_instantiate__ns7__eLinkRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__eLinkRequestMS:
		return (void*)soap_instantiate__ns7__eLinkRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__union_SpelledQueryType:
		return (void*)soap_instantiate___ns8__union_SpelledQueryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns8__SpelledQueryType:
		return (void*)soap_instantiate_ns8__SpelledQueryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns8__eSpellResultType:
		return (void*)soap_instantiate_ns8__eSpellResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__eSpellResult:
		return (void*)soap_instantiate__ns8__eSpellResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__eSpellRequest:
		return (void*)soap_instantiate__ns8__eSpellRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__eSpellResultMS:
		return (void*)soap_instantiate__ns8__eSpellResultMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__eSpellRequestMS:
		return (void*)soap_instantiate__ns8__eSpellRequestMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__IdType:
		return (void*)soap_instantiate_ns7__IdType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeGquery:
		return (void*)soap_instantiate___ns1__run_USCOREeGquery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeGquery_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeGquery_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeInfo:
		return (void*)soap_instantiate___ns1__run_USCOREeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeInfo_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeInfo_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSearch:
		return (void*)soap_instantiate___ns1__run_USCOREeSearch(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSearch_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeSearch_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSummary:
		return (void*)soap_instantiate___ns1__run_USCOREeSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSummary_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeSummary_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeLink:
		return (void*)soap_instantiate___ns1__run_USCOREeLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeLink_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeLink_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSpell:
		return (void*)soap_instantiate___ns1__run_USCOREeSpell(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__run_USCOREeSpell_USCOREMS:
		return (void*)soap_instantiate___ns1__run_USCOREeSpell_USCOREMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__LinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetDbType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdUrlSetType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__IdType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkInfoType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocSumType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__DocSumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__ItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TranslationType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__TranslationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__LinkType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__LinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FieldType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__FieldType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ResultItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__ResultItemType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ResultItemType:
		if (p->size < 0)
			delete (ns3__ResultItemType*)p->ptr;
		else
			delete[] (ns3__ResultItemType*)p->ptr;
		break;
	case SOAP_TYPE_ns3__eGQueryResultType:
		if (p->size < 0)
			delete (ns3__eGQueryResultType*)p->ptr;
		else
			delete[] (ns3__eGQueryResultType*)p->ptr;
		break;
	case SOAP_TYPE_ns3__GQueryResultType:
		if (p->size < 0)
			delete (ns3__GQueryResultType*)p->ptr;
		else
			delete[] (ns3__GQueryResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns3__Result:
		if (p->size < 0)
			delete (_ns3__Result*)p->ptr;
		else
			delete[] (_ns3__Result*)p->ptr;
		break;
	case SOAP_TYPE__ns3__eGqueryRequest:
		if (p->size < 0)
			delete (_ns3__eGqueryRequest*)p->ptr;
		else
			delete[] (_ns3__eGqueryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns3__eGqueryRequestMS:
		if (p->size < 0)
			delete (_ns3__eGqueryRequestMS*)p->ptr;
		else
			delete[] (_ns3__eGqueryRequestMS*)p->ptr;
		break;
	case SOAP_TYPE__ns3__ResultMS:
		if (p->size < 0)
			delete (_ns3__ResultMS*)p->ptr;
		else
			delete[] (_ns3__ResultMS*)p->ptr;
		break;
	case SOAP_TYPE_ns4__DbInfoType:
		if (p->size < 0)
			delete (ns4__DbInfoType*)p->ptr;
		else
			delete[] (ns4__DbInfoType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__DbListType:
		if (p->size < 0)
			delete (ns4__DbListType*)p->ptr;
		else
			delete[] (ns4__DbListType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FieldType:
		if (p->size < 0)
			delete (ns4__FieldType*)p->ptr;
		else
			delete[] (ns4__FieldType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__FieldListType:
		if (p->size < 0)
			delete (ns4__FieldListType*)p->ptr;
		else
			delete[] (ns4__FieldListType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__LinkType:
		if (p->size < 0)
			delete (ns4__LinkType*)p->ptr;
		else
			delete[] (ns4__LinkType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__LinkListType:
		if (p->size < 0)
			delete (ns4__LinkListType*)p->ptr;
		else
			delete[] (ns4__LinkListType*)p->ptr;
		break;
	case SOAP_TYPE_ns4__eInfoResultType:
		if (p->size < 0)
			delete (ns4__eInfoResultType*)p->ptr;
		else
			delete[] (ns4__eInfoResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns4__eInfoResult:
		if (p->size < 0)
			delete (_ns4__eInfoResult*)p->ptr;
		else
			delete[] (_ns4__eInfoResult*)p->ptr;
		break;
	case SOAP_TYPE__ns4__eInfoRequest:
		if (p->size < 0)
			delete (_ns4__eInfoRequest*)p->ptr;
		else
			delete[] (_ns4__eInfoRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns4__eInfoRequestMS:
		if (p->size < 0)
			delete (_ns4__eInfoRequestMS*)p->ptr;
		else
			delete[] (_ns4__eInfoRequestMS*)p->ptr;
		break;
	case SOAP_TYPE__ns4__eInfoResultMS:
		if (p->size < 0)
			delete (_ns4__eInfoResultMS*)p->ptr;
		else
			delete[] (_ns4__eInfoResultMS*)p->ptr;
		break;
	case SOAP_TYPE_ns5__ErrorListType:
		if (p->size < 0)
			delete (ns5__ErrorListType*)p->ptr;
		else
			delete[] (ns5__ErrorListType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__IdListType:
		if (p->size < 0)
			delete (ns5__IdListType*)p->ptr;
		else
			delete[] (ns5__IdListType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__TermSetType:
		if (p->size < 0)
			delete (ns5__TermSetType*)p->ptr;
		else
			delete[] (ns5__TermSetType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__TranslationType:
		if (p->size < 0)
			delete (ns5__TranslationType*)p->ptr;
		else
			delete[] (ns5__TranslationType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__TranslationSetType:
		if (p->size < 0)
			delete (ns5__TranslationSetType*)p->ptr;
		else
			delete[] (ns5__TranslationSetType*)p->ptr;
		break;
	case SOAP_TYPE___ns5__union_TranslationStackType:
		if (p->size < 0)
			delete (struct __ns5__union_TranslationStackType*)p->ptr;
		else
			delete[] (struct __ns5__union_TranslationStackType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__TranslationStackType:
		if (p->size < 0)
			delete (ns5__TranslationStackType*)p->ptr;
		else
			delete[] (ns5__TranslationStackType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__WarningListType:
		if (p->size < 0)
			delete (ns5__WarningListType*)p->ptr;
		else
			delete[] (ns5__WarningListType*)p->ptr;
		break;
	case SOAP_TYPE_ns5__eSearchResultType:
		if (p->size < 0)
			delete (ns5__eSearchResultType*)p->ptr;
		else
			delete[] (ns5__eSearchResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns5__eSearchResult:
		if (p->size < 0)
			delete (_ns5__eSearchResult*)p->ptr;
		else
			delete[] (_ns5__eSearchResult*)p->ptr;
		break;
	case SOAP_TYPE__ns5__eSearchRequest:
		if (p->size < 0)
			delete (_ns5__eSearchRequest*)p->ptr;
		else
			delete[] (_ns5__eSearchRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns5__eSearchRequestMS:
		if (p->size < 0)
			delete (_ns5__eSearchRequestMS*)p->ptr;
		else
			delete[] (_ns5__eSearchRequestMS*)p->ptr;
		break;
	case SOAP_TYPE__ns5__eSearchResultMS:
		if (p->size < 0)
			delete (_ns5__eSearchResultMS*)p->ptr;
		else
			delete[] (_ns5__eSearchResultMS*)p->ptr;
		break;
	case SOAP_TYPE_ns6__DocSumType:
		if (p->size < 0)
			delete (ns6__DocSumType*)p->ptr;
		else
			delete[] (ns6__DocSumType*)p->ptr;
		break;
	case SOAP_TYPE___ns6__union_ItemType:
		if (p->size < 0)
			delete (struct __ns6__union_ItemType*)p->ptr;
		else
			delete[] (struct __ns6__union_ItemType*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ItemType:
		if (p->size < 0)
			delete (ns6__ItemType*)p->ptr;
		else
			delete[] (ns6__ItemType*)p->ptr;
		break;
	case SOAP_TYPE_ns6__eSummaryResultType:
		if (p->size < 0)
			delete (ns6__eSummaryResultType*)p->ptr;
		else
			delete[] (ns6__eSummaryResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns6__eSummaryResult:
		if (p->size < 0)
			delete (_ns6__eSummaryResult*)p->ptr;
		else
			delete[] (_ns6__eSummaryResult*)p->ptr;
		break;
	case SOAP_TYPE__ns6__eSummaryRequest:
		if (p->size < 0)
			delete (_ns6__eSummaryRequest*)p->ptr;
		else
			delete[] (_ns6__eSummaryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns6__eSummaryRequestMS:
		if (p->size < 0)
			delete (_ns6__eSummaryRequestMS*)p->ptr;
		else
			delete[] (_ns6__eSummaryRequestMS*)p->ptr;
		break;
	case SOAP_TYPE__ns6__eSummaryResultMS:
		if (p->size < 0)
			delete (_ns6__eSummaryResultMS*)p->ptr;
		else
			delete[] (_ns6__eSummaryResultMS*)p->ptr;
		break;
	case SOAP_TYPE___ns7__union_IdCheckListType:
		if (p->size < 0)
			delete (struct __ns7__union_IdCheckListType*)p->ptr;
		else
			delete[] (struct __ns7__union_IdCheckListType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdCheckListType:
		if (p->size < 0)
			delete (ns7__IdCheckListType*)p->ptr;
		else
			delete[] (ns7__IdCheckListType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdLinkSetType:
		if (p->size < 0)
			delete (ns7__IdLinkSetType*)p->ptr;
		else
			delete[] (ns7__IdLinkSetType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdListType:
		if (p->size < 0)
			delete (ns7__IdListType*)p->ptr;
		else
			delete[] (ns7__IdListType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdUrlListType:
		if (p->size < 0)
			delete (ns7__IdUrlListType*)p->ptr;
		else
			delete[] (ns7__IdUrlListType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdUrlSetType:
		if (p->size < 0)
			delete (ns7__IdUrlSetType*)p->ptr;
		else
			delete[] (ns7__IdUrlSetType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__LinkType:
		if (p->size < 0)
			delete (ns7__LinkType*)p->ptr;
		else
			delete[] (ns7__LinkType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__LinkInfoType:
		if (p->size < 0)
			delete (ns7__LinkInfoType*)p->ptr;
		else
			delete[] (ns7__LinkInfoType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__LinkSetType:
		if (p->size < 0)
			delete (ns7__LinkSetType*)p->ptr;
		else
			delete[] (ns7__LinkSetType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__LinkSetDbType:
		if (p->size < 0)
			delete (ns7__LinkSetDbType*)p->ptr;
		else
			delete[] (ns7__LinkSetDbType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ObjUrlType:
		if (p->size < 0)
			delete (ns7__ObjUrlType*)p->ptr;
		else
			delete[] (ns7__ObjUrlType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__ProviderType:
		if (p->size < 0)
			delete (ns7__ProviderType*)p->ptr;
		else
			delete[] (ns7__ProviderType*)p->ptr;
		break;
	case SOAP_TYPE_ns7__eLinkResultType:
		if (p->size < 0)
			delete (ns7__eLinkResultType*)p->ptr;
		else
			delete[] (ns7__eLinkResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns7__eLinkResult:
		if (p->size < 0)
			delete (_ns7__eLinkResult*)p->ptr;
		else
			delete[] (_ns7__eLinkResult*)p->ptr;
		break;
	case SOAP_TYPE__ns7__eLinkResultMS:
		if (p->size < 0)
			delete (_ns7__eLinkResultMS*)p->ptr;
		else
			delete[] (_ns7__eLinkResultMS*)p->ptr;
		break;
	case SOAP_TYPE__ns7__eLinkRequest:
		if (p->size < 0)
			delete (_ns7__eLinkRequest*)p->ptr;
		else
			delete[] (_ns7__eLinkRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns7__eLinkRequestMS:
		if (p->size < 0)
			delete (_ns7__eLinkRequestMS*)p->ptr;
		else
			delete[] (_ns7__eLinkRequestMS*)p->ptr;
		break;
	case SOAP_TYPE___ns8__union_SpelledQueryType:
		if (p->size < 0)
			delete (struct __ns8__union_SpelledQueryType*)p->ptr;
		else
			delete[] (struct __ns8__union_SpelledQueryType*)p->ptr;
		break;
	case SOAP_TYPE_ns8__SpelledQueryType:
		if (p->size < 0)
			delete (ns8__SpelledQueryType*)p->ptr;
		else
			delete[] (ns8__SpelledQueryType*)p->ptr;
		break;
	case SOAP_TYPE_ns8__eSpellResultType:
		if (p->size < 0)
			delete (ns8__eSpellResultType*)p->ptr;
		else
			delete[] (ns8__eSpellResultType*)p->ptr;
		break;
	case SOAP_TYPE__ns8__eSpellResult:
		if (p->size < 0)
			delete (_ns8__eSpellResult*)p->ptr;
		else
			delete[] (_ns8__eSpellResult*)p->ptr;
		break;
	case SOAP_TYPE__ns8__eSpellRequest:
		if (p->size < 0)
			delete (_ns8__eSpellRequest*)p->ptr;
		else
			delete[] (_ns8__eSpellRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns8__eSpellResultMS:
		if (p->size < 0)
			delete (_ns8__eSpellResultMS*)p->ptr;
		else
			delete[] (_ns8__eSpellResultMS*)p->ptr;
		break;
	case SOAP_TYPE__ns8__eSpellRequestMS:
		if (p->size < 0)
			delete (_ns8__eSpellRequestMS*)p->ptr;
		else
			delete[] (_ns8__eSpellRequestMS*)p->ptr;
		break;
	case SOAP_TYPE_ns7__IdType:
		if (p->size < 0)
			delete (ns7__IdType*)p->ptr;
		else
			delete[] (ns7__IdType*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeGquery:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeGquery*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeGquery*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeGquery_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeGquery_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeGquery_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeInfo:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeInfo*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeInfo_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeInfo_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeInfo_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSearch:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSearch*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSearch*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSearch_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSearch_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSearch_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSummary:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSummary*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSummary*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSummary_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSummary_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSummary_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeLink:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeLink*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeLink*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeLink_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeLink_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeLink_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSpell:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSpell*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSpell*)p->ptr;
		break;
	case SOAP_TYPE___ns1__run_USCOREeSpell_USCOREMS:
		if (p->size < 0)
			delete (struct __ns1__run_USCOREeSpell_USCOREMS*)p->ptr;
		else
			delete[] (struct __ns1__run_USCOREeSpell_USCOREMS*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetType:
		if (p->size < 0)
			delete (std::vector<ns7__LinkSetType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__LinkSetType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType:
		if (p->size < 0)
			delete (std::vector<ns7__LinkType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__LinkType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetDbType:
		if (p->size < 0)
			delete (std::vector<ns7__LinkSetDbType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__LinkSetDbType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType:
		if (p->size < 0)
			delete (std::vector<ns7__ObjUrlType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__ObjUrlType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdUrlSetType:
		if (p->size < 0)
			delete (std::vector<ns7__IdUrlSetType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__IdUrlSetType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdType:
		if (p->size < 0)
			delete (std::vector<ns7__IdType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__IdType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkInfoType:
		if (p->size < 0)
			delete (std::vector<ns7__LinkInfoType * >*)p->ptr;
		else
			delete[] (std::vector<ns7__LinkInfoType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocSumType:
		if (p->size < 0)
			delete (std::vector<ns6__DocSumType * >*)p->ptr;
		else
			delete[] (std::vector<ns6__DocSumType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ItemType:
		if (p->size < 0)
			delete (std::vector<ns6__ItemType * >*)p->ptr;
		else
			delete[] (std::vector<ns6__ItemType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TranslationType:
		if (p->size < 0)
			delete (std::vector<ns5__TranslationType * >*)p->ptr;
		else
			delete[] (std::vector<ns5__TranslationType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__LinkType:
		if (p->size < 0)
			delete (std::vector<ns4__LinkType * >*)p->ptr;
		else
			delete[] (std::vector<ns4__LinkType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FieldType:
		if (p->size < 0)
			delete (std::vector<ns4__FieldType * >*)p->ptr;
		else
			delete[] (std::vector<ns4__FieldType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ResultItemType:
		if (p->size < 0)
			delete (std::vector<ns3__ResultItemType * >*)p->ptr;
		else
			delete[] (std::vector<ns3__ResultItemType * >*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__LinkSetType * >*)p)[len] = *(ns7__LinkSetType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__LinkType * >*)p)[len] = *(ns7__LinkType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetDbType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__LinkSetDbType * >*)p)[len] = *(ns7__LinkSetDbType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__ObjUrlType * >*)p)[len] = *(ns7__ObjUrlType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdUrlSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__IdUrlSetType * >*)p)[len] = *(ns7__IdUrlSetType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__IdType * >*)p)[len] = *(ns7__IdType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns7__LinkInfoType * >*)p)[len] = *(ns7__LinkInfoType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocSumType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__DocSumType * >*)p)[len] = *(ns6__DocSumType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__ItemType * >*)p)[len] = *(ns6__ItemType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TranslationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__TranslationType * >*)p)[len] = *(ns5__TranslationType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__LinkType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__LinkType * >*)p)[len] = *(ns4__LinkType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__FieldType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__FieldType * >*)p)[len] = *(ns4__FieldType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ResultItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__ResultItemType * >*)p)[len] = *(ns3__ResultItemType **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__IdType_HasNeighbor(struct soap *soap, enum _ns7__IdType_HasNeighbor *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns7__IdType_HasNeighbor
	*a = SOAP_DEFAULT__ns7__IdType_HasNeighbor;
#else
	*a = (enum _ns7__IdType_HasNeighbor)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__IdType_HasNeighbor(struct soap *soap, const enum _ns7__IdType_HasNeighbor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns7__IdType_HasNeighbor);
	if (soap_out__ns7__IdType_HasNeighbor(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__ns7__IdType_HasNeighbor[] =
{	{ (long)_ns7__IdType_HasNeighbor__Y, "Y" },
	{ (long)_ns7__IdType_HasNeighbor__N, "N" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns7__IdType_HasNeighbor2s(struct soap *soap, enum _ns7__IdType_HasNeighbor n)
{	const char *s = soap_code_str(soap_codes__ns7__IdType_HasNeighbor, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__IdType_HasNeighbor(struct soap *soap, const char *tag, int id, const enum _ns7__IdType_HasNeighbor *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__IdType_HasNeighbor), type);
	soap_send(soap, soap__ns7__IdType_HasNeighbor2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _ns7__IdType_HasNeighbor * SOAP_FMAC4 soap_get__ns7__IdType_HasNeighbor(struct soap *soap, enum _ns7__IdType_HasNeighbor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__IdType_HasNeighbor(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns7__IdType_HasNeighbor(struct soap *soap, const char *s, enum _ns7__IdType_HasNeighbor *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__ns7__IdType_HasNeighbor, s);
	if (map)
		*a = (enum _ns7__IdType_HasNeighbor)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns7__IdType_HasNeighbor)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns7__IdType_HasNeighbor * SOAP_FMAC4 soap_in__ns7__IdType_HasNeighbor(struct soap *soap, const char *tag, enum _ns7__IdType_HasNeighbor *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns7__IdType_HasNeighbor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__IdType_HasNeighbor, sizeof(enum _ns7__IdType_HasNeighbor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns7__IdType_HasNeighbor(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns7__IdType_HasNeighbor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__IdType_HasNeighbor, 0, sizeof(enum _ns7__IdType_HasNeighbor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__IdType_HasLinkOut(struct soap *soap, enum _ns7__IdType_HasLinkOut *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns7__IdType_HasLinkOut
	*a = SOAP_DEFAULT__ns7__IdType_HasLinkOut;
#else
	*a = (enum _ns7__IdType_HasLinkOut)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__IdType_HasLinkOut(struct soap *soap, const enum _ns7__IdType_HasLinkOut *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns7__IdType_HasLinkOut);
	if (soap_out__ns7__IdType_HasLinkOut(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__ns7__IdType_HasLinkOut[] =
{	{ (long)_ns7__IdType_HasLinkOut__Y, "Y" },
	{ (long)_ns7__IdType_HasLinkOut__N, "N" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns7__IdType_HasLinkOut2s(struct soap *soap, enum _ns7__IdType_HasLinkOut n)
{	const char *s = soap_code_str(soap_codes__ns7__IdType_HasLinkOut, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__IdType_HasLinkOut(struct soap *soap, const char *tag, int id, const enum _ns7__IdType_HasLinkOut *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__IdType_HasLinkOut), type);
	soap_send(soap, soap__ns7__IdType_HasLinkOut2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _ns7__IdType_HasLinkOut * SOAP_FMAC4 soap_get__ns7__IdType_HasLinkOut(struct soap *soap, enum _ns7__IdType_HasLinkOut *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__IdType_HasLinkOut(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns7__IdType_HasLinkOut(struct soap *soap, const char *s, enum _ns7__IdType_HasLinkOut *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__ns7__IdType_HasLinkOut, s);
	if (map)
		*a = (enum _ns7__IdType_HasLinkOut)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns7__IdType_HasLinkOut)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns7__IdType_HasLinkOut * SOAP_FMAC4 soap_in__ns7__IdType_HasLinkOut(struct soap *soap, const char *tag, enum _ns7__IdType_HasLinkOut *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns7__IdType_HasLinkOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__IdType_HasLinkOut, sizeof(enum _ns7__IdType_HasLinkOut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns7__IdType_HasLinkOut(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns7__IdType_HasLinkOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__IdType_HasLinkOut, 0, sizeof(enum _ns7__IdType_HasLinkOut), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__ItemType_Type(struct soap *soap, enum _ns6__ItemType_Type *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns6__ItemType_Type
	*a = SOAP_DEFAULT__ns6__ItemType_Type;
#else
	*a = (enum _ns6__ItemType_Type)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__ItemType_Type(struct soap *soap, const enum _ns6__ItemType_Type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns6__ItemType_Type);
	if (soap_out__ns6__ItemType_Type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__ns6__ItemType_Type[] =
{	{ (long)_ns6__ItemType_Type__Integer, "Integer" },
	{ (long)_ns6__ItemType_Type__Date, "Date" },
	{ (long)_ns6__ItemType_Type__String, "String" },
	{ (long)_ns6__ItemType_Type__Structure, "Structure" },
	{ (long)_ns6__ItemType_Type__List, "List" },
	{ (long)_ns6__ItemType_Type__Flags, "Flags" },
	{ (long)_ns6__ItemType_Type__Qualifier, "Qualifier" },
	{ (long)_ns6__ItemType_Type__Enumerator, "Enumerator" },
	{ (long)_ns6__ItemType_Type__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns6__ItemType_Type2s(struct soap *soap, enum _ns6__ItemType_Type n)
{	const char *s = soap_code_str(soap_codes__ns6__ItemType_Type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__ItemType_Type(struct soap *soap, const char *tag, int id, const enum _ns6__ItemType_Type *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__ItemType_Type), type);
	soap_send(soap, soap__ns6__ItemType_Type2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _ns6__ItemType_Type * SOAP_FMAC4 soap_get__ns6__ItemType_Type(struct soap *soap, enum _ns6__ItemType_Type *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__ItemType_Type(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns6__ItemType_Type(struct soap *soap, const char *s, enum _ns6__ItemType_Type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__ns6__ItemType_Type, s);
	if (map)
		*a = (enum _ns6__ItemType_Type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns6__ItemType_Type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns6__ItemType_Type * SOAP_FMAC4 soap_in__ns6__ItemType_Type(struct soap *soap, const char *tag, enum _ns6__ItemType_Type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns6__ItemType_Type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__ItemType_Type, sizeof(enum _ns6__ItemType_Type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns6__ItemType_Type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns6__ItemType_Type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__ItemType_Type, 0, sizeof(enum _ns6__ItemType_Type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns8__eSpellRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequestMS*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequestMS*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequestMS*)this)->email);
	/* transient soap skipped */
}

void _ns8__eSpellRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns8__eSpellRequestMS*)this)->db = NULL;
	((_ns8__eSpellRequestMS*)this)->term = NULL;
	((_ns8__eSpellRequestMS*)this)->tool = NULL;
	((_ns8__eSpellRequestMS*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns8__eSpellRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__eSpellRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns8__eSpellRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__eSpellRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__eSpellRequestMS(struct soap *soap, const char *tag, int id, const _ns8__eSpellRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__eSpellRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns8:db", -1, &(((_ns8__eSpellRequestMS*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns8:term", -1, &(((_ns8__eSpellRequestMS*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns8:tool", -1, &(((_ns8__eSpellRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns8:email", -1, &(((_ns8__eSpellRequestMS*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns8__eSpellRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__eSpellRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__eSpellRequestMS * SOAP_FMAC4 soap_get__ns8__eSpellRequestMS(struct soap *soap, _ns8__eSpellRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__eSpellRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns8__eSpellRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns8__eSpellRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__eSpellRequestMS * SOAP_FMAC4 soap_in__ns8__eSpellRequestMS(struct soap *soap, const char *tag, _ns8__eSpellRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__eSpellRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__eSpellRequestMS, sizeof(_ns8__eSpellRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns8__eSpellRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__eSpellRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_term1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:db", &(((_ns8__eSpellRequestMS*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:term", &(((_ns8__eSpellRequestMS*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:tool", &(((_ns8__eSpellRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:email", &(((_ns8__eSpellRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__eSpellRequestMS, 0, sizeof(_ns8__eSpellRequestMS), 0, soap_copy__ns8__eSpellRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns8__eSpellRequestMS * SOAP_FMAC6 soap_new__ns8__eSpellRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns8__eSpellRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns8__eSpellRequestMS(struct soap *soap, _ns8__eSpellRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns8__eSpellRequestMS * SOAP_FMAC4 soap_instantiate__ns8__eSpellRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__eSpellRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__eSpellRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns8__eSpellRequestMS;
		if (size)
			*size = sizeof(_ns8__eSpellRequestMS);
		((_ns8__eSpellRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns8__eSpellRequestMS[n];
		if (size)
			*size = n * sizeof(_ns8__eSpellRequestMS);
		for (int i = 0; i < n; i++)
			((_ns8__eSpellRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__eSpellRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__eSpellRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__eSpellRequestMS %p -> %p\n", q, p));
	*(_ns8__eSpellRequestMS*)p = *(_ns8__eSpellRequestMS*)q;
}

void _ns8__eSpellResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons8__eSpellResultType(soap, &((_ns8__eSpellResultMS*)this)->eSpellResult);
	/* transient soap skipped */
}

void _ns8__eSpellResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns8__eSpellResultMS*)this)->eSpellResult = NULL;
	/* transient soap skipped */
}

int _ns8__eSpellResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__eSpellResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns8__eSpellResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__eSpellResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__eSpellResultMS(struct soap *soap, const char *tag, int id, const _ns8__eSpellResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__eSpellResultMS), type);
	if (a->eSpellResult)
		soap_element_result(soap, "ns8:eSpellResult");
	soap_out_PointerTons8__eSpellResultType(soap, "ns8:eSpellResult", -1, &(((_ns8__eSpellResultMS*)a)->eSpellResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns8__eSpellResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__eSpellResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__eSpellResultMS * SOAP_FMAC4 soap_get__ns8__eSpellResultMS(struct soap *soap, _ns8__eSpellResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__eSpellResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns8__eSpellResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns8__eSpellResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__eSpellResultMS * SOAP_FMAC4 soap_in__ns8__eSpellResultMS(struct soap *soap, const char *tag, _ns8__eSpellResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__eSpellResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__eSpellResultMS, sizeof(_ns8__eSpellResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns8__eSpellResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__eSpellResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eSpellResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eSpellResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__eSpellResultType(soap, "ns8:eSpellResult", &(((_ns8__eSpellResultMS*)a)->eSpellResult), "ns8:eSpellResultType"))
				{	soap_flag_eSpellResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns8:eSpellResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__eSpellResultMS, 0, sizeof(_ns8__eSpellResultMS), 0, soap_copy__ns8__eSpellResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns8__eSpellResultMS * SOAP_FMAC6 soap_new__ns8__eSpellResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns8__eSpellResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns8__eSpellResultMS(struct soap *soap, _ns8__eSpellResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns8__eSpellResultMS * SOAP_FMAC4 soap_instantiate__ns8__eSpellResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__eSpellResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__eSpellResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns8__eSpellResultMS;
		if (size)
			*size = sizeof(_ns8__eSpellResultMS);
		((_ns8__eSpellResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns8__eSpellResultMS[n];
		if (size)
			*size = n * sizeof(_ns8__eSpellResultMS);
		for (int i = 0; i < n; i++)
			((_ns8__eSpellResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__eSpellResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__eSpellResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__eSpellResultMS %p -> %p\n", q, p));
	*(_ns8__eSpellResultMS*)p = *(_ns8__eSpellResultMS*)q;
}

void _ns8__eSpellRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequest*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequest*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns8__eSpellRequest*)this)->email);
	/* transient soap skipped */
}

void _ns8__eSpellRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns8__eSpellRequest*)this)->db = NULL;
	((_ns8__eSpellRequest*)this)->term = NULL;
	((_ns8__eSpellRequest*)this)->tool = NULL;
	((_ns8__eSpellRequest*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns8__eSpellRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__eSpellRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns8__eSpellRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__eSpellRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__eSpellRequest(struct soap *soap, const char *tag, int id, const _ns8__eSpellRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__eSpellRequest), type);
	soap_out_PointerTostd__string(soap, "ns8:db", -1, &(((_ns8__eSpellRequest*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns8:term", -1, &(((_ns8__eSpellRequest*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns8:tool", -1, &(((_ns8__eSpellRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns8:email", -1, &(((_ns8__eSpellRequest*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns8__eSpellRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__eSpellRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__eSpellRequest * SOAP_FMAC4 soap_get__ns8__eSpellRequest(struct soap *soap, _ns8__eSpellRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__eSpellRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns8__eSpellRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns8__eSpellRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__eSpellRequest * SOAP_FMAC4 soap_in__ns8__eSpellRequest(struct soap *soap, const char *tag, _ns8__eSpellRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__eSpellRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__eSpellRequest, sizeof(_ns8__eSpellRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns8__eSpellRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__eSpellRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_term1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:db", &(((_ns8__eSpellRequest*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:term", &(((_ns8__eSpellRequest*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:tool", &(((_ns8__eSpellRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns8:email", &(((_ns8__eSpellRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__eSpellRequest, 0, sizeof(_ns8__eSpellRequest), 0, soap_copy__ns8__eSpellRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns8__eSpellRequest * SOAP_FMAC6 soap_new__ns8__eSpellRequest(struct soap *soap, int n)
{	return soap_instantiate__ns8__eSpellRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns8__eSpellRequest(struct soap *soap, _ns8__eSpellRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns8__eSpellRequest * SOAP_FMAC4 soap_instantiate__ns8__eSpellRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__eSpellRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__eSpellRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns8__eSpellRequest;
		if (size)
			*size = sizeof(_ns8__eSpellRequest);
		((_ns8__eSpellRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns8__eSpellRequest[n];
		if (size)
			*size = n * sizeof(_ns8__eSpellRequest);
		for (int i = 0; i < n; i++)
			((_ns8__eSpellRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__eSpellRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__eSpellRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__eSpellRequest %p -> %p\n", q, p));
	*(_ns8__eSpellRequest*)p = *(_ns8__eSpellRequest*)q;
}

void _ns8__eSpellResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ns8__eSpellResult*)this)->ERROR_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ns8__eSpellResult*)this)->ERROR_);
	soap_embedded(soap, &((_ns8__eSpellResult*)this)->Database, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ns8__eSpellResult*)this)->Database);
	soap_embedded(soap, &((_ns8__eSpellResult*)this)->Query, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ns8__eSpellResult*)this)->Query);
	soap_embedded(soap, &((_ns8__eSpellResult*)this)->CorrectedQuery, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ns8__eSpellResult*)this)->CorrectedQuery);
	soap_serialize_PointerTons8__SpelledQueryType(soap, &((_ns8__eSpellResult*)this)->SpelledQuery);
	/* transient soap skipped */
}

void _ns8__eSpellResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ns8__eSpellResult*)this)->ERROR_);
	soap_default_std__string(soap, &((_ns8__eSpellResult*)this)->Database);
	soap_default_std__string(soap, &((_ns8__eSpellResult*)this)->Query);
	soap_default_std__string(soap, &((_ns8__eSpellResult*)this)->CorrectedQuery);
	((_ns8__eSpellResult*)this)->SpelledQuery = NULL;
	/* transient soap skipped */
}

int _ns8__eSpellResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__eSpellResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns8__eSpellResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__eSpellResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__eSpellResult(struct soap *soap, const char *tag, int id, const _ns8__eSpellResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__eSpellResult), type);
	soap_element_result(soap, "ns8:ERROR_");
	soap_out_std__string(soap, "ns8:ERROR_", -1, &(((_ns8__eSpellResult*)a)->ERROR_), "");
	soap_out_std__string(soap, "ns8:Database", -1, &(((_ns8__eSpellResult*)a)->Database), "");
	soap_out_std__string(soap, "ns8:Query", -1, &(((_ns8__eSpellResult*)a)->Query), "");
	soap_out_std__string(soap, "ns8:CorrectedQuery", -1, &(((_ns8__eSpellResult*)a)->CorrectedQuery), "");
	soap_out_PointerTons8__SpelledQueryType(soap, "ns8:SpelledQuery", -1, &(((_ns8__eSpellResult*)a)->SpelledQuery), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns8__eSpellResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__eSpellResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__eSpellResult * SOAP_FMAC4 soap_get__ns8__eSpellResult(struct soap *soap, _ns8__eSpellResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__eSpellResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns8__eSpellResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns8__eSpellResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__eSpellResult * SOAP_FMAC4 soap_in__ns8__eSpellResult(struct soap *soap, const char *tag, _ns8__eSpellResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__eSpellResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__eSpellResult, sizeof(_ns8__eSpellResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns8__eSpellResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__eSpellResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1, soap_flag_Database1 = 1, soap_flag_Query1 = 1, soap_flag_CorrectedQuery1 = 1, soap_flag_SpelledQuery1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:ERROR_", &(((_ns8__eSpellResult*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_Database1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:Database", &(((_ns8__eSpellResult*)a)->Database), "xsd:string"))
				{	soap_flag_Database1--;
					continue;
				}
			if (soap_flag_Query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:Query", &(((_ns8__eSpellResult*)a)->Query), "xsd:string"))
				{	soap_flag_Query1--;
					continue;
				}
			if (soap_flag_CorrectedQuery1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:CorrectedQuery", &(((_ns8__eSpellResult*)a)->CorrectedQuery), "xsd:string"))
				{	soap_flag_CorrectedQuery1--;
					continue;
				}
			if (soap_flag_SpelledQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__SpelledQueryType(soap, "ns8:SpelledQuery", &(((_ns8__eSpellResult*)a)->SpelledQuery), "ns8:SpelledQueryType"))
				{	soap_flag_SpelledQuery1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns8:ERROR_");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ERROR_1 > 0 || soap_flag_Database1 > 0 || soap_flag_Query1 > 0 || soap_flag_CorrectedQuery1 > 0 || soap_flag_SpelledQuery1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__eSpellResult, 0, sizeof(_ns8__eSpellResult), 0, soap_copy__ns8__eSpellResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns8__eSpellResult * SOAP_FMAC6 soap_new__ns8__eSpellResult(struct soap *soap, int n)
{	return soap_instantiate__ns8__eSpellResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns8__eSpellResult(struct soap *soap, _ns8__eSpellResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns8__eSpellResult * SOAP_FMAC4 soap_instantiate__ns8__eSpellResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__eSpellResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__eSpellResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns8__eSpellResult;
		if (size)
			*size = sizeof(_ns8__eSpellResult);
		((_ns8__eSpellResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns8__eSpellResult[n];
		if (size)
			*size = n * sizeof(_ns8__eSpellResult);
		for (int i = 0; i < n; i++)
			((_ns8__eSpellResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__eSpellResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__eSpellResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__eSpellResult %p -> %p\n", q, p));
	*(_ns8__eSpellResult*)p = *(_ns8__eSpellResult*)q;
}

void ns8__eSpellResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns8__eSpellResultType*)this)->ERROR_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns8__eSpellResultType*)this)->ERROR_);
	soap_embedded(soap, &((ns8__eSpellResultType*)this)->Database, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns8__eSpellResultType*)this)->Database);
	soap_embedded(soap, &((ns8__eSpellResultType*)this)->Query, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns8__eSpellResultType*)this)->Query);
	soap_embedded(soap, &((ns8__eSpellResultType*)this)->CorrectedQuery, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns8__eSpellResultType*)this)->CorrectedQuery);
	soap_serialize_PointerTons8__SpelledQueryType(soap, &((ns8__eSpellResultType*)this)->SpelledQuery);
	/* transient soap skipped */
}

void ns8__eSpellResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns8__eSpellResultType*)this)->ERROR_);
	soap_default_std__string(soap, &((ns8__eSpellResultType*)this)->Database);
	soap_default_std__string(soap, &((ns8__eSpellResultType*)this)->Query);
	soap_default_std__string(soap, &((ns8__eSpellResultType*)this)->CorrectedQuery);
	((ns8__eSpellResultType*)this)->SpelledQuery = NULL;
	/* transient soap skipped */
}

int ns8__eSpellResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns8__eSpellResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns8__eSpellResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns8__eSpellResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__eSpellResultType(struct soap *soap, const char *tag, int id, const ns8__eSpellResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__eSpellResultType), type);
	soap_out_std__string(soap, "ns8:ERROR_", -1, &(((ns8__eSpellResultType*)a)->ERROR_), "");
	soap_out_std__string(soap, "ns8:Database", -1, &(((ns8__eSpellResultType*)a)->Database), "");
	soap_out_std__string(soap, "ns8:Query", -1, &(((ns8__eSpellResultType*)a)->Query), "");
	soap_out_std__string(soap, "ns8:CorrectedQuery", -1, &(((ns8__eSpellResultType*)a)->CorrectedQuery), "");
	soap_out_PointerTons8__SpelledQueryType(soap, "ns8:SpelledQuery", -1, &(((ns8__eSpellResultType*)a)->SpelledQuery), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns8__eSpellResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns8__eSpellResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns8__eSpellResultType * SOAP_FMAC4 soap_get_ns8__eSpellResultType(struct soap *soap, ns8__eSpellResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__eSpellResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns8__eSpellResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns8__eSpellResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns8__eSpellResultType * SOAP_FMAC4 soap_in_ns8__eSpellResultType(struct soap *soap, const char *tag, ns8__eSpellResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns8__eSpellResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__eSpellResultType, sizeof(ns8__eSpellResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns8__eSpellResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns8__eSpellResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1, soap_flag_Database1 = 1, soap_flag_Query1 = 1, soap_flag_CorrectedQuery1 = 1, soap_flag_SpelledQuery1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:ERROR_", &(((ns8__eSpellResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_Database1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:Database", &(((ns8__eSpellResultType*)a)->Database), "xsd:string"))
				{	soap_flag_Database1--;
					continue;
				}
			if (soap_flag_Query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:Query", &(((ns8__eSpellResultType*)a)->Query), "xsd:string"))
				{	soap_flag_Query1--;
					continue;
				}
			if (soap_flag_CorrectedQuery1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns8:CorrectedQuery", &(((ns8__eSpellResultType*)a)->CorrectedQuery), "xsd:string"))
				{	soap_flag_CorrectedQuery1--;
					continue;
				}
			if (soap_flag_SpelledQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__SpelledQueryType(soap, "ns8:SpelledQuery", &(((ns8__eSpellResultType*)a)->SpelledQuery), "ns8:SpelledQueryType"))
				{	soap_flag_SpelledQuery1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ERROR_1 > 0 || soap_flag_Database1 > 0 || soap_flag_Query1 > 0 || soap_flag_CorrectedQuery1 > 0 || soap_flag_SpelledQuery1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns8__eSpellResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__eSpellResultType, 0, sizeof(ns8__eSpellResultType), 0, soap_copy_ns8__eSpellResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns8__eSpellResultType * SOAP_FMAC6 soap_new_ns8__eSpellResultType(struct soap *soap, int n)
{	return soap_instantiate_ns8__eSpellResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns8__eSpellResultType(struct soap *soap, ns8__eSpellResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns8__eSpellResultType * SOAP_FMAC4 soap_instantiate_ns8__eSpellResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns8__eSpellResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns8__eSpellResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns8__eSpellResultType;
		if (size)
			*size = sizeof(ns8__eSpellResultType);
		((ns8__eSpellResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns8__eSpellResultType[n];
		if (size)
			*size = n * sizeof(ns8__eSpellResultType);
		for (int i = 0; i < n; i++)
			((ns8__eSpellResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns8__eSpellResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns8__eSpellResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns8__eSpellResultType %p -> %p\n", q, p));
	*(ns8__eSpellResultType*)p = *(ns8__eSpellResultType*)q;
}

void ns8__SpelledQueryType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (((ns8__SpelledQueryType*)this)->__union_SpelledQueryType)
	{	int i;
		for (i = 0; i < ((ns8__SpelledQueryType*)this)->__size_SpelledQueryType; i++)
		{
			soap_serialize___ns8__union_SpelledQueryType(soap, ((ns8__SpelledQueryType*)this)->__union_SpelledQueryType + i);
		}
	}
	/* transient soap skipped */
}

void ns8__SpelledQueryType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns8__SpelledQueryType*)this)->__size_SpelledQueryType = 0;
	((ns8__SpelledQueryType*)this)->__union_SpelledQueryType = NULL;
	/* transient soap skipped */
}

int ns8__SpelledQueryType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns8__SpelledQueryType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns8__SpelledQueryType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns8__SpelledQueryType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__SpelledQueryType(struct soap *soap, const char *tag, int id, const ns8__SpelledQueryType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__SpelledQueryType), type);
	if (((ns8__SpelledQueryType*)a)->__union_SpelledQueryType)
	{	int i;
		for (i = 0; i < ((ns8__SpelledQueryType*)a)->__size_SpelledQueryType; i++)
			soap_out___ns8__union_SpelledQueryType(soap, "-union-SpelledQueryType", -1, ((ns8__SpelledQueryType*)a)->__union_SpelledQueryType + i, "");
	}
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns8__SpelledQueryType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns8__SpelledQueryType(soap, this, tag, type);
}

SOAP_FMAC3 ns8__SpelledQueryType * SOAP_FMAC4 soap_get_ns8__SpelledQueryType(struct soap *soap, ns8__SpelledQueryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__SpelledQueryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns8__SpelledQueryType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns8__SpelledQueryType(soap, tag, this, type);
}

SOAP_FMAC3 ns8__SpelledQueryType * SOAP_FMAC4 soap_in_ns8__SpelledQueryType(struct soap *soap, const char *tag, ns8__SpelledQueryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns8__SpelledQueryType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__SpelledQueryType, sizeof(ns8__SpelledQueryType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns8__SpelledQueryType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns8__SpelledQueryType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___union_SpelledQueryType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___union_SpelledQueryType1 && soap->error == SOAP_TAG_MISMATCH)
			{	struct __ns8__union_SpelledQueryType *p;
				soap_new_block(soap);
				for (((ns8__SpelledQueryType*)a)->__size_SpelledQueryType = 0; !soap_element_begin_in(soap, "-union-SpelledQueryType", 1, NULL); ((ns8__SpelledQueryType*)a)->__size_SpelledQueryType++)
				{	p = (struct __ns8__union_SpelledQueryType *)soap_push_block(soap, sizeof(struct __ns8__union_SpelledQueryType));
					if (!p)
						return NULL;
					soap_default___ns8__union_SpelledQueryType(soap, p);
					if (!soap_in___ns8__union_SpelledQueryType(soap, "-union-SpelledQueryType", p, "-ns8:union-SpelledQueryType"))
						break;
					soap_flag___union_SpelledQueryType1 = 0;
				}
				((ns8__SpelledQueryType*)a)->__union_SpelledQueryType = (struct __ns8__union_SpelledQueryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___union_SpelledQueryType1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns8__SpelledQueryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__SpelledQueryType, 0, sizeof(ns8__SpelledQueryType), 0, soap_copy_ns8__SpelledQueryType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns8__SpelledQueryType * SOAP_FMAC6 soap_new_ns8__SpelledQueryType(struct soap *soap, int n)
{	return soap_instantiate_ns8__SpelledQueryType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns8__SpelledQueryType(struct soap *soap, ns8__SpelledQueryType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns8__SpelledQueryType * SOAP_FMAC4 soap_instantiate_ns8__SpelledQueryType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns8__SpelledQueryType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns8__SpelledQueryType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns8__SpelledQueryType;
		if (size)
			*size = sizeof(ns8__SpelledQueryType);
		((ns8__SpelledQueryType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns8__SpelledQueryType[n];
		if (size)
			*size = n * sizeof(ns8__SpelledQueryType);
		for (int i = 0; i < n; i++)
			((ns8__SpelledQueryType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns8__SpelledQueryType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns8__SpelledQueryType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns8__SpelledQueryType %p -> %p\n", q, p));
	*(ns8__SpelledQueryType*)p = *(ns8__SpelledQueryType*)q;
}

void _ns7__eLinkRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->db);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_ns7__eLinkRequestMS*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->reldate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->mindate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->maxdate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->datetype);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->dbfrom);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->query_USCOREkey);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->cmd);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequestMS*)this)->email);
	/* transient soap skipped */
}

void _ns7__eLinkRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns7__eLinkRequestMS*)this)->db = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_ns7__eLinkRequestMS*)this)->id);
	((_ns7__eLinkRequestMS*)this)->reldate = NULL;
	((_ns7__eLinkRequestMS*)this)->mindate = NULL;
	((_ns7__eLinkRequestMS*)this)->maxdate = NULL;
	((_ns7__eLinkRequestMS*)this)->datetype = NULL;
	((_ns7__eLinkRequestMS*)this)->term = NULL;
	((_ns7__eLinkRequestMS*)this)->dbfrom = NULL;
	((_ns7__eLinkRequestMS*)this)->WebEnv = NULL;
	((_ns7__eLinkRequestMS*)this)->query_USCOREkey = NULL;
	((_ns7__eLinkRequestMS*)this)->cmd = NULL;
	((_ns7__eLinkRequestMS*)this)->tool = NULL;
	((_ns7__eLinkRequestMS*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns7__eLinkRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__eLinkRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__eLinkRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__eLinkRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__eLinkRequestMS(struct soap *soap, const char *tag, int id, const _ns7__eLinkRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__eLinkRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns7:db", -1, &(((_ns7__eLinkRequestMS*)a)->db), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns7:id", -1, &(((_ns7__eLinkRequestMS*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns7:reldate", -1, &(((_ns7__eLinkRequestMS*)a)->reldate), "");
	soap_out_PointerTostd__string(soap, "ns7:mindate", -1, &(((_ns7__eLinkRequestMS*)a)->mindate), "");
	soap_out_PointerTostd__string(soap, "ns7:maxdate", -1, &(((_ns7__eLinkRequestMS*)a)->maxdate), "");
	soap_out_PointerTostd__string(soap, "ns7:datetype", -1, &(((_ns7__eLinkRequestMS*)a)->datetype), "");
	soap_out_PointerTostd__string(soap, "ns7:term", -1, &(((_ns7__eLinkRequestMS*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns7:dbfrom", -1, &(((_ns7__eLinkRequestMS*)a)->dbfrom), "");
	soap_out_PointerTostd__string(soap, "ns7:WebEnv", -1, &(((_ns7__eLinkRequestMS*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns7:query_key", -1, &(((_ns7__eLinkRequestMS*)a)->query_USCOREkey), "");
	soap_out_PointerTostd__string(soap, "ns7:cmd", -1, &(((_ns7__eLinkRequestMS*)a)->cmd), "");
	soap_out_PointerTostd__string(soap, "ns7:tool", -1, &(((_ns7__eLinkRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns7:email", -1, &(((_ns7__eLinkRequestMS*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns7__eLinkRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__eLinkRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__eLinkRequestMS * SOAP_FMAC4 soap_get__ns7__eLinkRequestMS(struct soap *soap, _ns7__eLinkRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__eLinkRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns7__eLinkRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__eLinkRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__eLinkRequestMS * SOAP_FMAC4 soap_in__ns7__eLinkRequestMS(struct soap *soap, const char *tag, _ns7__eLinkRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__eLinkRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__eLinkRequestMS, sizeof(_ns7__eLinkRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__eLinkRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__eLinkRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_reldate1 = 1, soap_flag_mindate1 = 1, soap_flag_maxdate1 = 1, soap_flag_datetype1 = 1, soap_flag_term1 = 1, soap_flag_dbfrom1 = 1, soap_flag_WebEnv1 = 1, soap_flag_query_USCOREkey1 = 1, soap_flag_cmd1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:db", &(((_ns7__eLinkRequestMS*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns7:id", &(((_ns7__eLinkRequestMS*)a)->id), "xsd:string"))
					continue;
			if (soap_flag_reldate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:reldate", &(((_ns7__eLinkRequestMS*)a)->reldate), "xsd:string"))
				{	soap_flag_reldate1--;
					continue;
				}
			if (soap_flag_mindate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:mindate", &(((_ns7__eLinkRequestMS*)a)->mindate), "xsd:string"))
				{	soap_flag_mindate1--;
					continue;
				}
			if (soap_flag_maxdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:maxdate", &(((_ns7__eLinkRequestMS*)a)->maxdate), "xsd:string"))
				{	soap_flag_maxdate1--;
					continue;
				}
			if (soap_flag_datetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:datetype", &(((_ns7__eLinkRequestMS*)a)->datetype), "xsd:string"))
				{	soap_flag_datetype1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:term", &(((_ns7__eLinkRequestMS*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_dbfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:dbfrom", &(((_ns7__eLinkRequestMS*)a)->dbfrom), "xsd:string"))
				{	soap_flag_dbfrom1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:WebEnv", &(((_ns7__eLinkRequestMS*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_query_USCOREkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:query_key", &(((_ns7__eLinkRequestMS*)a)->query_USCOREkey), "xsd:string"))
				{	soap_flag_query_USCOREkey1--;
					continue;
				}
			if (soap_flag_cmd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:cmd", &(((_ns7__eLinkRequestMS*)a)->cmd), "xsd:string"))
				{	soap_flag_cmd1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:tool", &(((_ns7__eLinkRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:email", &(((_ns7__eLinkRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__eLinkRequestMS, 0, sizeof(_ns7__eLinkRequestMS), 0, soap_copy__ns7__eLinkRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns7__eLinkRequestMS * SOAP_FMAC6 soap_new__ns7__eLinkRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns7__eLinkRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns7__eLinkRequestMS(struct soap *soap, _ns7__eLinkRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns7__eLinkRequestMS * SOAP_FMAC4 soap_instantiate__ns7__eLinkRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__eLinkRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__eLinkRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__eLinkRequestMS;
		if (size)
			*size = sizeof(_ns7__eLinkRequestMS);
		((_ns7__eLinkRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns7__eLinkRequestMS[n];
		if (size)
			*size = n * sizeof(_ns7__eLinkRequestMS);
		for (int i = 0; i < n; i++)
			((_ns7__eLinkRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__eLinkRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__eLinkRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__eLinkRequestMS %p -> %p\n", q, p));
	*(_ns7__eLinkRequestMS*)p = *(_ns7__eLinkRequestMS*)q;
}

void _ns7__eLinkRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->db);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_ns7__eLinkRequest*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->reldate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->mindate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->maxdate);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->datetype);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->dbfrom);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->query_USCOREkey);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->cmd);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkRequest*)this)->email);
	/* transient soap skipped */
}

void _ns7__eLinkRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns7__eLinkRequest*)this)->db = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_ns7__eLinkRequest*)this)->id);
	((_ns7__eLinkRequest*)this)->reldate = NULL;
	((_ns7__eLinkRequest*)this)->mindate = NULL;
	((_ns7__eLinkRequest*)this)->maxdate = NULL;
	((_ns7__eLinkRequest*)this)->datetype = NULL;
	((_ns7__eLinkRequest*)this)->term = NULL;
	((_ns7__eLinkRequest*)this)->dbfrom = NULL;
	((_ns7__eLinkRequest*)this)->WebEnv = NULL;
	((_ns7__eLinkRequest*)this)->query_USCOREkey = NULL;
	((_ns7__eLinkRequest*)this)->cmd = NULL;
	((_ns7__eLinkRequest*)this)->tool = NULL;
	((_ns7__eLinkRequest*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns7__eLinkRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__eLinkRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__eLinkRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__eLinkRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__eLinkRequest(struct soap *soap, const char *tag, int id, const _ns7__eLinkRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__eLinkRequest), type);
	soap_out_PointerTostd__string(soap, "ns7:db", -1, &(((_ns7__eLinkRequest*)a)->db), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns7:id", -1, &(((_ns7__eLinkRequest*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns7:reldate", -1, &(((_ns7__eLinkRequest*)a)->reldate), "");
	soap_out_PointerTostd__string(soap, "ns7:mindate", -1, &(((_ns7__eLinkRequest*)a)->mindate), "");
	soap_out_PointerTostd__string(soap, "ns7:maxdate", -1, &(((_ns7__eLinkRequest*)a)->maxdate), "");
	soap_out_PointerTostd__string(soap, "ns7:datetype", -1, &(((_ns7__eLinkRequest*)a)->datetype), "");
	soap_out_PointerTostd__string(soap, "ns7:term", -1, &(((_ns7__eLinkRequest*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns7:dbfrom", -1, &(((_ns7__eLinkRequest*)a)->dbfrom), "");
	soap_out_PointerTostd__string(soap, "ns7:WebEnv", -1, &(((_ns7__eLinkRequest*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns7:query_key", -1, &(((_ns7__eLinkRequest*)a)->query_USCOREkey), "");
	soap_out_PointerTostd__string(soap, "ns7:cmd", -1, &(((_ns7__eLinkRequest*)a)->cmd), "");
	soap_out_PointerTostd__string(soap, "ns7:tool", -1, &(((_ns7__eLinkRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns7:email", -1, &(((_ns7__eLinkRequest*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns7__eLinkRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__eLinkRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__eLinkRequest * SOAP_FMAC4 soap_get__ns7__eLinkRequest(struct soap *soap, _ns7__eLinkRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__eLinkRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns7__eLinkRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__eLinkRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__eLinkRequest * SOAP_FMAC4 soap_in__ns7__eLinkRequest(struct soap *soap, const char *tag, _ns7__eLinkRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__eLinkRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__eLinkRequest, sizeof(_ns7__eLinkRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__eLinkRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__eLinkRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_reldate1 = 1, soap_flag_mindate1 = 1, soap_flag_maxdate1 = 1, soap_flag_datetype1 = 1, soap_flag_term1 = 1, soap_flag_dbfrom1 = 1, soap_flag_WebEnv1 = 1, soap_flag_query_USCOREkey1 = 1, soap_flag_cmd1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:db", &(((_ns7__eLinkRequest*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns7:id", &(((_ns7__eLinkRequest*)a)->id), "xsd:string"))
					continue;
			if (soap_flag_reldate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:reldate", &(((_ns7__eLinkRequest*)a)->reldate), "xsd:string"))
				{	soap_flag_reldate1--;
					continue;
				}
			if (soap_flag_mindate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:mindate", &(((_ns7__eLinkRequest*)a)->mindate), "xsd:string"))
				{	soap_flag_mindate1--;
					continue;
				}
			if (soap_flag_maxdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:maxdate", &(((_ns7__eLinkRequest*)a)->maxdate), "xsd:string"))
				{	soap_flag_maxdate1--;
					continue;
				}
			if (soap_flag_datetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:datetype", &(((_ns7__eLinkRequest*)a)->datetype), "xsd:string"))
				{	soap_flag_datetype1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:term", &(((_ns7__eLinkRequest*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_dbfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:dbfrom", &(((_ns7__eLinkRequest*)a)->dbfrom), "xsd:string"))
				{	soap_flag_dbfrom1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:WebEnv", &(((_ns7__eLinkRequest*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_query_USCOREkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:query_key", &(((_ns7__eLinkRequest*)a)->query_USCOREkey), "xsd:string"))
				{	soap_flag_query_USCOREkey1--;
					continue;
				}
			if (soap_flag_cmd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:cmd", &(((_ns7__eLinkRequest*)a)->cmd), "xsd:string"))
				{	soap_flag_cmd1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:tool", &(((_ns7__eLinkRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:email", &(((_ns7__eLinkRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__eLinkRequest, 0, sizeof(_ns7__eLinkRequest), 0, soap_copy__ns7__eLinkRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns7__eLinkRequest * SOAP_FMAC6 soap_new__ns7__eLinkRequest(struct soap *soap, int n)
{	return soap_instantiate__ns7__eLinkRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns7__eLinkRequest(struct soap *soap, _ns7__eLinkRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns7__eLinkRequest * SOAP_FMAC4 soap_instantiate__ns7__eLinkRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__eLinkRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__eLinkRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__eLinkRequest;
		if (size)
			*size = sizeof(_ns7__eLinkRequest);
		((_ns7__eLinkRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns7__eLinkRequest[n];
		if (size)
			*size = n * sizeof(_ns7__eLinkRequest);
		for (int i = 0; i < n; i++)
			((_ns7__eLinkRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__eLinkRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__eLinkRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__eLinkRequest %p -> %p\n", q, p));
	*(_ns7__eLinkRequest*)p = *(_ns7__eLinkRequest*)q;
}

void _ns7__eLinkResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__eLinkResultType(soap, &((_ns7__eLinkResultMS*)this)->eLinkResult);
	/* transient soap skipped */
}

void _ns7__eLinkResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns7__eLinkResultMS*)this)->eLinkResult = NULL;
	/* transient soap skipped */
}

int _ns7__eLinkResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__eLinkResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__eLinkResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__eLinkResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__eLinkResultMS(struct soap *soap, const char *tag, int id, const _ns7__eLinkResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__eLinkResultMS), type);
	if (a->eLinkResult)
		soap_element_result(soap, "ns7:eLinkResult");
	soap_out_PointerTons7__eLinkResultType(soap, "ns7:eLinkResult", -1, &(((_ns7__eLinkResultMS*)a)->eLinkResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns7__eLinkResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__eLinkResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__eLinkResultMS * SOAP_FMAC4 soap_get__ns7__eLinkResultMS(struct soap *soap, _ns7__eLinkResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__eLinkResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns7__eLinkResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__eLinkResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__eLinkResultMS * SOAP_FMAC4 soap_in__ns7__eLinkResultMS(struct soap *soap, const char *tag, _ns7__eLinkResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__eLinkResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__eLinkResultMS, sizeof(_ns7__eLinkResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__eLinkResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__eLinkResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eLinkResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eLinkResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__eLinkResultType(soap, "ns7:eLinkResult", &(((_ns7__eLinkResultMS*)a)->eLinkResult), "ns7:eLinkResultType"))
				{	soap_flag_eLinkResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns7:eLinkResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__eLinkResultMS, 0, sizeof(_ns7__eLinkResultMS), 0, soap_copy__ns7__eLinkResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns7__eLinkResultMS * SOAP_FMAC6 soap_new__ns7__eLinkResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns7__eLinkResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns7__eLinkResultMS(struct soap *soap, _ns7__eLinkResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns7__eLinkResultMS * SOAP_FMAC4 soap_instantiate__ns7__eLinkResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__eLinkResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__eLinkResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__eLinkResultMS;
		if (size)
			*size = sizeof(_ns7__eLinkResultMS);
		((_ns7__eLinkResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns7__eLinkResultMS[n];
		if (size)
			*size = n * sizeof(_ns7__eLinkResultMS);
		for (int i = 0; i < n; i++)
			((_ns7__eLinkResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__eLinkResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__eLinkResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__eLinkResultMS %p -> %p\n", q, p));
	*(_ns7__eLinkResultMS*)p = *(_ns7__eLinkResultMS*)q;
}

void _ns7__eLinkResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns7__eLinkResult*)this)->ERROR_);
	soap_serialize_std__vectorTemplateOfPointerTons7__LinkSetType(soap, &((_ns7__eLinkResult*)this)->LinkSet);
	/* transient soap skipped */
}

void _ns7__eLinkResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns7__eLinkResult*)this)->ERROR_ = NULL;
	soap_default_std__vectorTemplateOfPointerTons7__LinkSetType(soap, &((_ns7__eLinkResult*)this)->LinkSet);
	/* transient soap skipped */
}

int _ns7__eLinkResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__eLinkResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns7__eLinkResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__eLinkResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__eLinkResult(struct soap *soap, const char *tag, int id, const _ns7__eLinkResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__eLinkResult), type);
	if (a->ERROR_)
		soap_element_result(soap, "ns7:ERROR_");
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((_ns7__eLinkResult*)a)->ERROR_), "");
	soap_out_std__vectorTemplateOfPointerTons7__LinkSetType(soap, "ns7:LinkSet", -1, &(((_ns7__eLinkResult*)a)->LinkSet), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns7__eLinkResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__eLinkResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__eLinkResult * SOAP_FMAC4 soap_get__ns7__eLinkResult(struct soap *soap, _ns7__eLinkResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__eLinkResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns7__eLinkResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__eLinkResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__eLinkResult * SOAP_FMAC4 soap_in__ns7__eLinkResult(struct soap *soap, const char *tag, _ns7__eLinkResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__eLinkResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__eLinkResult, sizeof(_ns7__eLinkResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__eLinkResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__eLinkResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((_ns7__eLinkResult*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__LinkSetType(soap, "ns7:LinkSet", &(((_ns7__eLinkResult*)a)->LinkSet), "ns7:LinkSetType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns7:ERROR_");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__eLinkResult, 0, sizeof(_ns7__eLinkResult), 0, soap_copy__ns7__eLinkResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns7__eLinkResult * SOAP_FMAC6 soap_new__ns7__eLinkResult(struct soap *soap, int n)
{	return soap_instantiate__ns7__eLinkResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns7__eLinkResult(struct soap *soap, _ns7__eLinkResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns7__eLinkResult * SOAP_FMAC4 soap_instantiate__ns7__eLinkResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__eLinkResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__eLinkResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns7__eLinkResult;
		if (size)
			*size = sizeof(_ns7__eLinkResult);
		((_ns7__eLinkResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns7__eLinkResult[n];
		if (size)
			*size = n * sizeof(_ns7__eLinkResult);
		for (int i = 0; i < n; i++)
			((_ns7__eLinkResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__eLinkResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__eLinkResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__eLinkResult %p -> %p\n", q, p));
	*(_ns7__eLinkResult*)p = *(_ns7__eLinkResult*)q;
}

void ns7__eLinkResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns7__eLinkResultType*)this)->ERROR_);
	soap_serialize_std__vectorTemplateOfPointerTons7__LinkSetType(soap, &((ns7__eLinkResultType*)this)->LinkSet);
	/* transient soap skipped */
}

void ns7__eLinkResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns7__eLinkResultType*)this)->ERROR_ = NULL;
	soap_default_std__vectorTemplateOfPointerTons7__LinkSetType(soap, &((ns7__eLinkResultType*)this)->LinkSet);
	/* transient soap skipped */
}

int ns7__eLinkResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__eLinkResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__eLinkResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__eLinkResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__eLinkResultType(struct soap *soap, const char *tag, int id, const ns7__eLinkResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__eLinkResultType), type);
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((ns7__eLinkResultType*)a)->ERROR_), "");
	soap_out_std__vectorTemplateOfPointerTons7__LinkSetType(soap, "ns7:LinkSet", -1, &(((ns7__eLinkResultType*)a)->LinkSet), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__eLinkResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__eLinkResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__eLinkResultType * SOAP_FMAC4 soap_get_ns7__eLinkResultType(struct soap *soap, ns7__eLinkResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__eLinkResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__eLinkResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__eLinkResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__eLinkResultType * SOAP_FMAC4 soap_in_ns7__eLinkResultType(struct soap *soap, const char *tag, ns7__eLinkResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__eLinkResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__eLinkResultType, sizeof(ns7__eLinkResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__eLinkResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__eLinkResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((ns7__eLinkResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__LinkSetType(soap, "ns7:LinkSet", &(((ns7__eLinkResultType*)a)->LinkSet), "ns7:LinkSetType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__eLinkResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__eLinkResultType, 0, sizeof(ns7__eLinkResultType), 0, soap_copy_ns7__eLinkResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__eLinkResultType * SOAP_FMAC6 soap_new_ns7__eLinkResultType(struct soap *soap, int n)
{	return soap_instantiate_ns7__eLinkResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__eLinkResultType(struct soap *soap, ns7__eLinkResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__eLinkResultType * SOAP_FMAC4 soap_instantiate_ns7__eLinkResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__eLinkResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__eLinkResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__eLinkResultType;
		if (size)
			*size = sizeof(ns7__eLinkResultType);
		((ns7__eLinkResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__eLinkResultType[n];
		if (size)
			*size = n * sizeof(ns7__eLinkResultType);
		for (int i = 0; i < n; i++)
			((ns7__eLinkResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__eLinkResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__eLinkResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__eLinkResultType %p -> %p\n", q, p));
	*(ns7__eLinkResultType*)p = *(ns7__eLinkResultType*)q;
}

void ns7__ProviderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__ProviderType*)this)->Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__ProviderType*)this)->Name);
	soap_embedded(soap, &((ns7__ProviderType*)this)->NameAbbr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__ProviderType*)this)->NameAbbr);
	soap_serialize_PointerTons7__IdType(soap, &((ns7__ProviderType*)this)->Id);
	soap_embedded(soap, &((ns7__ProviderType*)this)->Url, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__ProviderType*)this)->Url);
	soap_serialize_PointerTostd__string(soap, &((ns7__ProviderType*)this)->IconUrl);
	/* transient soap skipped */
}

void ns7__ProviderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__ProviderType*)this)->Name);
	soap_default_std__string(soap, &((ns7__ProviderType*)this)->NameAbbr);
	((ns7__ProviderType*)this)->Id = NULL;
	soap_default_std__string(soap, &((ns7__ProviderType*)this)->Url);
	((ns7__ProviderType*)this)->IconUrl = NULL;
	/* transient soap skipped */
}

int ns7__ProviderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ProviderType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ProviderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ProviderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ProviderType(struct soap *soap, const char *tag, int id, const ns7__ProviderType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ProviderType), type);
	soap_out_std__string(soap, "ns7:Name", -1, &(((ns7__ProviderType*)a)->Name), "");
	soap_out_std__string(soap, "ns7:NameAbbr", -1, &(((ns7__ProviderType*)a)->NameAbbr), "");
	soap_out_PointerTons7__IdType(soap, "ns7:Id", -1, &(((ns7__ProviderType*)a)->Id), "");
	soap_out_std__string(soap, "ns7:Url", -1, &(((ns7__ProviderType*)a)->Url), "");
	soap_out_PointerTostd__string(soap, "ns7:IconUrl", -1, &(((ns7__ProviderType*)a)->IconUrl), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__ProviderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ProviderType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ProviderType * SOAP_FMAC4 soap_get_ns7__ProviderType(struct soap *soap, ns7__ProviderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ProviderType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__ProviderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ProviderType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ProviderType * SOAP_FMAC4 soap_in_ns7__ProviderType(struct soap *soap, const char *tag, ns7__ProviderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ProviderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ProviderType, sizeof(ns7__ProviderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ProviderType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ProviderType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Name1 = 1, soap_flag_NameAbbr1 = 1, soap_flag_Id1 = 1, soap_flag_Url1 = 1, soap_flag_IconUrl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:Name", &(((ns7__ProviderType*)a)->Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_NameAbbr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:NameAbbr", &(((ns7__ProviderType*)a)->NameAbbr), "xsd:string"))
				{	soap_flag_NameAbbr1--;
					continue;
				}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdType(soap, "ns7:Id", &(((ns7__ProviderType*)a)->Id), "ns7:IdType"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:Url", &(((ns7__ProviderType*)a)->Url), "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_IconUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:IconUrl", &(((ns7__ProviderType*)a)->IconUrl), "xsd:string"))
				{	soap_flag_IconUrl1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_NameAbbr1 > 0 || soap_flag_Id1 > 0 || soap_flag_Url1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ProviderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ProviderType, 0, sizeof(ns7__ProviderType), 0, soap_copy_ns7__ProviderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__ProviderType * SOAP_FMAC6 soap_new_ns7__ProviderType(struct soap *soap, int n)
{	return soap_instantiate_ns7__ProviderType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__ProviderType(struct soap *soap, ns7__ProviderType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__ProviderType * SOAP_FMAC4 soap_instantiate_ns7__ProviderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ProviderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ProviderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ProviderType;
		if (size)
			*size = sizeof(ns7__ProviderType);
		((ns7__ProviderType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ProviderType[n];
		if (size)
			*size = n * sizeof(ns7__ProviderType);
		for (int i = 0; i < n; i++)
			((ns7__ProviderType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ProviderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ProviderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ProviderType %p -> %p\n", q, p));
	*(ns7__ProviderType*)p = *(ns7__ProviderType*)q;
}

void ns7__ObjUrlType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__ObjUrlType*)this)->Url, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__ObjUrlType*)this)->Url);
	soap_serialize_PointerTostd__string(soap, &((ns7__ObjUrlType*)this)->IconUrl);
	soap_serialize_PointerTostd__string(soap, &((ns7__ObjUrlType*)this)->LinkName);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns7__ObjUrlType*)this)->SubjectType);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns7__ObjUrlType*)this)->Attribute);
	soap_serialize_PointerTons7__ProviderType(soap, &((ns7__ObjUrlType*)this)->Provider);
	/* transient soap skipped */
}

void ns7__ObjUrlType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__ObjUrlType*)this)->Url);
	((ns7__ObjUrlType*)this)->IconUrl = NULL;
	((ns7__ObjUrlType*)this)->LinkName = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns7__ObjUrlType*)this)->SubjectType);
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns7__ObjUrlType*)this)->Attribute);
	((ns7__ObjUrlType*)this)->Provider = NULL;
	/* transient soap skipped */
}

int ns7__ObjUrlType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ObjUrlType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__ObjUrlType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ObjUrlType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ObjUrlType(struct soap *soap, const char *tag, int id, const ns7__ObjUrlType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ObjUrlType), type);
	soap_out_std__string(soap, "ns7:Url", -1, &(((ns7__ObjUrlType*)a)->Url), "");
	soap_out_PointerTostd__string(soap, "ns7:IconUrl", -1, &(((ns7__ObjUrlType*)a)->IconUrl), "");
	soap_out_PointerTostd__string(soap, "ns7:LinkName", -1, &(((ns7__ObjUrlType*)a)->LinkName), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns7:SubjectType", -1, &(((ns7__ObjUrlType*)a)->SubjectType), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns7:Attribute", -1, &(((ns7__ObjUrlType*)a)->Attribute), "");
	soap_out_PointerTons7__ProviderType(soap, "ns7:Provider", -1, &(((ns7__ObjUrlType*)a)->Provider), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__ObjUrlType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ObjUrlType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ObjUrlType * SOAP_FMAC4 soap_get_ns7__ObjUrlType(struct soap *soap, ns7__ObjUrlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ObjUrlType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__ObjUrlType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__ObjUrlType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ObjUrlType * SOAP_FMAC4 soap_in_ns7__ObjUrlType(struct soap *soap, const char *tag, ns7__ObjUrlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ObjUrlType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ObjUrlType, sizeof(ns7__ObjUrlType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__ObjUrlType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ObjUrlType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Url1 = 1, soap_flag_IconUrl1 = 1, soap_flag_LinkName1 = 1, soap_flag_Provider1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:Url", &(((ns7__ObjUrlType*)a)->Url), "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_IconUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:IconUrl", &(((ns7__ObjUrlType*)a)->IconUrl), "xsd:string"))
				{	soap_flag_IconUrl1--;
					continue;
				}
			if (soap_flag_LinkName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:LinkName", &(((ns7__ObjUrlType*)a)->LinkName), "xsd:string"))
				{	soap_flag_LinkName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns7:SubjectType", &(((ns7__ObjUrlType*)a)->SubjectType), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns7:Attribute", &(((ns7__ObjUrlType*)a)->Attribute), "xsd:string"))
					continue;
			if (soap_flag_Provider1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ProviderType(soap, "ns7:Provider", &(((ns7__ObjUrlType*)a)->Provider), "ns7:ProviderType"))
				{	soap_flag_Provider1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Url1 > 0 || soap_flag_Provider1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__ObjUrlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ObjUrlType, 0, sizeof(ns7__ObjUrlType), 0, soap_copy_ns7__ObjUrlType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__ObjUrlType * SOAP_FMAC6 soap_new_ns7__ObjUrlType(struct soap *soap, int n)
{	return soap_instantiate_ns7__ObjUrlType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__ObjUrlType(struct soap *soap, ns7__ObjUrlType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__ObjUrlType * SOAP_FMAC4 soap_instantiate_ns7__ObjUrlType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ObjUrlType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ObjUrlType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__ObjUrlType;
		if (size)
			*size = sizeof(ns7__ObjUrlType);
		((ns7__ObjUrlType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__ObjUrlType[n];
		if (size)
			*size = n * sizeof(ns7__ObjUrlType);
		for (int i = 0; i < n; i++)
			((ns7__ObjUrlType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ObjUrlType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ObjUrlType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ObjUrlType %p -> %p\n", q, p));
	*(ns7__ObjUrlType*)p = *(ns7__ObjUrlType*)q;
}

void ns7__LinkSetDbType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__LinkSetDbType*)this)->DbTo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkSetDbType*)this)->DbTo);
	soap_embedded(soap, &((ns7__LinkSetDbType*)this)->LinkName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkSetDbType*)this)->LinkName);
	soap_serialize_PointerTostd__string(soap, &((ns7__LinkSetDbType*)this)->ERROR_);
	soap_serialize__ns7__union_LinkSetDbType(soap, ((ns7__LinkSetDbType*)this)->__union_LinkSetDbType, &((ns7__LinkSetDbType*)this)->union_LinkSetDbType);
	/* transient soap skipped */
}

void ns7__LinkSetDbType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__LinkSetDbType*)this)->DbTo);
	soap_default_std__string(soap, &((ns7__LinkSetDbType*)this)->LinkName);
	((ns7__LinkSetDbType*)this)->ERROR_ = NULL;
	((ns7__LinkSetDbType*)this)->__union_LinkSetDbType = 0;
	/* transient soap skipped */
}

int ns7__LinkSetDbType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__LinkSetDbType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__LinkSetDbType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__LinkSetDbType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__LinkSetDbType(struct soap *soap, const char *tag, int id, const ns7__LinkSetDbType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__LinkSetDbType), type);
	soap_out_std__string(soap, "ns7:DbTo", -1, &(((ns7__LinkSetDbType*)a)->DbTo), "");
	soap_out_std__string(soap, "ns7:LinkName", -1, &(((ns7__LinkSetDbType*)a)->LinkName), "");
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((ns7__LinkSetDbType*)a)->ERROR_), "");
	soap_out__ns7__union_LinkSetDbType(soap, ((ns7__LinkSetDbType*)a)->__union_LinkSetDbType, &((ns7__LinkSetDbType*)a)->union_LinkSetDbType);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__LinkSetDbType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__LinkSetDbType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__LinkSetDbType * SOAP_FMAC4 soap_get_ns7__LinkSetDbType(struct soap *soap, ns7__LinkSetDbType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__LinkSetDbType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__LinkSetDbType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__LinkSetDbType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__LinkSetDbType * SOAP_FMAC4 soap_in_ns7__LinkSetDbType(struct soap *soap, const char *tag, ns7__LinkSetDbType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__LinkSetDbType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__LinkSetDbType, sizeof(ns7__LinkSetDbType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__LinkSetDbType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__LinkSetDbType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DbTo1 = 1, soap_flag_LinkName1 = 1, soap_flag_ERROR_1 = 1, soap_flag_union_LinkSetDbType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:DbTo", &(((ns7__LinkSetDbType*)a)->DbTo), "xsd:string"))
				{	soap_flag_DbTo1--;
					continue;
				}
			if (soap_flag_LinkName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:LinkName", &(((ns7__LinkSetDbType*)a)->LinkName), "xsd:string"))
				{	soap_flag_LinkName1--;
					continue;
				}
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((ns7__LinkSetDbType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_union_LinkSetDbType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns7__union_LinkSetDbType(soap, &((ns7__LinkSetDbType*)a)->__union_LinkSetDbType, &((ns7__LinkSetDbType*)a)->union_LinkSetDbType))
				{	soap_flag_union_LinkSetDbType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DbTo1 > 0 || soap_flag_LinkName1 > 0 || soap_flag_union_LinkSetDbType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__LinkSetDbType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__LinkSetDbType, 0, sizeof(ns7__LinkSetDbType), 0, soap_copy_ns7__LinkSetDbType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__LinkSetDbType * SOAP_FMAC6 soap_new_ns7__LinkSetDbType(struct soap *soap, int n)
{	return soap_instantiate_ns7__LinkSetDbType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__LinkSetDbType(struct soap *soap, ns7__LinkSetDbType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__LinkSetDbType * SOAP_FMAC4 soap_instantiate_ns7__LinkSetDbType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__LinkSetDbType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__LinkSetDbType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__LinkSetDbType;
		if (size)
			*size = sizeof(ns7__LinkSetDbType);
		((ns7__LinkSetDbType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__LinkSetDbType[n];
		if (size)
			*size = n * sizeof(ns7__LinkSetDbType);
		for (int i = 0; i < n; i++)
			((ns7__LinkSetDbType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__LinkSetDbType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__LinkSetDbType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__LinkSetDbType %p -> %p\n", q, p));
	*(ns7__LinkSetDbType*)p = *(ns7__LinkSetDbType*)q;
}

void ns7__LinkSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__LinkSetType*)this)->DbFrom, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkSetType*)this)->DbFrom);
	soap_serialize_PointerTostd__string(soap, &((ns7__LinkSetType*)this)->ERROR_);
	soap_serialize_PointerTons7__IdListType(soap, &((ns7__LinkSetType*)this)->IdList);
	soap_serialize_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, &((ns7__LinkSetType*)this)->LinkSetDb);
	soap_serialize_PointerTons7__IdUrlListType(soap, &((ns7__LinkSetType*)this)->IdUrlList);
	soap_serialize_PointerTons7__IdCheckListType(soap, &((ns7__LinkSetType*)this)->IdCheckList);
	/* transient soap skipped */
}

void ns7__LinkSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__LinkSetType*)this)->DbFrom);
	((ns7__LinkSetType*)this)->ERROR_ = NULL;
	((ns7__LinkSetType*)this)->IdList = NULL;
	soap_default_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, &((ns7__LinkSetType*)this)->LinkSetDb);
	((ns7__LinkSetType*)this)->IdUrlList = NULL;
	((ns7__LinkSetType*)this)->IdCheckList = NULL;
	/* transient soap skipped */
}

int ns7__LinkSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__LinkSetType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__LinkSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__LinkSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__LinkSetType(struct soap *soap, const char *tag, int id, const ns7__LinkSetType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__LinkSetType), type);
	soap_out_std__string(soap, "ns7:DbFrom", -1, &(((ns7__LinkSetType*)a)->DbFrom), "");
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((ns7__LinkSetType*)a)->ERROR_), "");
	soap_out_PointerTons7__IdListType(soap, "ns7:IdList", -1, &(((ns7__LinkSetType*)a)->IdList), "");
	soap_out_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, "ns7:LinkSetDb", -1, &(((ns7__LinkSetType*)a)->LinkSetDb), "");
	soap_out_PointerTons7__IdUrlListType(soap, "ns7:IdUrlList", -1, &(((ns7__LinkSetType*)a)->IdUrlList), "");
	soap_out_PointerTons7__IdCheckListType(soap, "ns7:IdCheckList", -1, &(((ns7__LinkSetType*)a)->IdCheckList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__LinkSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__LinkSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__LinkSetType * SOAP_FMAC4 soap_get_ns7__LinkSetType(struct soap *soap, ns7__LinkSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__LinkSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__LinkSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__LinkSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__LinkSetType * SOAP_FMAC4 soap_in_ns7__LinkSetType(struct soap *soap, const char *tag, ns7__LinkSetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__LinkSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__LinkSetType, sizeof(ns7__LinkSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__LinkSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__LinkSetType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DbFrom1 = 1, soap_flag_ERROR_1 = 1, soap_flag_IdList1 = 1, soap_flag_IdUrlList1 = 1, soap_flag_IdCheckList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:DbFrom", &(((ns7__LinkSetType*)a)->DbFrom), "xsd:string"))
				{	soap_flag_DbFrom1--;
					continue;
				}
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((ns7__LinkSetType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_IdList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdListType(soap, "ns7:IdList", &(((ns7__LinkSetType*)a)->IdList), "ns7:IdListType"))
				{	soap_flag_IdList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, "ns7:LinkSetDb", &(((ns7__LinkSetType*)a)->LinkSetDb), "ns7:LinkSetDbType"))
					continue;
			if (soap_flag_IdUrlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdUrlListType(soap, "ns7:IdUrlList", &(((ns7__LinkSetType*)a)->IdUrlList), "ns7:IdUrlListType"))
				{	soap_flag_IdUrlList1--;
					continue;
				}
			if (soap_flag_IdCheckList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdCheckListType(soap, "ns7:IdCheckList", &(((ns7__LinkSetType*)a)->IdCheckList), "ns7:IdCheckListType"))
				{	soap_flag_IdCheckList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DbFrom1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__LinkSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__LinkSetType, 0, sizeof(ns7__LinkSetType), 0, soap_copy_ns7__LinkSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__LinkSetType * SOAP_FMAC6 soap_new_ns7__LinkSetType(struct soap *soap, int n)
{	return soap_instantiate_ns7__LinkSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__LinkSetType(struct soap *soap, ns7__LinkSetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__LinkSetType * SOAP_FMAC4 soap_instantiate_ns7__LinkSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__LinkSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__LinkSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__LinkSetType;
		if (size)
			*size = sizeof(ns7__LinkSetType);
		((ns7__LinkSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__LinkSetType[n];
		if (size)
			*size = n * sizeof(ns7__LinkSetType);
		for (int i = 0; i < n; i++)
			((ns7__LinkSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__LinkSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__LinkSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__LinkSetType %p -> %p\n", q, p));
	*(ns7__LinkSetType*)p = *(ns7__LinkSetType*)q;
}

void ns7__LinkInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__LinkInfoType*)this)->DbTo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkInfoType*)this)->DbTo);
	soap_embedded(soap, &((ns7__LinkInfoType*)this)->LinkName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkInfoType*)this)->LinkName);
	soap_embedded(soap, &((ns7__LinkInfoType*)this)->MenuTag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__LinkInfoType*)this)->MenuTag);
	/* transient soap skipped */
}

void ns7__LinkInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__LinkInfoType*)this)->DbTo);
	soap_default_std__string(soap, &((ns7__LinkInfoType*)this)->LinkName);
	soap_default_std__string(soap, &((ns7__LinkInfoType*)this)->MenuTag);
	/* transient soap skipped */
}

int ns7__LinkInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__LinkInfoType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__LinkInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__LinkInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__LinkInfoType(struct soap *soap, const char *tag, int id, const ns7__LinkInfoType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__LinkInfoType), type);
	soap_out_std__string(soap, "ns7:DbTo", -1, &(((ns7__LinkInfoType*)a)->DbTo), "");
	soap_out_std__string(soap, "ns7:LinkName", -1, &(((ns7__LinkInfoType*)a)->LinkName), "");
	soap_out_std__string(soap, "ns7:MenuTag", -1, &(((ns7__LinkInfoType*)a)->MenuTag), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__LinkInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__LinkInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__LinkInfoType * SOAP_FMAC4 soap_get_ns7__LinkInfoType(struct soap *soap, ns7__LinkInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__LinkInfoType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__LinkInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__LinkInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__LinkInfoType * SOAP_FMAC4 soap_in_ns7__LinkInfoType(struct soap *soap, const char *tag, ns7__LinkInfoType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__LinkInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__LinkInfoType, sizeof(ns7__LinkInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__LinkInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__LinkInfoType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DbTo1 = 1, soap_flag_LinkName1 = 1, soap_flag_MenuTag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:DbTo", &(((ns7__LinkInfoType*)a)->DbTo), "xsd:string"))
				{	soap_flag_DbTo1--;
					continue;
				}
			if (soap_flag_LinkName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:LinkName", &(((ns7__LinkInfoType*)a)->LinkName), "xsd:string"))
				{	soap_flag_LinkName1--;
					continue;
				}
			if (soap_flag_MenuTag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns7:MenuTag", &(((ns7__LinkInfoType*)a)->MenuTag), "xsd:string"))
				{	soap_flag_MenuTag1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DbTo1 > 0 || soap_flag_LinkName1 > 0 || soap_flag_MenuTag1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__LinkInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__LinkInfoType, 0, sizeof(ns7__LinkInfoType), 0, soap_copy_ns7__LinkInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__LinkInfoType * SOAP_FMAC6 soap_new_ns7__LinkInfoType(struct soap *soap, int n)
{	return soap_instantiate_ns7__LinkInfoType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__LinkInfoType(struct soap *soap, ns7__LinkInfoType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__LinkInfoType * SOAP_FMAC4 soap_instantiate_ns7__LinkInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__LinkInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__LinkInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__LinkInfoType;
		if (size)
			*size = sizeof(ns7__LinkInfoType);
		((ns7__LinkInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__LinkInfoType[n];
		if (size)
			*size = n * sizeof(ns7__LinkInfoType);
		for (int i = 0; i < n; i++)
			((ns7__LinkInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__LinkInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__LinkInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__LinkInfoType %p -> %p\n", q, p));
	*(ns7__LinkInfoType*)p = *(ns7__LinkInfoType*)q;
}

void ns7__LinkType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__IdType(soap, &((ns7__LinkType*)this)->Id);
	soap_serialize_PointerTostd__string(soap, &((ns7__LinkType*)this)->Score);
	/* transient soap skipped */
}

void ns7__LinkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns7__LinkType*)this)->Id = NULL;
	((ns7__LinkType*)this)->Score = NULL;
	/* transient soap skipped */
}

int ns7__LinkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__LinkType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__LinkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__LinkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__LinkType(struct soap *soap, const char *tag, int id, const ns7__LinkType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__LinkType), type);
	soap_out_PointerTons7__IdType(soap, "ns7:Id", -1, &(((ns7__LinkType*)a)->Id), "");
	soap_out_PointerTostd__string(soap, "ns7:Score", -1, &(((ns7__LinkType*)a)->Score), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__LinkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__LinkType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__LinkType * SOAP_FMAC4 soap_get_ns7__LinkType(struct soap *soap, ns7__LinkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__LinkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__LinkType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__LinkType * SOAP_FMAC4 soap_in_ns7__LinkType(struct soap *soap, const char *tag, ns7__LinkType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__LinkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__LinkType, sizeof(ns7__LinkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__LinkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__LinkType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Id1 = 1, soap_flag_Score1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdType(soap, "ns7:Id", &(((ns7__LinkType*)a)->Id), "ns7:IdType"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_Score1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:Score", &(((ns7__LinkType*)a)->Score), "xsd:string"))
				{	soap_flag_Score1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__LinkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__LinkType, 0, sizeof(ns7__LinkType), 0, soap_copy_ns7__LinkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__LinkType * SOAP_FMAC6 soap_new_ns7__LinkType(struct soap *soap, int n)
{	return soap_instantiate_ns7__LinkType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__LinkType(struct soap *soap, ns7__LinkType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__LinkType * SOAP_FMAC4 soap_instantiate_ns7__LinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__LinkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__LinkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__LinkType;
		if (size)
			*size = sizeof(ns7__LinkType);
		((ns7__LinkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__LinkType[n];
		if (size)
			*size = n * sizeof(ns7__LinkType);
		for (int i = 0; i < n; i++)
			((ns7__LinkType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__LinkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__LinkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__LinkType %p -> %p\n", q, p));
	*(ns7__LinkType*)p = *(ns7__LinkType*)q;
}

void ns7__IdUrlSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__IdType(soap, &((ns7__IdUrlSetType*)this)->Id);
	soap_serialize__ns7__union_IdUrlSetType(soap, ((ns7__IdUrlSetType*)this)->__union_IdUrlSetType, &((ns7__IdUrlSetType*)this)->union_IdUrlSetType);
	/* transient soap skipped */
}

void ns7__IdUrlSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns7__IdUrlSetType*)this)->Id = NULL;
	((ns7__IdUrlSetType*)this)->__union_IdUrlSetType = 0;
	/* transient soap skipped */
}

int ns7__IdUrlSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdUrlSetType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdUrlSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdUrlSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdUrlSetType(struct soap *soap, const char *tag, int id, const ns7__IdUrlSetType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__IdUrlSetType), type);
	soap_out_PointerTons7__IdType(soap, "ns7:Id", -1, &(((ns7__IdUrlSetType*)a)->Id), "");
	soap_out__ns7__union_IdUrlSetType(soap, ((ns7__IdUrlSetType*)a)->__union_IdUrlSetType, &((ns7__IdUrlSetType*)a)->union_IdUrlSetType);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__IdUrlSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdUrlSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdUrlSetType * SOAP_FMAC4 soap_get_ns7__IdUrlSetType(struct soap *soap, ns7__IdUrlSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdUrlSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdUrlSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdUrlSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdUrlSetType * SOAP_FMAC4 soap_in_ns7__IdUrlSetType(struct soap *soap, const char *tag, ns7__IdUrlSetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__IdUrlSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdUrlSetType, sizeof(ns7__IdUrlSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdUrlSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__IdUrlSetType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Id1 = 1, soap_flag_union_IdUrlSetType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__IdType(soap, "ns7:Id", &(((ns7__IdUrlSetType*)a)->Id), "ns7:IdType"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap_flag_union_IdUrlSetType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns7__union_IdUrlSetType(soap, &((ns7__IdUrlSetType*)a)->__union_IdUrlSetType, &((ns7__IdUrlSetType*)a)->union_IdUrlSetType))
				{	soap_flag_union_IdUrlSetType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_union_IdUrlSetType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__IdUrlSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__IdUrlSetType, 0, sizeof(ns7__IdUrlSetType), 0, soap_copy_ns7__IdUrlSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__IdUrlSetType * SOAP_FMAC6 soap_new_ns7__IdUrlSetType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdUrlSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdUrlSetType(struct soap *soap, ns7__IdUrlSetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdUrlSetType * SOAP_FMAC4 soap_instantiate_ns7__IdUrlSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdUrlSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdUrlSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdUrlSetType;
		if (size)
			*size = sizeof(ns7__IdUrlSetType);
		((ns7__IdUrlSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdUrlSetType[n];
		if (size)
			*size = n * sizeof(ns7__IdUrlSetType);
		for (int i = 0; i < n; i++)
			((ns7__IdUrlSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdUrlSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdUrlSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdUrlSetType %p -> %p\n", q, p));
	*(ns7__IdUrlSetType*)p = *(ns7__IdUrlSetType*)q;
}

void ns7__IdUrlListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, &((ns7__IdUrlListType*)this)->IdUrlSet);
	soap_serialize_PointerTostd__string(soap, &((ns7__IdUrlListType*)this)->ERROR_);
	/* transient soap skipped */
}

void ns7__IdUrlListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, &((ns7__IdUrlListType*)this)->IdUrlSet);
	((ns7__IdUrlListType*)this)->ERROR_ = NULL;
	/* transient soap skipped */
}

int ns7__IdUrlListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdUrlListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdUrlListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdUrlListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdUrlListType(struct soap *soap, const char *tag, int id, const ns7__IdUrlListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__IdUrlListType), type);
	soap_out_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, "ns7:IdUrlSet", -1, &(((ns7__IdUrlListType*)a)->IdUrlSet), "");
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((ns7__IdUrlListType*)a)->ERROR_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__IdUrlListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdUrlListType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdUrlListType * SOAP_FMAC4 soap_get_ns7__IdUrlListType(struct soap *soap, ns7__IdUrlListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdUrlListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdUrlListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdUrlListType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdUrlListType * SOAP_FMAC4 soap_in_ns7__IdUrlListType(struct soap *soap, const char *tag, ns7__IdUrlListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__IdUrlListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdUrlListType, sizeof(ns7__IdUrlListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdUrlListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__IdUrlListType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, "ns7:IdUrlSet", &(((ns7__IdUrlListType*)a)->IdUrlSet), "ns7:IdUrlSetType"))
					continue;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((ns7__IdUrlListType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__IdUrlListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__IdUrlListType, 0, sizeof(ns7__IdUrlListType), 0, soap_copy_ns7__IdUrlListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__IdUrlListType * SOAP_FMAC6 soap_new_ns7__IdUrlListType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdUrlListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdUrlListType(struct soap *soap, ns7__IdUrlListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdUrlListType * SOAP_FMAC4 soap_instantiate_ns7__IdUrlListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdUrlListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdUrlListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdUrlListType;
		if (size)
			*size = sizeof(ns7__IdUrlListType);
		((ns7__IdUrlListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdUrlListType[n];
		if (size)
			*size = n * sizeof(ns7__IdUrlListType);
		for (int i = 0; i < n; i++)
			((ns7__IdUrlListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdUrlListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdUrlListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdUrlListType %p -> %p\n", q, p));
	*(ns7__IdUrlListType*)p = *(ns7__IdUrlListType*)q;
}

void ns7__IdListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons7__IdType(soap, &((ns7__IdListType*)this)->Id);
	/* transient soap skipped */
}

void ns7__IdListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__IdType(soap, &((ns7__IdListType*)this)->Id);
	/* transient soap skipped */
}

int ns7__IdListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdListType(struct soap *soap, const char *tag, int id, const ns7__IdListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__IdListType), type);
	soap_out_std__vectorTemplateOfPointerTons7__IdType(soap, "ns7:Id", -1, &(((ns7__IdListType*)a)->Id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__IdListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdListType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdListType * SOAP_FMAC4 soap_get_ns7__IdListType(struct soap *soap, ns7__IdListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdListType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdListType * SOAP_FMAC4 soap_in_ns7__IdListType(struct soap *soap, const char *tag, ns7__IdListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__IdListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdListType, sizeof(ns7__IdListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__IdListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__IdType(soap, "ns7:Id", &(((ns7__IdListType*)a)->Id), "ns7:IdType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__IdListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__IdListType, 0, sizeof(ns7__IdListType), 0, soap_copy_ns7__IdListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__IdListType * SOAP_FMAC6 soap_new_ns7__IdListType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdListType(struct soap *soap, ns7__IdListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdListType * SOAP_FMAC4 soap_instantiate_ns7__IdListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdListType;
		if (size)
			*size = sizeof(ns7__IdListType);
		((ns7__IdListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdListType[n];
		if (size)
			*size = n * sizeof(ns7__IdListType);
		for (int i = 0; i < n; i++)
			((ns7__IdListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdListType %p -> %p\n", q, p));
	*(ns7__IdListType*)p = *(ns7__IdListType*)q;
}

void ns7__IdLinkSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, &((ns7__IdLinkSetType*)this)->LinkInfo);
	/* transient soap skipped */
}

void ns7__IdLinkSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, &((ns7__IdLinkSetType*)this)->LinkInfo);
	/* transient soap skipped */
}

int ns7__IdLinkSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdLinkSetType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdLinkSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdLinkSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdLinkSetType(struct soap *soap, const char *tag, int id, const ns7__IdLinkSetType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__IdLinkSetType), type);
	soap_out_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, "ns7:LinkInfo", -1, &(((ns7__IdLinkSetType*)a)->LinkInfo), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__IdLinkSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdLinkSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdLinkSetType * SOAP_FMAC4 soap_get_ns7__IdLinkSetType(struct soap *soap, ns7__IdLinkSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdLinkSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdLinkSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdLinkSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdLinkSetType * SOAP_FMAC4 soap_in_ns7__IdLinkSetType(struct soap *soap, const char *tag, ns7__IdLinkSetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__IdLinkSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdLinkSetType, sizeof(ns7__IdLinkSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdLinkSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__IdLinkSetType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, "ns7:LinkInfo", &(((ns7__IdLinkSetType*)a)->LinkInfo), "ns7:LinkInfoType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__IdLinkSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__IdLinkSetType, 0, sizeof(ns7__IdLinkSetType), 0, soap_copy_ns7__IdLinkSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__IdLinkSetType * SOAP_FMAC6 soap_new_ns7__IdLinkSetType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdLinkSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdLinkSetType(struct soap *soap, ns7__IdLinkSetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdLinkSetType * SOAP_FMAC4 soap_instantiate_ns7__IdLinkSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdLinkSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdLinkSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdLinkSetType;
		if (size)
			*size = sizeof(ns7__IdLinkSetType);
		((ns7__IdLinkSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdLinkSetType[n];
		if (size)
			*size = n * sizeof(ns7__IdLinkSetType);
		for (int i = 0; i < n; i++)
			((ns7__IdLinkSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdLinkSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdLinkSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdLinkSetType %p -> %p\n", q, p));
	*(ns7__IdLinkSetType*)p = *(ns7__IdLinkSetType*)q;
}

void ns7__IdCheckListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns7__IdCheckListType*)this)->ERROR_);
	if (((ns7__IdCheckListType*)this)->__union_IdCheckListType)
	{	int i;
		for (i = 0; i < ((ns7__IdCheckListType*)this)->__size_IdCheckListType; i++)
		{
			soap_serialize___ns7__union_IdCheckListType(soap, ((ns7__IdCheckListType*)this)->__union_IdCheckListType + i);
		}
	}
	/* transient soap skipped */
}

void ns7__IdCheckListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns7__IdCheckListType*)this)->ERROR_ = NULL;
	((ns7__IdCheckListType*)this)->__size_IdCheckListType = 0;
	((ns7__IdCheckListType*)this)->__union_IdCheckListType = NULL;
	/* transient soap skipped */
}

int ns7__IdCheckListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdCheckListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdCheckListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdCheckListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdCheckListType(struct soap *soap, const char *tag, int id, const ns7__IdCheckListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__IdCheckListType), type);
	soap_out_PointerTostd__string(soap, "ns7:ERROR_", -1, &(((ns7__IdCheckListType*)a)->ERROR_), "");
	if (((ns7__IdCheckListType*)a)->__union_IdCheckListType)
	{	int i;
		for (i = 0; i < ((ns7__IdCheckListType*)a)->__size_IdCheckListType; i++)
			soap_out___ns7__union_IdCheckListType(soap, "-union-IdCheckListType", -1, ((ns7__IdCheckListType*)a)->__union_IdCheckListType + i, "");
	}
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__IdCheckListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdCheckListType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdCheckListType * SOAP_FMAC4 soap_get_ns7__IdCheckListType(struct soap *soap, ns7__IdCheckListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdCheckListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdCheckListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdCheckListType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdCheckListType * SOAP_FMAC4 soap_in_ns7__IdCheckListType(struct soap *soap, const char *tag, ns7__IdCheckListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__IdCheckListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdCheckListType, sizeof(ns7__IdCheckListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdCheckListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__IdCheckListType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1, soap_flag___union_IdCheckListType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns7:ERROR_", &(((ns7__IdCheckListType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag___union_IdCheckListType1 && soap->error == SOAP_TAG_MISMATCH)
			{	struct __ns7__union_IdCheckListType *p;
				soap_new_block(soap);
				for (((ns7__IdCheckListType*)a)->__size_IdCheckListType = 0; !soap_element_begin_in(soap, "-union-IdCheckListType", 1, NULL); ((ns7__IdCheckListType*)a)->__size_IdCheckListType++)
				{	p = (struct __ns7__union_IdCheckListType *)soap_push_block(soap, sizeof(struct __ns7__union_IdCheckListType));
					if (!p)
						return NULL;
					soap_default___ns7__union_IdCheckListType(soap, p);
					if (!soap_in___ns7__union_IdCheckListType(soap, "-union-IdCheckListType", p, "-ns7:union-IdCheckListType"))
						break;
					soap_flag___union_IdCheckListType1 = 0;
				}
				((ns7__IdCheckListType*)a)->__union_IdCheckListType = (struct __ns7__union_IdCheckListType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___union_IdCheckListType1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__IdCheckListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__IdCheckListType, 0, sizeof(ns7__IdCheckListType), 0, soap_copy_ns7__IdCheckListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__IdCheckListType * SOAP_FMAC6 soap_new_ns7__IdCheckListType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdCheckListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdCheckListType(struct soap *soap, ns7__IdCheckListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdCheckListType * SOAP_FMAC4 soap_instantiate_ns7__IdCheckListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdCheckListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdCheckListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdCheckListType;
		if (size)
			*size = sizeof(ns7__IdCheckListType);
		((ns7__IdCheckListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdCheckListType[n];
		if (size)
			*size = n * sizeof(ns7__IdCheckListType);
		for (int i = 0; i < n; i++)
			((ns7__IdCheckListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdCheckListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdCheckListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdCheckListType %p -> %p\n", q, p));
	*(ns7__IdCheckListType*)p = *(ns7__IdCheckListType*)q;
}

void ns7__IdType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__IdType*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns7__IdType*)this)->__item);
	/* transient soap skipped */
}

void ns7__IdType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns7__IdType*)this)->__item);
	soap_default__ns7__IdType_HasLinkOut(soap, &((ns7__IdType*)this)->HasLinkOut);
	soap_default__ns7__IdType_HasNeighbor(soap, &((ns7__IdType*)this)->HasNeighbor);
	/* transient soap skipped */
}

int ns7__IdType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__IdType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__IdType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__IdType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__IdType(struct soap *soap, const char *tag, int id, const ns7__IdType *a, const char *type)
{
	soap_set_attr(soap, "HasLinkOut", soap__ns7__IdType_HasLinkOut2s(soap, ((ns7__IdType *)a)->HasLinkOut));
	soap_set_attr(soap, "HasNeighbor", soap__ns7__IdType_HasNeighbor2s(soap, ((ns7__IdType *)a)->HasNeighbor));
	return soap_out_std__string(soap, tag, id, &(((ns7__IdType*)a)->__item), "");
}

void *ns7__IdType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__IdType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__IdType * SOAP_FMAC4 soap_get_ns7__IdType(struct soap *soap, ns7__IdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__IdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__IdType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__IdType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__IdType * SOAP_FMAC4 soap_in_ns7__IdType(struct soap *soap, const char *tag, ns7__IdType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns7__IdType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__IdType, sizeof(ns7__IdType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__IdType)
			return (ns7__IdType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2_ns7__IdType_HasLinkOut(soap, soap_attr_value(soap, "HasLinkOut", 0), &((ns7__IdType *)a)->HasLinkOut))
		return NULL;
	if (soap_s2_ns7__IdType_HasNeighbor(soap, soap_attr_value(soap, "HasNeighbor", 0), &((ns7__IdType *)a)->HasNeighbor))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(((ns7__IdType*)a)->__item), "ns7:IdType"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns7__IdType * SOAP_FMAC6 soap_new_ns7__IdType(struct soap *soap, int n)
{	return soap_instantiate_ns7__IdType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__IdType(struct soap *soap, ns7__IdType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__IdType * SOAP_FMAC4 soap_instantiate_ns7__IdType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__IdType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__IdType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__IdType;
		if (size)
			*size = sizeof(ns7__IdType);
		((ns7__IdType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__IdType[n];
		if (size)
			*size = n * sizeof(ns7__IdType);
		for (int i = 0; i < n; i++)
			((ns7__IdType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__IdType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__IdType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__IdType %p -> %p\n", q, p));
	*(ns7__IdType*)p = *(ns7__IdType*)q;
}

void _ns6__eSummaryResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__eSummaryResultType(soap, &((_ns6__eSummaryResultMS*)this)->eSummaryResult);
	/* transient soap skipped */
}

void _ns6__eSummaryResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns6__eSummaryResultMS*)this)->eSummaryResult = NULL;
	/* transient soap skipped */
}

int _ns6__eSummaryResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__eSummaryResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__eSummaryResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__eSummaryResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__eSummaryResultMS(struct soap *soap, const char *tag, int id, const _ns6__eSummaryResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__eSummaryResultMS), type);
	if (a->eSummaryResult)
		soap_element_result(soap, "ns6:eSummaryResult");
	soap_out_PointerTons6__eSummaryResultType(soap, "ns6:eSummaryResult", -1, &(((_ns6__eSummaryResultMS*)a)->eSummaryResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns6__eSummaryResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__eSummaryResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__eSummaryResultMS * SOAP_FMAC4 soap_get__ns6__eSummaryResultMS(struct soap *soap, _ns6__eSummaryResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__eSummaryResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns6__eSummaryResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__eSummaryResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__eSummaryResultMS * SOAP_FMAC4 soap_in__ns6__eSummaryResultMS(struct soap *soap, const char *tag, _ns6__eSummaryResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__eSummaryResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__eSummaryResultMS, sizeof(_ns6__eSummaryResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__eSummaryResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__eSummaryResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eSummaryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eSummaryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__eSummaryResultType(soap, "ns6:eSummaryResult", &(((_ns6__eSummaryResultMS*)a)->eSummaryResult), "ns6:eSummaryResultType"))
				{	soap_flag_eSummaryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:eSummaryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__eSummaryResultMS, 0, sizeof(_ns6__eSummaryResultMS), 0, soap_copy__ns6__eSummaryResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns6__eSummaryResultMS * SOAP_FMAC6 soap_new__ns6__eSummaryResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns6__eSummaryResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns6__eSummaryResultMS(struct soap *soap, _ns6__eSummaryResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns6__eSummaryResultMS * SOAP_FMAC4 soap_instantiate__ns6__eSummaryResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__eSummaryResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__eSummaryResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__eSummaryResultMS;
		if (size)
			*size = sizeof(_ns6__eSummaryResultMS);
		((_ns6__eSummaryResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__eSummaryResultMS[n];
		if (size)
			*size = n * sizeof(_ns6__eSummaryResultMS);
		for (int i = 0; i < n; i++)
			((_ns6__eSummaryResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__eSummaryResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__eSummaryResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__eSummaryResultMS %p -> %p\n", q, p));
	*(_ns6__eSummaryResultMS*)p = *(_ns6__eSummaryResultMS*)q;
}

void _ns6__eSummaryRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->query_USCOREkey);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->retstart);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->retmax);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequestMS*)this)->email);
	/* transient soap skipped */
}

void _ns6__eSummaryRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns6__eSummaryRequestMS*)this)->db = NULL;
	((_ns6__eSummaryRequestMS*)this)->id = NULL;
	((_ns6__eSummaryRequestMS*)this)->WebEnv = NULL;
	((_ns6__eSummaryRequestMS*)this)->query_USCOREkey = NULL;
	((_ns6__eSummaryRequestMS*)this)->retstart = NULL;
	((_ns6__eSummaryRequestMS*)this)->retmax = NULL;
	((_ns6__eSummaryRequestMS*)this)->tool = NULL;
	((_ns6__eSummaryRequestMS*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns6__eSummaryRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__eSummaryRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__eSummaryRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__eSummaryRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__eSummaryRequestMS(struct soap *soap, const char *tag, int id, const _ns6__eSummaryRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__eSummaryRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns6:db", -1, &(((_ns6__eSummaryRequestMS*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns6:id", -1, &(((_ns6__eSummaryRequestMS*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns6:WebEnv", -1, &(((_ns6__eSummaryRequestMS*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns6:query_key", -1, &(((_ns6__eSummaryRequestMS*)a)->query_USCOREkey), "");
	soap_out_PointerTostd__string(soap, "ns6:retstart", -1, &(((_ns6__eSummaryRequestMS*)a)->retstart), "");
	soap_out_PointerTostd__string(soap, "ns6:retmax", -1, &(((_ns6__eSummaryRequestMS*)a)->retmax), "");
	soap_out_PointerTostd__string(soap, "ns6:tool", -1, &(((_ns6__eSummaryRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns6:email", -1, &(((_ns6__eSummaryRequestMS*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns6__eSummaryRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__eSummaryRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__eSummaryRequestMS * SOAP_FMAC4 soap_get__ns6__eSummaryRequestMS(struct soap *soap, _ns6__eSummaryRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__eSummaryRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns6__eSummaryRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__eSummaryRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__eSummaryRequestMS * SOAP_FMAC4 soap_in__ns6__eSummaryRequestMS(struct soap *soap, const char *tag, _ns6__eSummaryRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__eSummaryRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__eSummaryRequestMS, sizeof(_ns6__eSummaryRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__eSummaryRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__eSummaryRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_id1 = 1, soap_flag_WebEnv1 = 1, soap_flag_query_USCOREkey1 = 1, soap_flag_retstart1 = 1, soap_flag_retmax1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:db", &(((_ns6__eSummaryRequestMS*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:id", &(((_ns6__eSummaryRequestMS*)a)->id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:WebEnv", &(((_ns6__eSummaryRequestMS*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_query_USCOREkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:query_key", &(((_ns6__eSummaryRequestMS*)a)->query_USCOREkey), "xsd:string"))
				{	soap_flag_query_USCOREkey1--;
					continue;
				}
			if (soap_flag_retstart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:retstart", &(((_ns6__eSummaryRequestMS*)a)->retstart), "xsd:string"))
				{	soap_flag_retstart1--;
					continue;
				}
			if (soap_flag_retmax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:retmax", &(((_ns6__eSummaryRequestMS*)a)->retmax), "xsd:string"))
				{	soap_flag_retmax1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:tool", &(((_ns6__eSummaryRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:email", &(((_ns6__eSummaryRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__eSummaryRequestMS, 0, sizeof(_ns6__eSummaryRequestMS), 0, soap_copy__ns6__eSummaryRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns6__eSummaryRequestMS * SOAP_FMAC6 soap_new__ns6__eSummaryRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns6__eSummaryRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns6__eSummaryRequestMS(struct soap *soap, _ns6__eSummaryRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns6__eSummaryRequestMS * SOAP_FMAC4 soap_instantiate__ns6__eSummaryRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__eSummaryRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__eSummaryRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__eSummaryRequestMS;
		if (size)
			*size = sizeof(_ns6__eSummaryRequestMS);
		((_ns6__eSummaryRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__eSummaryRequestMS[n];
		if (size)
			*size = n * sizeof(_ns6__eSummaryRequestMS);
		for (int i = 0; i < n; i++)
			((_ns6__eSummaryRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__eSummaryRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__eSummaryRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__eSummaryRequestMS %p -> %p\n", q, p));
	*(_ns6__eSummaryRequestMS*)p = *(_ns6__eSummaryRequestMS*)q;
}

void _ns6__eSummaryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->id);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->query_USCOREkey);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->retstart);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->retmax);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryRequest*)this)->email);
	/* transient soap skipped */
}

void _ns6__eSummaryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns6__eSummaryRequest*)this)->db = NULL;
	((_ns6__eSummaryRequest*)this)->id = NULL;
	((_ns6__eSummaryRequest*)this)->WebEnv = NULL;
	((_ns6__eSummaryRequest*)this)->query_USCOREkey = NULL;
	((_ns6__eSummaryRequest*)this)->retstart = NULL;
	((_ns6__eSummaryRequest*)this)->retmax = NULL;
	((_ns6__eSummaryRequest*)this)->tool = NULL;
	((_ns6__eSummaryRequest*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns6__eSummaryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__eSummaryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__eSummaryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__eSummaryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__eSummaryRequest(struct soap *soap, const char *tag, int id, const _ns6__eSummaryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__eSummaryRequest), type);
	soap_out_PointerTostd__string(soap, "ns6:db", -1, &(((_ns6__eSummaryRequest*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns6:id", -1, &(((_ns6__eSummaryRequest*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ns6:WebEnv", -1, &(((_ns6__eSummaryRequest*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns6:query_key", -1, &(((_ns6__eSummaryRequest*)a)->query_USCOREkey), "");
	soap_out_PointerTostd__string(soap, "ns6:retstart", -1, &(((_ns6__eSummaryRequest*)a)->retstart), "");
	soap_out_PointerTostd__string(soap, "ns6:retmax", -1, &(((_ns6__eSummaryRequest*)a)->retmax), "");
	soap_out_PointerTostd__string(soap, "ns6:tool", -1, &(((_ns6__eSummaryRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns6:email", -1, &(((_ns6__eSummaryRequest*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns6__eSummaryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__eSummaryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__eSummaryRequest * SOAP_FMAC4 soap_get__ns6__eSummaryRequest(struct soap *soap, _ns6__eSummaryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__eSummaryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns6__eSummaryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__eSummaryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__eSummaryRequest * SOAP_FMAC4 soap_in__ns6__eSummaryRequest(struct soap *soap, const char *tag, _ns6__eSummaryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__eSummaryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__eSummaryRequest, sizeof(_ns6__eSummaryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__eSummaryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__eSummaryRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_id1 = 1, soap_flag_WebEnv1 = 1, soap_flag_query_USCOREkey1 = 1, soap_flag_retstart1 = 1, soap_flag_retmax1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:db", &(((_ns6__eSummaryRequest*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:id", &(((_ns6__eSummaryRequest*)a)->id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:WebEnv", &(((_ns6__eSummaryRequest*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_query_USCOREkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:query_key", &(((_ns6__eSummaryRequest*)a)->query_USCOREkey), "xsd:string"))
				{	soap_flag_query_USCOREkey1--;
					continue;
				}
			if (soap_flag_retstart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:retstart", &(((_ns6__eSummaryRequest*)a)->retstart), "xsd:string"))
				{	soap_flag_retstart1--;
					continue;
				}
			if (soap_flag_retmax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:retmax", &(((_ns6__eSummaryRequest*)a)->retmax), "xsd:string"))
				{	soap_flag_retmax1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:tool", &(((_ns6__eSummaryRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:email", &(((_ns6__eSummaryRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__eSummaryRequest, 0, sizeof(_ns6__eSummaryRequest), 0, soap_copy__ns6__eSummaryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns6__eSummaryRequest * SOAP_FMAC6 soap_new__ns6__eSummaryRequest(struct soap *soap, int n)
{	return soap_instantiate__ns6__eSummaryRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns6__eSummaryRequest(struct soap *soap, _ns6__eSummaryRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns6__eSummaryRequest * SOAP_FMAC4 soap_instantiate__ns6__eSummaryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__eSummaryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__eSummaryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__eSummaryRequest;
		if (size)
			*size = sizeof(_ns6__eSummaryRequest);
		((_ns6__eSummaryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__eSummaryRequest[n];
		if (size)
			*size = n * sizeof(_ns6__eSummaryRequest);
		for (int i = 0; i < n; i++)
			((_ns6__eSummaryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__eSummaryRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__eSummaryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__eSummaryRequest %p -> %p\n", q, p));
	*(_ns6__eSummaryRequest*)p = *(_ns6__eSummaryRequest*)q;
}

void _ns6__eSummaryResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns6__eSummaryResult*)this)->ERROR_);
	soap_serialize_std__vectorTemplateOfPointerTons6__DocSumType(soap, &((_ns6__eSummaryResult*)this)->DocSum);
	/* transient soap skipped */
}

void _ns6__eSummaryResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns6__eSummaryResult*)this)->ERROR_ = NULL;
	soap_default_std__vectorTemplateOfPointerTons6__DocSumType(soap, &((_ns6__eSummaryResult*)this)->DocSum);
	/* transient soap skipped */
}

int _ns6__eSummaryResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__eSummaryResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__eSummaryResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__eSummaryResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__eSummaryResult(struct soap *soap, const char *tag, int id, const _ns6__eSummaryResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__eSummaryResult), type);
	if (a->ERROR_)
		soap_element_result(soap, "ns6:ERROR_");
	soap_out_PointerTostd__string(soap, "ns6:ERROR_", -1, &(((_ns6__eSummaryResult*)a)->ERROR_), "");
	soap_out_std__vectorTemplateOfPointerTons6__DocSumType(soap, "ns6:DocSum", -1, &(((_ns6__eSummaryResult*)a)->DocSum), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns6__eSummaryResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__eSummaryResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__eSummaryResult * SOAP_FMAC4 soap_get__ns6__eSummaryResult(struct soap *soap, _ns6__eSummaryResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__eSummaryResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns6__eSummaryResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__eSummaryResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__eSummaryResult * SOAP_FMAC4 soap_in__ns6__eSummaryResult(struct soap *soap, const char *tag, _ns6__eSummaryResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__eSummaryResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__eSummaryResult, sizeof(_ns6__eSummaryResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__eSummaryResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__eSummaryResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:ERROR_", &(((_ns6__eSummaryResult*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocSumType(soap, "ns6:DocSum", &(((_ns6__eSummaryResult*)a)->DocSum), "ns6:DocSumType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns6:ERROR_");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__eSummaryResult, 0, sizeof(_ns6__eSummaryResult), 0, soap_copy__ns6__eSummaryResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns6__eSummaryResult * SOAP_FMAC6 soap_new__ns6__eSummaryResult(struct soap *soap, int n)
{	return soap_instantiate__ns6__eSummaryResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns6__eSummaryResult(struct soap *soap, _ns6__eSummaryResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns6__eSummaryResult * SOAP_FMAC4 soap_instantiate__ns6__eSummaryResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__eSummaryResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__eSummaryResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__eSummaryResult;
		if (size)
			*size = sizeof(_ns6__eSummaryResult);
		((_ns6__eSummaryResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__eSummaryResult[n];
		if (size)
			*size = n * sizeof(_ns6__eSummaryResult);
		for (int i = 0; i < n; i++)
			((_ns6__eSummaryResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__eSummaryResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__eSummaryResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__eSummaryResult %p -> %p\n", q, p));
	*(_ns6__eSummaryResult*)p = *(_ns6__eSummaryResult*)q;
}

void ns6__eSummaryResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns6__eSummaryResultType*)this)->ERROR_);
	soap_serialize_std__vectorTemplateOfPointerTons6__DocSumType(soap, &((ns6__eSummaryResultType*)this)->DocSum);
	/* transient soap skipped */
}

void ns6__eSummaryResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns6__eSummaryResultType*)this)->ERROR_ = NULL;
	soap_default_std__vectorTemplateOfPointerTons6__DocSumType(soap, &((ns6__eSummaryResultType*)this)->DocSum);
	/* transient soap skipped */
}

int ns6__eSummaryResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__eSummaryResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__eSummaryResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__eSummaryResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__eSummaryResultType(struct soap *soap, const char *tag, int id, const ns6__eSummaryResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__eSummaryResultType), type);
	soap_out_PointerTostd__string(soap, "ns6:ERROR_", -1, &(((ns6__eSummaryResultType*)a)->ERROR_), "");
	soap_out_std__vectorTemplateOfPointerTons6__DocSumType(soap, "ns6:DocSum", -1, &(((ns6__eSummaryResultType*)a)->DocSum), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns6__eSummaryResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__eSummaryResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__eSummaryResultType * SOAP_FMAC4 soap_get_ns6__eSummaryResultType(struct soap *soap, ns6__eSummaryResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__eSummaryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns6__eSummaryResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__eSummaryResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__eSummaryResultType * SOAP_FMAC4 soap_in_ns6__eSummaryResultType(struct soap *soap, const char *tag, ns6__eSummaryResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__eSummaryResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__eSummaryResultType, sizeof(ns6__eSummaryResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__eSummaryResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__eSummaryResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns6:ERROR_", &(((ns6__eSummaryResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocSumType(soap, "ns6:DocSum", &(((ns6__eSummaryResultType*)a)->DocSum), "ns6:DocSumType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__eSummaryResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__eSummaryResultType, 0, sizeof(ns6__eSummaryResultType), 0, soap_copy_ns6__eSummaryResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns6__eSummaryResultType * SOAP_FMAC6 soap_new_ns6__eSummaryResultType(struct soap *soap, int n)
{	return soap_instantiate_ns6__eSummaryResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__eSummaryResultType(struct soap *soap, ns6__eSummaryResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns6__eSummaryResultType * SOAP_FMAC4 soap_instantiate_ns6__eSummaryResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__eSummaryResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__eSummaryResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__eSummaryResultType;
		if (size)
			*size = sizeof(ns6__eSummaryResultType);
		((ns6__eSummaryResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__eSummaryResultType[n];
		if (size)
			*size = n * sizeof(ns6__eSummaryResultType);
		for (int i = 0; i < n; i++)
			((ns6__eSummaryResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__eSummaryResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__eSummaryResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__eSummaryResultType %p -> %p\n", q, p));
	*(ns6__eSummaryResultType*)p = *(ns6__eSummaryResultType*)q;
}

void ns6__ItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (((ns6__ItemType*)this)->__union_ItemType)
	{	int i;
		for (i = 0; i < ((ns6__ItemType*)this)->__size_ItemType; i++)
		{
			soap_serialize___ns6__union_ItemType(soap, ((ns6__ItemType*)this)->__union_ItemType + i);
		}
	}
	/* transient soap skipped */
}

void ns6__ItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns6__ItemType*)this)->__size_ItemType = 0;
	((ns6__ItemType*)this)->__union_ItemType = NULL;
	soap_default_std__string(soap, &((ns6__ItemType*)this)->Name);
	soap_default__ns6__ItemType_Type(soap, &((ns6__ItemType*)this)->Type);
	((ns6__ItemType*)this)->__mixed = NULL;
	/* transient soap skipped */
}

int ns6__ItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ItemType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ItemType(struct soap *soap, const char *tag, int id, const ns6__ItemType *a, const char *type)
{
	if (!((ns6__ItemType *)a)->Name.empty())
		soap_set_attr(soap, "Name", ((ns6__ItemType *)a)->Name.c_str());
	soap_set_attr(soap, "Type", soap__ns6__ItemType_Type2s(soap, ((ns6__ItemType *)a)->Type));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ItemType), type);
	if (((ns6__ItemType*)a)->__union_ItemType)
	{	int i;
		for (i = 0; i < ((ns6__ItemType*)a)->__size_ItemType; i++)
			soap_out___ns6__union_ItemType(soap, "-union-ItemType", -1, ((ns6__ItemType*)a)->__union_ItemType + i, "");
	}
	soap_outliteral(soap, "-mixed", &(((ns6__ItemType*)a)->__mixed), NULL);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns6__ItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ItemType * SOAP_FMAC4 soap_get_ns6__ItemType(struct soap *soap, ns6__ItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns6__ItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ItemType * SOAP_FMAC4 soap_in_ns6__ItemType(struct soap *soap, const char *tag, ns6__ItemType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ItemType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ItemType, sizeof(ns6__ItemType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ItemType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ItemType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((ns6__ItemType *)a)->Name.assign(s);
		}
	}
	if (soap_s2_ns6__ItemType_Type(soap, soap_attr_value(soap, "Type", 1), &((ns6__ItemType *)a)->Type))
		return NULL;
	short soap_flag___union_ItemType1 = 1, soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___union_ItemType1 && soap->error == SOAP_TAG_MISMATCH)
			{	struct __ns6__union_ItemType *p;
				soap_new_block(soap);
				for (((ns6__ItemType*)a)->__size_ItemType = 0; !soap_element_begin_in(soap, "-union-ItemType", 1, NULL); ((ns6__ItemType*)a)->__size_ItemType++)
				{	p = (struct __ns6__union_ItemType *)soap_push_block(soap, sizeof(struct __ns6__union_ItemType));
					if (!p)
						return NULL;
					soap_default___ns6__union_ItemType(soap, p);
					if (!soap_in___ns6__union_ItemType(soap, "-union-ItemType", p, "-ns6:union-ItemType"))
						break;
					soap_flag___union_ItemType1 = 0;
				}
				((ns6__ItemType*)a)->__union_ItemType = (struct __ns6__union_ItemType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___union_ItemType1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(((ns6__ItemType*)a)->__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ItemType, 0, sizeof(ns6__ItemType), 0, soap_copy_ns6__ItemType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns6__ItemType * SOAP_FMAC6 soap_new_ns6__ItemType(struct soap *soap, int n)
{	return soap_instantiate_ns6__ItemType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__ItemType(struct soap *soap, ns6__ItemType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns6__ItemType * SOAP_FMAC4 soap_instantiate_ns6__ItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ItemType;
		if (size)
			*size = sizeof(ns6__ItemType);
		((ns6__ItemType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ItemType[n];
		if (size)
			*size = n * sizeof(ns6__ItemType);
		for (int i = 0; i < n; i++)
			((ns6__ItemType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ItemType %p -> %p\n", q, p));
	*(ns6__ItemType*)p = *(ns6__ItemType*)q;
}

void ns6__DocSumType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns6__DocSumType*)this)->Id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns6__DocSumType*)this)->Id);
	soap_serialize_std__vectorTemplateOfPointerTons6__ItemType(soap, &((ns6__DocSumType*)this)->Item);
	/* transient soap skipped */
}

void ns6__DocSumType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns6__DocSumType*)this)->Id);
	soap_default_std__vectorTemplateOfPointerTons6__ItemType(soap, &((ns6__DocSumType*)this)->Item);
	/* transient soap skipped */
}

int ns6__DocSumType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DocSumType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__DocSumType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DocSumType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocSumType(struct soap *soap, const char *tag, int id, const ns6__DocSumType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocSumType), type);
	soap_out_std__string(soap, "ns6:Id", -1, &(((ns6__DocSumType*)a)->Id), "");
	soap_out_std__vectorTemplateOfPointerTons6__ItemType(soap, "ns6:Item", -1, &(((ns6__DocSumType*)a)->Item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns6__DocSumType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DocSumType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DocSumType * SOAP_FMAC4 soap_get_ns6__DocSumType(struct soap *soap, ns6__DocSumType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocSumType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns6__DocSumType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DocSumType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DocSumType * SOAP_FMAC4 soap_in_ns6__DocSumType(struct soap *soap, const char *tag, ns6__DocSumType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DocSumType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocSumType, sizeof(ns6__DocSumType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DocSumType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DocSumType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns6:Id", &(((ns6__DocSumType*)a)->Id), "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__ItemType(soap, "ns6:Item", &(((ns6__DocSumType*)a)->Item), "ns6:ItemType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DocSumType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocSumType, 0, sizeof(ns6__DocSumType), 0, soap_copy_ns6__DocSumType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns6__DocSumType * SOAP_FMAC6 soap_new_ns6__DocSumType(struct soap *soap, int n)
{	return soap_instantiate_ns6__DocSumType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__DocSumType(struct soap *soap, ns6__DocSumType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns6__DocSumType * SOAP_FMAC4 soap_instantiate_ns6__DocSumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DocSumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DocSumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__DocSumType;
		if (size)
			*size = sizeof(ns6__DocSumType);
		((ns6__DocSumType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__DocSumType[n];
		if (size)
			*size = n * sizeof(ns6__DocSumType);
		for (int i = 0; i < n; i++)
			((ns6__DocSumType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DocSumType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DocSumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DocSumType %p -> %p\n", q, p));
	*(ns6__DocSumType*)p = *(ns6__DocSumType*)q;
}

void _ns5__eSearchResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__eSearchResultType(soap, &((_ns5__eSearchResultMS*)this)->eSearchResult);
	/* transient soap skipped */
}

void _ns5__eSearchResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns5__eSearchResultMS*)this)->eSearchResult = NULL;
	/* transient soap skipped */
}

int _ns5__eSearchResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__eSearchResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns5__eSearchResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__eSearchResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__eSearchResultMS(struct soap *soap, const char *tag, int id, const _ns5__eSearchResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__eSearchResultMS), type);
	if (a->eSearchResult)
		soap_element_result(soap, "ns5:eSearchResult");
	soap_out_PointerTons5__eSearchResultType(soap, "ns5:eSearchResult", -1, &(((_ns5__eSearchResultMS*)a)->eSearchResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns5__eSearchResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__eSearchResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__eSearchResultMS * SOAP_FMAC4 soap_get__ns5__eSearchResultMS(struct soap *soap, _ns5__eSearchResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__eSearchResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns5__eSearchResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__eSearchResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__eSearchResultMS * SOAP_FMAC4 soap_in__ns5__eSearchResultMS(struct soap *soap, const char *tag, _ns5__eSearchResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__eSearchResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__eSearchResultMS, sizeof(_ns5__eSearchResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__eSearchResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__eSearchResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eSearchResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eSearchResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__eSearchResultType(soap, "ns5:eSearchResult", &(((_ns5__eSearchResultMS*)a)->eSearchResult), "ns5:eSearchResultType"))
				{	soap_flag_eSearchResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns5:eSearchResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__eSearchResultMS, 0, sizeof(_ns5__eSearchResultMS), 0, soap_copy__ns5__eSearchResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns5__eSearchResultMS * SOAP_FMAC6 soap_new__ns5__eSearchResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns5__eSearchResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns5__eSearchResultMS(struct soap *soap, _ns5__eSearchResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns5__eSearchResultMS * SOAP_FMAC4 soap_instantiate__ns5__eSearchResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__eSearchResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__eSearchResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns5__eSearchResultMS;
		if (size)
			*size = sizeof(_ns5__eSearchResultMS);
		((_ns5__eSearchResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns5__eSearchResultMS[n];
		if (size)
			*size = n * sizeof(_ns5__eSearchResultMS);
		for (int i = 0; i < n; i++)
			((_ns5__eSearchResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns5__eSearchResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__eSearchResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__eSearchResultMS %p -> %p\n", q, p));
	*(_ns5__eSearchResultMS*)p = *(_ns5__eSearchResultMS*)q;
}

void _ns5__eSearchRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->query_USCOREkey);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->usehistory);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->email);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->field);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->reldate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->mindate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->maxdate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->datetype);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->retstart);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->retmax);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->rettype);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequestMS*)this)->sort);
	/* transient soap skipped */
}

void _ns5__eSearchRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns5__eSearchRequestMS*)this)->db = NULL;
	((_ns5__eSearchRequestMS*)this)->term = NULL;
	((_ns5__eSearchRequestMS*)this)->WebEnv = NULL;
	((_ns5__eSearchRequestMS*)this)->query_USCOREkey = NULL;
	((_ns5__eSearchRequestMS*)this)->usehistory = NULL;
	((_ns5__eSearchRequestMS*)this)->tool = NULL;
	((_ns5__eSearchRequestMS*)this)->email = NULL;
	((_ns5__eSearchRequestMS*)this)->field = NULL;
	((_ns5__eSearchRequestMS*)this)->reldate = NULL;
	((_ns5__eSearchRequestMS*)this)->mindate = NULL;
	((_ns5__eSearchRequestMS*)this)->maxdate = NULL;
	((_ns5__eSearchRequestMS*)this)->datetype = NULL;
	((_ns5__eSearchRequestMS*)this)->retstart = NULL;
	((_ns5__eSearchRequestMS*)this)->retmax = NULL;
	((_ns5__eSearchRequestMS*)this)->rettype = NULL;
	((_ns5__eSearchRequestMS*)this)->sort = NULL;
	/* transient soap skipped */
}

int _ns5__eSearchRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__eSearchRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns5__eSearchRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__eSearchRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__eSearchRequestMS(struct soap *soap, const char *tag, int id, const _ns5__eSearchRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__eSearchRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns5:db", -1, &(((_ns5__eSearchRequestMS*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns5:term", -1, &(((_ns5__eSearchRequestMS*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns5:WebEnv", -1, &(((_ns5__eSearchRequestMS*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns5:query_key", -1, &(((_ns5__eSearchRequestMS*)a)->query_USCOREkey), "");
	soap_out_PointerTostd__string(soap, "ns5:usehistory", -1, &(((_ns5__eSearchRequestMS*)a)->usehistory), "");
	soap_out_PointerTostd__string(soap, "ns5:tool", -1, &(((_ns5__eSearchRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns5:email", -1, &(((_ns5__eSearchRequestMS*)a)->email), "");
	soap_out_PointerTostd__string(soap, "ns5:field", -1, &(((_ns5__eSearchRequestMS*)a)->field), "");
	soap_out_PointerTostd__string(soap, "ns5:reldate", -1, &(((_ns5__eSearchRequestMS*)a)->reldate), "");
	soap_out_PointerTostd__string(soap, "ns5:mindate", -1, &(((_ns5__eSearchRequestMS*)a)->mindate), "");
	soap_out_PointerTostd__string(soap, "ns5:maxdate", -1, &(((_ns5__eSearchRequestMS*)a)->maxdate), "");
	soap_out_PointerTostd__string(soap, "ns5:datetype", -1, &(((_ns5__eSearchRequestMS*)a)->datetype), "");
	soap_out_PointerTostd__string(soap, "ns5:retstart", -1, &(((_ns5__eSearchRequestMS*)a)->retstart), "");
	soap_out_PointerTostd__string(soap, "ns5:retmax", -1, &(((_ns5__eSearchRequestMS*)a)->retmax), "");
	soap_out_PointerTostd__string(soap, "ns5:rettype", -1, &(((_ns5__eSearchRequestMS*)a)->rettype), "");
	soap_out_PointerTostd__string(soap, "ns5:sort", -1, &(((_ns5__eSearchRequestMS*)a)->sort), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns5__eSearchRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__eSearchRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__eSearchRequestMS * SOAP_FMAC4 soap_get__ns5__eSearchRequestMS(struct soap *soap, _ns5__eSearchRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__eSearchRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns5__eSearchRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__eSearchRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__eSearchRequestMS * SOAP_FMAC4 soap_in__ns5__eSearchRequestMS(struct soap *soap, const char *tag, _ns5__eSearchRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__eSearchRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__eSearchRequestMS, sizeof(_ns5__eSearchRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__eSearchRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__eSearchRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_term1 = 1, soap_flag_WebEnv1 = 1, soap_flag_query_USCOREkey1 = 1, soap_flag_usehistory1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1, soap_flag_field1 = 1, soap_flag_reldate1 = 1, soap_flag_mindate1 = 1, soap_flag_maxdate1 = 1, soap_flag_datetype1 = 1, soap_flag_retstart1 = 1, soap_flag_retmax1 = 1, soap_flag_rettype1 = 1, soap_flag_sort1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:db", &(((_ns5__eSearchRequestMS*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:term", &(((_ns5__eSearchRequestMS*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:WebEnv", &(((_ns5__eSearchRequestMS*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_query_USCOREkey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:query_key", &(((_ns5__eSearchRequestMS*)a)->query_USCOREkey), "xsd:string"))
				{	soap_flag_query_USCOREkey1--;
					continue;
				}
			if (soap_flag_usehistory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:usehistory", &(((_ns5__eSearchRequestMS*)a)->usehistory), "xsd:string"))
				{	soap_flag_usehistory1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:tool", &(((_ns5__eSearchRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:email", &(((_ns5__eSearchRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:field", &(((_ns5__eSearchRequestMS*)a)->field), "xsd:string"))
				{	soap_flag_field1--;
					continue;
				}
			if (soap_flag_reldate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:reldate", &(((_ns5__eSearchRequestMS*)a)->reldate), "xsd:string"))
				{	soap_flag_reldate1--;
					continue;
				}
			if (soap_flag_mindate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:mindate", &(((_ns5__eSearchRequestMS*)a)->mindate), "xsd:string"))
				{	soap_flag_mindate1--;
					continue;
				}
			if (soap_flag_maxdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:maxdate", &(((_ns5__eSearchRequestMS*)a)->maxdate), "xsd:string"))
				{	soap_flag_maxdate1--;
					continue;
				}
			if (soap_flag_datetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:datetype", &(((_ns5__eSearchRequestMS*)a)->datetype), "xsd:string"))
				{	soap_flag_datetype1--;
					continue;
				}
			if (soap_flag_retstart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:retstart", &(((_ns5__eSearchRequestMS*)a)->retstart), "xsd:string"))
				{	soap_flag_retstart1--;
					continue;
				}
			if (soap_flag_retmax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:retmax", &(((_ns5__eSearchRequestMS*)a)->retmax), "xsd:string"))
				{	soap_flag_retmax1--;
					continue;
				}
			if (soap_flag_rettype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:rettype", &(((_ns5__eSearchRequestMS*)a)->rettype), "xsd:string"))
				{	soap_flag_rettype1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:sort", &(((_ns5__eSearchRequestMS*)a)->sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__eSearchRequestMS, 0, sizeof(_ns5__eSearchRequestMS), 0, soap_copy__ns5__eSearchRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns5__eSearchRequestMS * SOAP_FMAC6 soap_new__ns5__eSearchRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns5__eSearchRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns5__eSearchRequestMS(struct soap *soap, _ns5__eSearchRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns5__eSearchRequestMS * SOAP_FMAC4 soap_instantiate__ns5__eSearchRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__eSearchRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__eSearchRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns5__eSearchRequestMS;
		if (size)
			*size = sizeof(_ns5__eSearchRequestMS);
		((_ns5__eSearchRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns5__eSearchRequestMS[n];
		if (size)
			*size = n * sizeof(_ns5__eSearchRequestMS);
		for (int i = 0; i < n; i++)
			((_ns5__eSearchRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns5__eSearchRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__eSearchRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__eSearchRequestMS %p -> %p\n", q, p));
	*(_ns5__eSearchRequestMS*)p = *(_ns5__eSearchRequestMS*)q;
}

void _ns5__eSearchRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->WebEnv);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->QueryKey);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->usehistory);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->email);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->field);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->reldate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->mindate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->maxdate);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->datetype);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->RetStart);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->RetMax);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->rettype);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchRequest*)this)->sort);
	/* transient soap skipped */
}

void _ns5__eSearchRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns5__eSearchRequest*)this)->db = NULL;
	((_ns5__eSearchRequest*)this)->term = NULL;
	((_ns5__eSearchRequest*)this)->WebEnv = NULL;
	((_ns5__eSearchRequest*)this)->QueryKey = NULL;
	((_ns5__eSearchRequest*)this)->usehistory = NULL;
	((_ns5__eSearchRequest*)this)->tool = NULL;
	((_ns5__eSearchRequest*)this)->email = NULL;
	((_ns5__eSearchRequest*)this)->field = NULL;
	((_ns5__eSearchRequest*)this)->reldate = NULL;
	((_ns5__eSearchRequest*)this)->mindate = NULL;
	((_ns5__eSearchRequest*)this)->maxdate = NULL;
	((_ns5__eSearchRequest*)this)->datetype = NULL;
	((_ns5__eSearchRequest*)this)->RetStart = NULL;
	((_ns5__eSearchRequest*)this)->RetMax = NULL;
	((_ns5__eSearchRequest*)this)->rettype = NULL;
	((_ns5__eSearchRequest*)this)->sort = NULL;
	/* transient soap skipped */
}

int _ns5__eSearchRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__eSearchRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns5__eSearchRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__eSearchRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__eSearchRequest(struct soap *soap, const char *tag, int id, const _ns5__eSearchRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__eSearchRequest), type);
	soap_out_PointerTostd__string(soap, "ns5:db", -1, &(((_ns5__eSearchRequest*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns5:term", -1, &(((_ns5__eSearchRequest*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns5:WebEnv", -1, &(((_ns5__eSearchRequest*)a)->WebEnv), "");
	soap_out_PointerTostd__string(soap, "ns5:QueryKey", -1, &(((_ns5__eSearchRequest*)a)->QueryKey), "");
	soap_out_PointerTostd__string(soap, "ns5:usehistory", -1, &(((_ns5__eSearchRequest*)a)->usehistory), "");
	soap_out_PointerTostd__string(soap, "ns5:tool", -1, &(((_ns5__eSearchRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns5:email", -1, &(((_ns5__eSearchRequest*)a)->email), "");
	soap_out_PointerTostd__string(soap, "ns5:field", -1, &(((_ns5__eSearchRequest*)a)->field), "");
	soap_out_PointerTostd__string(soap, "ns5:reldate", -1, &(((_ns5__eSearchRequest*)a)->reldate), "");
	soap_out_PointerTostd__string(soap, "ns5:mindate", -1, &(((_ns5__eSearchRequest*)a)->mindate), "");
	soap_out_PointerTostd__string(soap, "ns5:maxdate", -1, &(((_ns5__eSearchRequest*)a)->maxdate), "");
	soap_out_PointerTostd__string(soap, "ns5:datetype", -1, &(((_ns5__eSearchRequest*)a)->datetype), "");
	soap_out_PointerTostd__string(soap, "ns5:RetStart", -1, &(((_ns5__eSearchRequest*)a)->RetStart), "");
	soap_out_PointerTostd__string(soap, "ns5:RetMax", -1, &(((_ns5__eSearchRequest*)a)->RetMax), "");
	soap_out_PointerTostd__string(soap, "ns5:rettype", -1, &(((_ns5__eSearchRequest*)a)->rettype), "");
	soap_out_PointerTostd__string(soap, "ns5:sort", -1, &(((_ns5__eSearchRequest*)a)->sort), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns5__eSearchRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__eSearchRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__eSearchRequest * SOAP_FMAC4 soap_get__ns5__eSearchRequest(struct soap *soap, _ns5__eSearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__eSearchRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns5__eSearchRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__eSearchRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__eSearchRequest * SOAP_FMAC4 soap_in__ns5__eSearchRequest(struct soap *soap, const char *tag, _ns5__eSearchRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__eSearchRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__eSearchRequest, sizeof(_ns5__eSearchRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__eSearchRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__eSearchRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_term1 = 1, soap_flag_WebEnv1 = 1, soap_flag_QueryKey1 = 1, soap_flag_usehistory1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1, soap_flag_field1 = 1, soap_flag_reldate1 = 1, soap_flag_mindate1 = 1, soap_flag_maxdate1 = 1, soap_flag_datetype1 = 1, soap_flag_RetStart1 = 1, soap_flag_RetMax1 = 1, soap_flag_rettype1 = 1, soap_flag_sort1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:db", &(((_ns5__eSearchRequest*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:term", &(((_ns5__eSearchRequest*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:WebEnv", &(((_ns5__eSearchRequest*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_QueryKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:QueryKey", &(((_ns5__eSearchRequest*)a)->QueryKey), "xsd:string"))
				{	soap_flag_QueryKey1--;
					continue;
				}
			if (soap_flag_usehistory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:usehistory", &(((_ns5__eSearchRequest*)a)->usehistory), "xsd:string"))
				{	soap_flag_usehistory1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:tool", &(((_ns5__eSearchRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:email", &(((_ns5__eSearchRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:field", &(((_ns5__eSearchRequest*)a)->field), "xsd:string"))
				{	soap_flag_field1--;
					continue;
				}
			if (soap_flag_reldate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:reldate", &(((_ns5__eSearchRequest*)a)->reldate), "xsd:string"))
				{	soap_flag_reldate1--;
					continue;
				}
			if (soap_flag_mindate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:mindate", &(((_ns5__eSearchRequest*)a)->mindate), "xsd:string"))
				{	soap_flag_mindate1--;
					continue;
				}
			if (soap_flag_maxdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:maxdate", &(((_ns5__eSearchRequest*)a)->maxdate), "xsd:string"))
				{	soap_flag_maxdate1--;
					continue;
				}
			if (soap_flag_datetype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:datetype", &(((_ns5__eSearchRequest*)a)->datetype), "xsd:string"))
				{	soap_flag_datetype1--;
					continue;
				}
			if (soap_flag_RetStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetStart", &(((_ns5__eSearchRequest*)a)->RetStart), "xsd:string"))
				{	soap_flag_RetStart1--;
					continue;
				}
			if (soap_flag_RetMax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetMax", &(((_ns5__eSearchRequest*)a)->RetMax), "xsd:string"))
				{	soap_flag_RetMax1--;
					continue;
				}
			if (soap_flag_rettype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:rettype", &(((_ns5__eSearchRequest*)a)->rettype), "xsd:string"))
				{	soap_flag_rettype1--;
					continue;
				}
			if (soap_flag_sort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:sort", &(((_ns5__eSearchRequest*)a)->sort), "xsd:string"))
				{	soap_flag_sort1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__eSearchRequest, 0, sizeof(_ns5__eSearchRequest), 0, soap_copy__ns5__eSearchRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns5__eSearchRequest * SOAP_FMAC6 soap_new__ns5__eSearchRequest(struct soap *soap, int n)
{	return soap_instantiate__ns5__eSearchRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns5__eSearchRequest(struct soap *soap, _ns5__eSearchRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns5__eSearchRequest * SOAP_FMAC4 soap_instantiate__ns5__eSearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__eSearchRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__eSearchRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns5__eSearchRequest;
		if (size)
			*size = sizeof(_ns5__eSearchRequest);
		((_ns5__eSearchRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns5__eSearchRequest[n];
		if (size)
			*size = n * sizeof(_ns5__eSearchRequest);
		for (int i = 0; i < n; i++)
			((_ns5__eSearchRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns5__eSearchRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__eSearchRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__eSearchRequest %p -> %p\n", q, p));
	*(_ns5__eSearchRequest*)p = *(_ns5__eSearchRequest*)q;
}

void _ns5__eSearchResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ErrorListType(soap, &((_ns5__eSearchResult*)this)->ErrorList);
	soap_serialize_PointerTons5__WarningListType(soap, &((_ns5__eSearchResult*)this)->WarningList);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->ERROR_);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->Count);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->RetMax);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->RetStart);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->QueryKey);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->WebEnv);
	soap_serialize_PointerTons5__IdListType(soap, &((_ns5__eSearchResult*)this)->IdList);
	soap_serialize_PointerTons5__TranslationSetType(soap, &((_ns5__eSearchResult*)this)->TranslationSet);
	soap_serialize_PointerTons5__TranslationStackType(soap, &((_ns5__eSearchResult*)this)->TranslationStack);
	soap_serialize_PointerTostd__string(soap, &((_ns5__eSearchResult*)this)->QueryTranslation);
	/* transient soap skipped */
}

void _ns5__eSearchResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns5__eSearchResult*)this)->ErrorList = NULL;
	((_ns5__eSearchResult*)this)->WarningList = NULL;
	((_ns5__eSearchResult*)this)->ERROR_ = NULL;
	((_ns5__eSearchResult*)this)->Count = NULL;
	((_ns5__eSearchResult*)this)->RetMax = NULL;
	((_ns5__eSearchResult*)this)->RetStart = NULL;
	((_ns5__eSearchResult*)this)->QueryKey = NULL;
	((_ns5__eSearchResult*)this)->WebEnv = NULL;
	((_ns5__eSearchResult*)this)->IdList = NULL;
	((_ns5__eSearchResult*)this)->TranslationSet = NULL;
	((_ns5__eSearchResult*)this)->TranslationStack = NULL;
	((_ns5__eSearchResult*)this)->QueryTranslation = NULL;
	/* transient soap skipped */
}

int _ns5__eSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__eSearchResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns5__eSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__eSearchResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__eSearchResult(struct soap *soap, const char *tag, int id, const _ns5__eSearchResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__eSearchResult), type);
	if (a->ErrorList)
		soap_element_result(soap, "ns5:ErrorList");
	soap_out_PointerTons5__ErrorListType(soap, "ns5:ErrorList", -1, &(((_ns5__eSearchResult*)a)->ErrorList), "");
	soap_out_PointerTons5__WarningListType(soap, "ns5:WarningList", -1, &(((_ns5__eSearchResult*)a)->WarningList), "");
	soap_out_PointerTostd__string(soap, "ns5:ERROR_", -1, &(((_ns5__eSearchResult*)a)->ERROR_), "");
	soap_out_PointerTostd__string(soap, "ns5:Count", -1, &(((_ns5__eSearchResult*)a)->Count), "");
	soap_out_PointerTostd__string(soap, "ns5:RetMax", -1, &(((_ns5__eSearchResult*)a)->RetMax), "");
	soap_out_PointerTostd__string(soap, "ns5:RetStart", -1, &(((_ns5__eSearchResult*)a)->RetStart), "");
	soap_out_PointerTostd__string(soap, "ns5:QueryKey", -1, &(((_ns5__eSearchResult*)a)->QueryKey), "");
	soap_out_PointerTostd__string(soap, "ns5:WebEnv", -1, &(((_ns5__eSearchResult*)a)->WebEnv), "");
	soap_out_PointerTons5__IdListType(soap, "ns5:IdList", -1, &(((_ns5__eSearchResult*)a)->IdList), "");
	soap_out_PointerTons5__TranslationSetType(soap, "ns5:TranslationSet", -1, &(((_ns5__eSearchResult*)a)->TranslationSet), "");
	soap_out_PointerTons5__TranslationStackType(soap, "ns5:TranslationStack", -1, &(((_ns5__eSearchResult*)a)->TranslationStack), "");
	soap_out_PointerTostd__string(soap, "ns5:QueryTranslation", -1, &(((_ns5__eSearchResult*)a)->QueryTranslation), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns5__eSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__eSearchResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__eSearchResult * SOAP_FMAC4 soap_get__ns5__eSearchResult(struct soap *soap, _ns5__eSearchResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__eSearchResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns5__eSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__eSearchResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__eSearchResult * SOAP_FMAC4 soap_in__ns5__eSearchResult(struct soap *soap, const char *tag, _ns5__eSearchResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__eSearchResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__eSearchResult, sizeof(_ns5__eSearchResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__eSearchResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__eSearchResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ErrorList1 = 1, soap_flag_WarningList1 = 1, soap_flag_ERROR_1 = 1, soap_flag_Count1 = 1, soap_flag_RetMax1 = 1, soap_flag_RetStart1 = 1, soap_flag_QueryKey1 = 1, soap_flag_WebEnv1 = 1, soap_flag_IdList1 = 1, soap_flag_TranslationSet1 = 1, soap_flag_TranslationStack1 = 1, soap_flag_QueryTranslation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ErrorListType(soap, "ns5:ErrorList", &(((_ns5__eSearchResult*)a)->ErrorList), "ns5:ErrorListType"))
				{	soap_flag_ErrorList1--;
					continue;
				}
			if (soap_flag_WarningList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__WarningListType(soap, "ns5:WarningList", &(((_ns5__eSearchResult*)a)->WarningList), "ns5:WarningListType"))
				{	soap_flag_WarningList1--;
					continue;
				}
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ERROR_", &(((_ns5__eSearchResult*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Count", &(((_ns5__eSearchResult*)a)->Count), "xsd:string"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_RetMax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetMax", &(((_ns5__eSearchResult*)a)->RetMax), "xsd:string"))
				{	soap_flag_RetMax1--;
					continue;
				}
			if (soap_flag_RetStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetStart", &(((_ns5__eSearchResult*)a)->RetStart), "xsd:string"))
				{	soap_flag_RetStart1--;
					continue;
				}
			if (soap_flag_QueryKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:QueryKey", &(((_ns5__eSearchResult*)a)->QueryKey), "xsd:string"))
				{	soap_flag_QueryKey1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:WebEnv", &(((_ns5__eSearchResult*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_IdList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__IdListType(soap, "ns5:IdList", &(((_ns5__eSearchResult*)a)->IdList), "ns5:IdListType"))
				{	soap_flag_IdList1--;
					continue;
				}
			if (soap_flag_TranslationSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TranslationSetType(soap, "ns5:TranslationSet", &(((_ns5__eSearchResult*)a)->TranslationSet), "ns5:TranslationSetType"))
				{	soap_flag_TranslationSet1--;
					continue;
				}
			if (soap_flag_TranslationStack1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TranslationStackType(soap, "ns5:TranslationStack", &(((_ns5__eSearchResult*)a)->TranslationStack), "ns5:TranslationStackType"))
				{	soap_flag_TranslationStack1--;
					continue;
				}
			if (soap_flag_QueryTranslation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:QueryTranslation", &(((_ns5__eSearchResult*)a)->QueryTranslation), "xsd:string"))
				{	soap_flag_QueryTranslation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns5:ErrorList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__eSearchResult, 0, sizeof(_ns5__eSearchResult), 0, soap_copy__ns5__eSearchResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns5__eSearchResult * SOAP_FMAC6 soap_new__ns5__eSearchResult(struct soap *soap, int n)
{	return soap_instantiate__ns5__eSearchResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns5__eSearchResult(struct soap *soap, _ns5__eSearchResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns5__eSearchResult * SOAP_FMAC4 soap_instantiate__ns5__eSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__eSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__eSearchResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns5__eSearchResult;
		if (size)
			*size = sizeof(_ns5__eSearchResult);
		((_ns5__eSearchResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns5__eSearchResult[n];
		if (size)
			*size = n * sizeof(_ns5__eSearchResult);
		for (int i = 0; i < n; i++)
			((_ns5__eSearchResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns5__eSearchResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__eSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__eSearchResult %p -> %p\n", q, p));
	*(_ns5__eSearchResult*)p = *(_ns5__eSearchResult*)q;
}

void ns5__eSearchResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ErrorListType(soap, &((ns5__eSearchResultType*)this)->ErrorList);
	soap_serialize_PointerTons5__WarningListType(soap, &((ns5__eSearchResultType*)this)->WarningList);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->ERROR_);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->Count);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->RetMax);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->RetStart);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->QueryKey);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->WebEnv);
	soap_serialize_PointerTons5__IdListType(soap, &((ns5__eSearchResultType*)this)->IdList);
	soap_serialize_PointerTons5__TranslationSetType(soap, &((ns5__eSearchResultType*)this)->TranslationSet);
	soap_serialize_PointerTons5__TranslationStackType(soap, &((ns5__eSearchResultType*)this)->TranslationStack);
	soap_serialize_PointerTostd__string(soap, &((ns5__eSearchResultType*)this)->QueryTranslation);
	/* transient soap skipped */
}

void ns5__eSearchResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns5__eSearchResultType*)this)->ErrorList = NULL;
	((ns5__eSearchResultType*)this)->WarningList = NULL;
	((ns5__eSearchResultType*)this)->ERROR_ = NULL;
	((ns5__eSearchResultType*)this)->Count = NULL;
	((ns5__eSearchResultType*)this)->RetMax = NULL;
	((ns5__eSearchResultType*)this)->RetStart = NULL;
	((ns5__eSearchResultType*)this)->QueryKey = NULL;
	((ns5__eSearchResultType*)this)->WebEnv = NULL;
	((ns5__eSearchResultType*)this)->IdList = NULL;
	((ns5__eSearchResultType*)this)->TranslationSet = NULL;
	((ns5__eSearchResultType*)this)->TranslationStack = NULL;
	((ns5__eSearchResultType*)this)->QueryTranslation = NULL;
	/* transient soap skipped */
}

int ns5__eSearchResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__eSearchResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__eSearchResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__eSearchResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__eSearchResultType(struct soap *soap, const char *tag, int id, const ns5__eSearchResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__eSearchResultType), type);
	soap_out_PointerTons5__ErrorListType(soap, "ns5:ErrorList", -1, &(((ns5__eSearchResultType*)a)->ErrorList), "");
	soap_out_PointerTons5__WarningListType(soap, "ns5:WarningList", -1, &(((ns5__eSearchResultType*)a)->WarningList), "");
	soap_out_PointerTostd__string(soap, "ns5:ERROR_", -1, &(((ns5__eSearchResultType*)a)->ERROR_), "");
	soap_out_PointerTostd__string(soap, "ns5:Count", -1, &(((ns5__eSearchResultType*)a)->Count), "");
	soap_out_PointerTostd__string(soap, "ns5:RetMax", -1, &(((ns5__eSearchResultType*)a)->RetMax), "");
	soap_out_PointerTostd__string(soap, "ns5:RetStart", -1, &(((ns5__eSearchResultType*)a)->RetStart), "");
	soap_out_PointerTostd__string(soap, "ns5:QueryKey", -1, &(((ns5__eSearchResultType*)a)->QueryKey), "");
	soap_out_PointerTostd__string(soap, "ns5:WebEnv", -1, &(((ns5__eSearchResultType*)a)->WebEnv), "");
	soap_out_PointerTons5__IdListType(soap, "ns5:IdList", -1, &(((ns5__eSearchResultType*)a)->IdList), "");
	soap_out_PointerTons5__TranslationSetType(soap, "ns5:TranslationSet", -1, &(((ns5__eSearchResultType*)a)->TranslationSet), "");
	soap_out_PointerTons5__TranslationStackType(soap, "ns5:TranslationStack", -1, &(((ns5__eSearchResultType*)a)->TranslationStack), "");
	soap_out_PointerTostd__string(soap, "ns5:QueryTranslation", -1, &(((ns5__eSearchResultType*)a)->QueryTranslation), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__eSearchResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__eSearchResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__eSearchResultType * SOAP_FMAC4 soap_get_ns5__eSearchResultType(struct soap *soap, ns5__eSearchResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__eSearchResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__eSearchResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__eSearchResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__eSearchResultType * SOAP_FMAC4 soap_in_ns5__eSearchResultType(struct soap *soap, const char *tag, ns5__eSearchResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__eSearchResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__eSearchResultType, sizeof(ns5__eSearchResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__eSearchResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__eSearchResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ErrorList1 = 1, soap_flag_WarningList1 = 1, soap_flag_ERROR_1 = 1, soap_flag_Count1 = 1, soap_flag_RetMax1 = 1, soap_flag_RetStart1 = 1, soap_flag_QueryKey1 = 1, soap_flag_WebEnv1 = 1, soap_flag_IdList1 = 1, soap_flag_TranslationSet1 = 1, soap_flag_TranslationStack1 = 1, soap_flag_QueryTranslation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ErrorListType(soap, "ns5:ErrorList", &(((ns5__eSearchResultType*)a)->ErrorList), "ns5:ErrorListType"))
				{	soap_flag_ErrorList1--;
					continue;
				}
			if (soap_flag_WarningList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__WarningListType(soap, "ns5:WarningList", &(((ns5__eSearchResultType*)a)->WarningList), "ns5:WarningListType"))
				{	soap_flag_WarningList1--;
					continue;
				}
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ERROR_", &(((ns5__eSearchResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Count", &(((ns5__eSearchResultType*)a)->Count), "xsd:string"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_RetMax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetMax", &(((ns5__eSearchResultType*)a)->RetMax), "xsd:string"))
				{	soap_flag_RetMax1--;
					continue;
				}
			if (soap_flag_RetStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetStart", &(((ns5__eSearchResultType*)a)->RetStart), "xsd:string"))
				{	soap_flag_RetStart1--;
					continue;
				}
			if (soap_flag_QueryKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:QueryKey", &(((ns5__eSearchResultType*)a)->QueryKey), "xsd:string"))
				{	soap_flag_QueryKey1--;
					continue;
				}
			if (soap_flag_WebEnv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:WebEnv", &(((ns5__eSearchResultType*)a)->WebEnv), "xsd:string"))
				{	soap_flag_WebEnv1--;
					continue;
				}
			if (soap_flag_IdList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__IdListType(soap, "ns5:IdList", &(((ns5__eSearchResultType*)a)->IdList), "ns5:IdListType"))
				{	soap_flag_IdList1--;
					continue;
				}
			if (soap_flag_TranslationSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TranslationSetType(soap, "ns5:TranslationSet", &(((ns5__eSearchResultType*)a)->TranslationSet), "ns5:TranslationSetType"))
				{	soap_flag_TranslationSet1--;
					continue;
				}
			if (soap_flag_TranslationStack1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__TranslationStackType(soap, "ns5:TranslationStack", &(((ns5__eSearchResultType*)a)->TranslationStack), "ns5:TranslationStackType"))
				{	soap_flag_TranslationStack1--;
					continue;
				}
			if (soap_flag_QueryTranslation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:QueryTranslation", &(((ns5__eSearchResultType*)a)->QueryTranslation), "xsd:string"))
				{	soap_flag_QueryTranslation1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__eSearchResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__eSearchResultType, 0, sizeof(ns5__eSearchResultType), 0, soap_copy_ns5__eSearchResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__eSearchResultType * SOAP_FMAC6 soap_new_ns5__eSearchResultType(struct soap *soap, int n)
{	return soap_instantiate_ns5__eSearchResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__eSearchResultType(struct soap *soap, ns5__eSearchResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__eSearchResultType * SOAP_FMAC4 soap_instantiate_ns5__eSearchResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__eSearchResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__eSearchResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__eSearchResultType;
		if (size)
			*size = sizeof(ns5__eSearchResultType);
		((ns5__eSearchResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__eSearchResultType[n];
		if (size)
			*size = n * sizeof(ns5__eSearchResultType);
		for (int i = 0; i < n; i++)
			((ns5__eSearchResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__eSearchResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__eSearchResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__eSearchResultType %p -> %p\n", q, p));
	*(ns5__eSearchResultType*)p = *(ns5__eSearchResultType*)q;
}

void ns5__WarningListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->PhraseIgnored);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->QuotedPhraseNotFound);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->OutputMessage);
	/* transient soap skipped */
}

void ns5__WarningListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->PhraseIgnored);
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->QuotedPhraseNotFound);
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__WarningListType*)this)->OutputMessage);
	/* transient soap skipped */
}

int ns5__WarningListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__WarningListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__WarningListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__WarningListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__WarningListType(struct soap *soap, const char *tag, int id, const ns5__WarningListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__WarningListType), type);
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:PhraseIgnored", -1, &(((ns5__WarningListType*)a)->PhraseIgnored), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:QuotedPhraseNotFound", -1, &(((ns5__WarningListType*)a)->QuotedPhraseNotFound), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:OutputMessage", -1, &(((ns5__WarningListType*)a)->OutputMessage), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__WarningListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__WarningListType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__WarningListType * SOAP_FMAC4 soap_get_ns5__WarningListType(struct soap *soap, ns5__WarningListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__WarningListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__WarningListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__WarningListType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__WarningListType * SOAP_FMAC4 soap_in_ns5__WarningListType(struct soap *soap, const char *tag, ns5__WarningListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__WarningListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__WarningListType, sizeof(ns5__WarningListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__WarningListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__WarningListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:PhraseIgnored", &(((ns5__WarningListType*)a)->PhraseIgnored), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:QuotedPhraseNotFound", &(((ns5__WarningListType*)a)->QuotedPhraseNotFound), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:OutputMessage", &(((ns5__WarningListType*)a)->OutputMessage), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__WarningListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__WarningListType, 0, sizeof(ns5__WarningListType), 0, soap_copy_ns5__WarningListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__WarningListType * SOAP_FMAC6 soap_new_ns5__WarningListType(struct soap *soap, int n)
{	return soap_instantiate_ns5__WarningListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__WarningListType(struct soap *soap, ns5__WarningListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__WarningListType * SOAP_FMAC4 soap_instantiate_ns5__WarningListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__WarningListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__WarningListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__WarningListType;
		if (size)
			*size = sizeof(ns5__WarningListType);
		((ns5__WarningListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__WarningListType[n];
		if (size)
			*size = n * sizeof(ns5__WarningListType);
		for (int i = 0; i < n; i++)
			((ns5__WarningListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__WarningListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__WarningListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__WarningListType %p -> %p\n", q, p));
	*(ns5__WarningListType*)p = *(ns5__WarningListType*)q;
}

void ns5__TranslationStackType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (((ns5__TranslationStackType*)this)->__union_TranslationStackType)
	{	int i;
		for (i = 0; i < ((ns5__TranslationStackType*)this)->__size_TranslationStackType; i++)
		{
			soap_serialize___ns5__union_TranslationStackType(soap, ((ns5__TranslationStackType*)this)->__union_TranslationStackType + i);
		}
	}
	/* transient soap skipped */
}

void ns5__TranslationStackType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns5__TranslationStackType*)this)->__size_TranslationStackType = 0;
	((ns5__TranslationStackType*)this)->__union_TranslationStackType = NULL;
	/* transient soap skipped */
}

int ns5__TranslationStackType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__TranslationStackType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__TranslationStackType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TranslationStackType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TranslationStackType(struct soap *soap, const char *tag, int id, const ns5__TranslationStackType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TranslationStackType), type);
	if (((ns5__TranslationStackType*)a)->__union_TranslationStackType)
	{	int i;
		for (i = 0; i < ((ns5__TranslationStackType*)a)->__size_TranslationStackType; i++)
			soap_out___ns5__union_TranslationStackType(soap, "-union-TranslationStackType", -1, ((ns5__TranslationStackType*)a)->__union_TranslationStackType + i, "");
	}
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__TranslationStackType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TranslationStackType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TranslationStackType * SOAP_FMAC4 soap_get_ns5__TranslationStackType(struct soap *soap, ns5__TranslationStackType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TranslationStackType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__TranslationStackType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TranslationStackType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TranslationStackType * SOAP_FMAC4 soap_in_ns5__TranslationStackType(struct soap *soap, const char *tag, ns5__TranslationStackType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TranslationStackType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TranslationStackType, sizeof(ns5__TranslationStackType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__TranslationStackType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TranslationStackType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___union_TranslationStackType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___union_TranslationStackType1 && soap->error == SOAP_TAG_MISMATCH)
			{	struct __ns5__union_TranslationStackType *p;
				soap_new_block(soap);
				for (((ns5__TranslationStackType*)a)->__size_TranslationStackType = 0; !soap_element_begin_in(soap, "-union-TranslationStackType", 1, NULL); ((ns5__TranslationStackType*)a)->__size_TranslationStackType++)
				{	p = (struct __ns5__union_TranslationStackType *)soap_push_block(soap, sizeof(struct __ns5__union_TranslationStackType));
					if (!p)
						return NULL;
					soap_default___ns5__union_TranslationStackType(soap, p);
					if (!soap_in___ns5__union_TranslationStackType(soap, "-union-TranslationStackType", p, "-ns5:union-TranslationStackType"))
						break;
					soap_flag___union_TranslationStackType1 = 0;
				}
				((ns5__TranslationStackType*)a)->__union_TranslationStackType = (struct __ns5__union_TranslationStackType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___union_TranslationStackType1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TranslationStackType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TranslationStackType, 0, sizeof(ns5__TranslationStackType), 0, soap_copy_ns5__TranslationStackType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__TranslationStackType * SOAP_FMAC6 soap_new_ns5__TranslationStackType(struct soap *soap, int n)
{	return soap_instantiate_ns5__TranslationStackType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__TranslationStackType(struct soap *soap, ns5__TranslationStackType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__TranslationStackType * SOAP_FMAC4 soap_instantiate_ns5__TranslationStackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TranslationStackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__TranslationStackType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__TranslationStackType;
		if (size)
			*size = sizeof(ns5__TranslationStackType);
		((ns5__TranslationStackType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__TranslationStackType[n];
		if (size)
			*size = n * sizeof(ns5__TranslationStackType);
		for (int i = 0; i < n; i++)
			((ns5__TranslationStackType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__TranslationStackType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TranslationStackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TranslationStackType %p -> %p\n", q, p));
	*(ns5__TranslationStackType*)p = *(ns5__TranslationStackType*)q;
}

void ns5__TranslationSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__TranslationType(soap, &((ns5__TranslationSetType*)this)->Translation);
	/* transient soap skipped */
}

void ns5__TranslationSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__TranslationType(soap, &((ns5__TranslationSetType*)this)->Translation);
	/* transient soap skipped */
}

int ns5__TranslationSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__TranslationSetType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__TranslationSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TranslationSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TranslationSetType(struct soap *soap, const char *tag, int id, const ns5__TranslationSetType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TranslationSetType), type);
	soap_out_std__vectorTemplateOfPointerTons5__TranslationType(soap, "ns5:Translation", -1, &(((ns5__TranslationSetType*)a)->Translation), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__TranslationSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TranslationSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TranslationSetType * SOAP_FMAC4 soap_get_ns5__TranslationSetType(struct soap *soap, ns5__TranslationSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TranslationSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__TranslationSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TranslationSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TranslationSetType * SOAP_FMAC4 soap_in_ns5__TranslationSetType(struct soap *soap, const char *tag, ns5__TranslationSetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TranslationSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TranslationSetType, sizeof(ns5__TranslationSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__TranslationSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TranslationSetType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__TranslationType(soap, "ns5:Translation", &(((ns5__TranslationSetType*)a)->Translation), "ns5:TranslationType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TranslationSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TranslationSetType, 0, sizeof(ns5__TranslationSetType), 0, soap_copy_ns5__TranslationSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__TranslationSetType * SOAP_FMAC6 soap_new_ns5__TranslationSetType(struct soap *soap, int n)
{	return soap_instantiate_ns5__TranslationSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__TranslationSetType(struct soap *soap, ns5__TranslationSetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__TranslationSetType * SOAP_FMAC4 soap_instantiate_ns5__TranslationSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TranslationSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__TranslationSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__TranslationSetType;
		if (size)
			*size = sizeof(ns5__TranslationSetType);
		((ns5__TranslationSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__TranslationSetType[n];
		if (size)
			*size = n * sizeof(ns5__TranslationSetType);
		for (int i = 0; i < n; i++)
			((ns5__TranslationSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__TranslationSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TranslationSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TranslationSetType %p -> %p\n", q, p));
	*(ns5__TranslationSetType*)p = *(ns5__TranslationSetType*)q;
}

void ns5__TranslationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns5__TranslationType*)this)->From, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TranslationType*)this)->From);
	soap_embedded(soap, &((ns5__TranslationType*)this)->To, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TranslationType*)this)->To);
	/* transient soap skipped */
}

void ns5__TranslationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns5__TranslationType*)this)->From);
	soap_default_std__string(soap, &((ns5__TranslationType*)this)->To);
	/* transient soap skipped */
}

int ns5__TranslationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__TranslationType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__TranslationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TranslationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TranslationType(struct soap *soap, const char *tag, int id, const ns5__TranslationType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TranslationType), type);
	soap_out_std__string(soap, "ns5:From", -1, &(((ns5__TranslationType*)a)->From), "");
	soap_out_std__string(soap, "ns5:To", -1, &(((ns5__TranslationType*)a)->To), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__TranslationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TranslationType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TranslationType * SOAP_FMAC4 soap_get_ns5__TranslationType(struct soap *soap, ns5__TranslationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TranslationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__TranslationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TranslationType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TranslationType * SOAP_FMAC4 soap_in_ns5__TranslationType(struct soap *soap, const char *tag, ns5__TranslationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TranslationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TranslationType, sizeof(ns5__TranslationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__TranslationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TranslationType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_From1 = 1, soap_flag_To1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:From", &(((ns5__TranslationType*)a)->From), "xsd:string"))
				{	soap_flag_From1--;
					continue;
				}
			if (soap_flag_To1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:To", &(((ns5__TranslationType*)a)->To), "xsd:string"))
				{	soap_flag_To1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From1 > 0 || soap_flag_To1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TranslationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TranslationType, 0, sizeof(ns5__TranslationType), 0, soap_copy_ns5__TranslationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__TranslationType * SOAP_FMAC6 soap_new_ns5__TranslationType(struct soap *soap, int n)
{	return soap_instantiate_ns5__TranslationType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__TranslationType(struct soap *soap, ns5__TranslationType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__TranslationType * SOAP_FMAC4 soap_instantiate_ns5__TranslationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TranslationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__TranslationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__TranslationType;
		if (size)
			*size = sizeof(ns5__TranslationType);
		((ns5__TranslationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__TranslationType[n];
		if (size)
			*size = n * sizeof(ns5__TranslationType);
		for (int i = 0; i < n; i++)
			((ns5__TranslationType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__TranslationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TranslationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TranslationType %p -> %p\n", q, p));
	*(ns5__TranslationType*)p = *(ns5__TranslationType*)q;
}

void ns5__TermSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns5__TermSetType*)this)->Term, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TermSetType*)this)->Term);
	soap_embedded(soap, &((ns5__TermSetType*)this)->Field, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TermSetType*)this)->Field);
	soap_embedded(soap, &((ns5__TermSetType*)this)->Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TermSetType*)this)->Count);
	soap_embedded(soap, &((ns5__TermSetType*)this)->Explode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns5__TermSetType*)this)->Explode);
	/* transient soap skipped */
}

void ns5__TermSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns5__TermSetType*)this)->Term);
	soap_default_std__string(soap, &((ns5__TermSetType*)this)->Field);
	soap_default_std__string(soap, &((ns5__TermSetType*)this)->Count);
	soap_default_std__string(soap, &((ns5__TermSetType*)this)->Explode);
	/* transient soap skipped */
}

int ns5__TermSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__TermSetType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__TermSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TermSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TermSetType(struct soap *soap, const char *tag, int id, const ns5__TermSetType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TermSetType), type);
	soap_out_std__string(soap, "ns5:Term", -1, &(((ns5__TermSetType*)a)->Term), "");
	soap_out_std__string(soap, "ns5:Field", -1, &(((ns5__TermSetType*)a)->Field), "");
	soap_out_std__string(soap, "ns5:Count", -1, &(((ns5__TermSetType*)a)->Count), "");
	soap_out_std__string(soap, "ns5:Explode", -1, &(((ns5__TermSetType*)a)->Explode), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__TermSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TermSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TermSetType * SOAP_FMAC4 soap_get_ns5__TermSetType(struct soap *soap, ns5__TermSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TermSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__TermSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TermSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TermSetType * SOAP_FMAC4 soap_in_ns5__TermSetType(struct soap *soap, const char *tag, ns5__TermSetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TermSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TermSetType, sizeof(ns5__TermSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__TermSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__TermSetType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Term1 = 1, soap_flag_Field1 = 1, soap_flag_Count1 = 1, soap_flag_Explode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:Term", &(((ns5__TermSetType*)a)->Term), "xsd:string"))
				{	soap_flag_Term1--;
					continue;
				}
			if (soap_flag_Field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:Field", &(((ns5__TermSetType*)a)->Field), "xsd:string"))
				{	soap_flag_Field1--;
					continue;
				}
			if (soap_flag_Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:Count", &(((ns5__TermSetType*)a)->Count), "xsd:string"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_Explode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns5:Explode", &(((ns5__TermSetType*)a)->Explode), "xsd:string"))
				{	soap_flag_Explode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Term1 > 0 || soap_flag_Field1 > 0 || soap_flag_Count1 > 0 || soap_flag_Explode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TermSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TermSetType, 0, sizeof(ns5__TermSetType), 0, soap_copy_ns5__TermSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__TermSetType * SOAP_FMAC6 soap_new_ns5__TermSetType(struct soap *soap, int n)
{	return soap_instantiate_ns5__TermSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__TermSetType(struct soap *soap, ns5__TermSetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__TermSetType * SOAP_FMAC4 soap_instantiate_ns5__TermSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__TermSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__TermSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__TermSetType;
		if (size)
			*size = sizeof(ns5__TermSetType);
		((ns5__TermSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__TermSetType[n];
		if (size)
			*size = n * sizeof(ns5__TermSetType);
		for (int i = 0; i < n; i++)
			((ns5__TermSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__TermSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__TermSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__TermSetType %p -> %p\n", q, p));
	*(ns5__TermSetType*)p = *(ns5__TermSetType*)q;
}

void ns5__IdListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__IdListType*)this)->Id);
	/* transient soap skipped */
}

void ns5__IdListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__IdListType*)this)->Id);
	/* transient soap skipped */
}

int ns5__IdListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__IdListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__IdListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__IdListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__IdListType(struct soap *soap, const char *tag, int id, const ns5__IdListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__IdListType), type);
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:Id", -1, &(((ns5__IdListType*)a)->Id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__IdListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__IdListType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__IdListType * SOAP_FMAC4 soap_get_ns5__IdListType(struct soap *soap, ns5__IdListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__IdListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__IdListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__IdListType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__IdListType * SOAP_FMAC4 soap_in_ns5__IdListType(struct soap *soap, const char *tag, ns5__IdListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__IdListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__IdListType, sizeof(ns5__IdListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__IdListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__IdListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:Id", &(((ns5__IdListType*)a)->Id), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__IdListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__IdListType, 0, sizeof(ns5__IdListType), 0, soap_copy_ns5__IdListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__IdListType * SOAP_FMAC6 soap_new_ns5__IdListType(struct soap *soap, int n)
{	return soap_instantiate_ns5__IdListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__IdListType(struct soap *soap, ns5__IdListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__IdListType * SOAP_FMAC4 soap_instantiate_ns5__IdListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__IdListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__IdListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__IdListType;
		if (size)
			*size = sizeof(ns5__IdListType);
		((ns5__IdListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__IdListType[n];
		if (size)
			*size = n * sizeof(ns5__IdListType);
		for (int i = 0; i < n; i++)
			((ns5__IdListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__IdListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__IdListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__IdListType %p -> %p\n", q, p));
	*(ns5__IdListType*)p = *(ns5__IdListType*)q;
}

void ns5__ErrorListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__ErrorListType*)this)->PhraseNotFound);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns5__ErrorListType*)this)->FieldNotFound);
	/* transient soap skipped */
}

void ns5__ErrorListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__ErrorListType*)this)->PhraseNotFound);
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns5__ErrorListType*)this)->FieldNotFound);
	/* transient soap skipped */
}

int ns5__ErrorListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ErrorListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__ErrorListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ErrorListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ErrorListType(struct soap *soap, const char *tag, int id, const ns5__ErrorListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ErrorListType), type);
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:PhraseNotFound", -1, &(((ns5__ErrorListType*)a)->PhraseNotFound), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns5:FieldNotFound", -1, &(((ns5__ErrorListType*)a)->FieldNotFound), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__ErrorListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ErrorListType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ErrorListType * SOAP_FMAC4 soap_get_ns5__ErrorListType(struct soap *soap, ns5__ErrorListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ErrorListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__ErrorListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ErrorListType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ErrorListType * SOAP_FMAC4 soap_in_ns5__ErrorListType(struct soap *soap, const char *tag, ns5__ErrorListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ErrorListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ErrorListType, sizeof(ns5__ErrorListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ErrorListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ErrorListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:PhraseNotFound", &(((ns5__ErrorListType*)a)->PhraseNotFound), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns5:FieldNotFound", &(((ns5__ErrorListType*)a)->FieldNotFound), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ErrorListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ErrorListType, 0, sizeof(ns5__ErrorListType), 0, soap_copy_ns5__ErrorListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__ErrorListType * SOAP_FMAC6 soap_new_ns5__ErrorListType(struct soap *soap, int n)
{	return soap_instantiate_ns5__ErrorListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__ErrorListType(struct soap *soap, ns5__ErrorListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__ErrorListType * SOAP_FMAC4 soap_instantiate_ns5__ErrorListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ErrorListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ErrorListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__ErrorListType;
		if (size)
			*size = sizeof(ns5__ErrorListType);
		((ns5__ErrorListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__ErrorListType[n];
		if (size)
			*size = n * sizeof(ns5__ErrorListType);
		for (int i = 0; i < n; i++)
			((ns5__ErrorListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ErrorListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ErrorListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ErrorListType %p -> %p\n", q, p));
	*(ns5__ErrorListType*)p = *(ns5__ErrorListType*)q;
}

void _ns4__eInfoResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__eInfoResultType(soap, &((_ns4__eInfoResultMS*)this)->eInfoResult);
	/* transient soap skipped */
}

void _ns4__eInfoResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns4__eInfoResultMS*)this)->eInfoResult = NULL;
	/* transient soap skipped */
}

int _ns4__eInfoResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__eInfoResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns4__eInfoResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__eInfoResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__eInfoResultMS(struct soap *soap, const char *tag, int id, const _ns4__eInfoResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__eInfoResultMS), type);
	if (a->eInfoResult)
		soap_element_result(soap, "ns4:eInfoResult");
	soap_out_PointerTons4__eInfoResultType(soap, "ns4:eInfoResult", -1, &(((_ns4__eInfoResultMS*)a)->eInfoResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns4__eInfoResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__eInfoResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__eInfoResultMS * SOAP_FMAC4 soap_get__ns4__eInfoResultMS(struct soap *soap, _ns4__eInfoResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__eInfoResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns4__eInfoResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__eInfoResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__eInfoResultMS * SOAP_FMAC4 soap_in__ns4__eInfoResultMS(struct soap *soap, const char *tag, _ns4__eInfoResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__eInfoResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__eInfoResultMS, sizeof(_ns4__eInfoResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__eInfoResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__eInfoResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__eInfoResultType(soap, "ns4:eInfoResult", &(((_ns4__eInfoResultMS*)a)->eInfoResult), "ns4:eInfoResultType"))
				{	soap_flag_eInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns4:eInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__eInfoResultMS, 0, sizeof(_ns4__eInfoResultMS), 0, soap_copy__ns4__eInfoResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns4__eInfoResultMS * SOAP_FMAC6 soap_new__ns4__eInfoResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns4__eInfoResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns4__eInfoResultMS(struct soap *soap, _ns4__eInfoResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns4__eInfoResultMS * SOAP_FMAC4 soap_instantiate__ns4__eInfoResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__eInfoResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__eInfoResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns4__eInfoResultMS;
		if (size)
			*size = sizeof(_ns4__eInfoResultMS);
		((_ns4__eInfoResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns4__eInfoResultMS[n];
		if (size)
			*size = n * sizeof(_ns4__eInfoResultMS);
		for (int i = 0; i < n; i++)
			((_ns4__eInfoResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__eInfoResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__eInfoResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__eInfoResultMS %p -> %p\n", q, p));
	*(_ns4__eInfoResultMS*)p = *(_ns4__eInfoResultMS*)q;
}

void _ns4__eInfoRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequestMS*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequestMS*)this)->email);
	/* transient soap skipped */
}

void _ns4__eInfoRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns4__eInfoRequestMS*)this)->db = NULL;
	((_ns4__eInfoRequestMS*)this)->tool = NULL;
	((_ns4__eInfoRequestMS*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns4__eInfoRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__eInfoRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns4__eInfoRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__eInfoRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__eInfoRequestMS(struct soap *soap, const char *tag, int id, const _ns4__eInfoRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__eInfoRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns4:db", -1, &(((_ns4__eInfoRequestMS*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns4:tool", -1, &(((_ns4__eInfoRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns4:email", -1, &(((_ns4__eInfoRequestMS*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns4__eInfoRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__eInfoRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__eInfoRequestMS * SOAP_FMAC4 soap_get__ns4__eInfoRequestMS(struct soap *soap, _ns4__eInfoRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__eInfoRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns4__eInfoRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__eInfoRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__eInfoRequestMS * SOAP_FMAC4 soap_in__ns4__eInfoRequestMS(struct soap *soap, const char *tag, _ns4__eInfoRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__eInfoRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__eInfoRequestMS, sizeof(_ns4__eInfoRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__eInfoRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__eInfoRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:db", &(((_ns4__eInfoRequestMS*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:tool", &(((_ns4__eInfoRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:email", &(((_ns4__eInfoRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__eInfoRequestMS, 0, sizeof(_ns4__eInfoRequestMS), 0, soap_copy__ns4__eInfoRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns4__eInfoRequestMS * SOAP_FMAC6 soap_new__ns4__eInfoRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns4__eInfoRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns4__eInfoRequestMS(struct soap *soap, _ns4__eInfoRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns4__eInfoRequestMS * SOAP_FMAC4 soap_instantiate__ns4__eInfoRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__eInfoRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__eInfoRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns4__eInfoRequestMS;
		if (size)
			*size = sizeof(_ns4__eInfoRequestMS);
		((_ns4__eInfoRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns4__eInfoRequestMS[n];
		if (size)
			*size = n * sizeof(_ns4__eInfoRequestMS);
		for (int i = 0; i < n; i++)
			((_ns4__eInfoRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__eInfoRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__eInfoRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__eInfoRequestMS %p -> %p\n", q, p));
	*(_ns4__eInfoRequestMS*)p = *(_ns4__eInfoRequestMS*)q;
}

void _ns4__eInfoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequest*)this)->db);
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoRequest*)this)->email);
	/* transient soap skipped */
}

void _ns4__eInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns4__eInfoRequest*)this)->db = NULL;
	((_ns4__eInfoRequest*)this)->tool = NULL;
	((_ns4__eInfoRequest*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns4__eInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__eInfoRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns4__eInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__eInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__eInfoRequest(struct soap *soap, const char *tag, int id, const _ns4__eInfoRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__eInfoRequest), type);
	soap_out_PointerTostd__string(soap, "ns4:db", -1, &(((_ns4__eInfoRequest*)a)->db), "");
	soap_out_PointerTostd__string(soap, "ns4:tool", -1, &(((_ns4__eInfoRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns4:email", -1, &(((_ns4__eInfoRequest*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns4__eInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__eInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__eInfoRequest * SOAP_FMAC4 soap_get__ns4__eInfoRequest(struct soap *soap, _ns4__eInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__eInfoRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns4__eInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__eInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__eInfoRequest * SOAP_FMAC4 soap_in__ns4__eInfoRequest(struct soap *soap, const char *tag, _ns4__eInfoRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__eInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__eInfoRequest, sizeof(_ns4__eInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__eInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__eInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_db1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:db", &(((_ns4__eInfoRequest*)a)->db), "xsd:string"))
				{	soap_flag_db1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:tool", &(((_ns4__eInfoRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:email", &(((_ns4__eInfoRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__eInfoRequest, 0, sizeof(_ns4__eInfoRequest), 0, soap_copy__ns4__eInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns4__eInfoRequest * SOAP_FMAC6 soap_new__ns4__eInfoRequest(struct soap *soap, int n)
{	return soap_instantiate__ns4__eInfoRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns4__eInfoRequest(struct soap *soap, _ns4__eInfoRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns4__eInfoRequest * SOAP_FMAC4 soap_instantiate__ns4__eInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__eInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__eInfoRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns4__eInfoRequest;
		if (size)
			*size = sizeof(_ns4__eInfoRequest);
		((_ns4__eInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns4__eInfoRequest[n];
		if (size)
			*size = n * sizeof(_ns4__eInfoRequest);
		for (int i = 0; i < n; i++)
			((_ns4__eInfoRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__eInfoRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__eInfoRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__eInfoRequest %p -> %p\n", q, p));
	*(_ns4__eInfoRequest*)p = *(_ns4__eInfoRequest*)q;
}

void _ns4__eInfoResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns4__eInfoResult*)this)->ERROR_);
	soap_serialize_PointerTons4__DbListType(soap, &((_ns4__eInfoResult*)this)->DbList);
	soap_serialize_PointerTons4__DbInfoType(soap, &((_ns4__eInfoResult*)this)->DbInfo);
	/* transient soap skipped */
}

void _ns4__eInfoResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns4__eInfoResult*)this)->ERROR_ = NULL;
	((_ns4__eInfoResult*)this)->DbList = NULL;
	((_ns4__eInfoResult*)this)->DbInfo = NULL;
	/* transient soap skipped */
}

int _ns4__eInfoResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__eInfoResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns4__eInfoResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__eInfoResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__eInfoResult(struct soap *soap, const char *tag, int id, const _ns4__eInfoResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__eInfoResult), type);
	if (a->ERROR_)
		soap_element_result(soap, "ns4:ERROR_");
	soap_out_PointerTostd__string(soap, "ns4:ERROR_", -1, &(((_ns4__eInfoResult*)a)->ERROR_), "");
	soap_out_PointerTons4__DbListType(soap, "ns4:DbList", -1, &(((_ns4__eInfoResult*)a)->DbList), "");
	soap_out_PointerTons4__DbInfoType(soap, "ns4:DbInfo", -1, &(((_ns4__eInfoResult*)a)->DbInfo), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns4__eInfoResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__eInfoResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__eInfoResult * SOAP_FMAC4 soap_get__ns4__eInfoResult(struct soap *soap, _ns4__eInfoResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__eInfoResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns4__eInfoResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__eInfoResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__eInfoResult * SOAP_FMAC4 soap_in__ns4__eInfoResult(struct soap *soap, const char *tag, _ns4__eInfoResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__eInfoResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__eInfoResult, sizeof(_ns4__eInfoResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__eInfoResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__eInfoResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1, soap_flag_DbList1 = 1, soap_flag_DbInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:ERROR_", &(((_ns4__eInfoResult*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_DbList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DbListType(soap, "ns4:DbList", &(((_ns4__eInfoResult*)a)->DbList), "ns4:DbListType"))
				{	soap_flag_DbList1--;
					continue;
				}
			if (soap_flag_DbInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DbInfoType(soap, "ns4:DbInfo", &(((_ns4__eInfoResult*)a)->DbInfo), "ns4:DbInfoType"))
				{	soap_flag_DbInfo1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns4:ERROR_");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__eInfoResult, 0, sizeof(_ns4__eInfoResult), 0, soap_copy__ns4__eInfoResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns4__eInfoResult * SOAP_FMAC6 soap_new__ns4__eInfoResult(struct soap *soap, int n)
{	return soap_instantiate__ns4__eInfoResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns4__eInfoResult(struct soap *soap, _ns4__eInfoResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns4__eInfoResult * SOAP_FMAC4 soap_instantiate__ns4__eInfoResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__eInfoResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__eInfoResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns4__eInfoResult;
		if (size)
			*size = sizeof(_ns4__eInfoResult);
		((_ns4__eInfoResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns4__eInfoResult[n];
		if (size)
			*size = n * sizeof(_ns4__eInfoResult);
		for (int i = 0; i < n; i++)
			((_ns4__eInfoResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__eInfoResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__eInfoResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__eInfoResult %p -> %p\n", q, p));
	*(_ns4__eInfoResult*)p = *(_ns4__eInfoResult*)q;
}

void ns4__eInfoResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns4__eInfoResultType*)this)->ERROR_);
	soap_serialize_PointerTons4__DbListType(soap, &((ns4__eInfoResultType*)this)->DbList);
	soap_serialize_PointerTons4__DbInfoType(soap, &((ns4__eInfoResultType*)this)->DbInfo);
	/* transient soap skipped */
}

void ns4__eInfoResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__eInfoResultType*)this)->ERROR_ = NULL;
	((ns4__eInfoResultType*)this)->DbList = NULL;
	((ns4__eInfoResultType*)this)->DbInfo = NULL;
	/* transient soap skipped */
}

int ns4__eInfoResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__eInfoResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__eInfoResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__eInfoResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__eInfoResultType(struct soap *soap, const char *tag, int id, const ns4__eInfoResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__eInfoResultType), type);
	soap_out_PointerTostd__string(soap, "ns4:ERROR_", -1, &(((ns4__eInfoResultType*)a)->ERROR_), "");
	soap_out_PointerTons4__DbListType(soap, "ns4:DbList", -1, &(((ns4__eInfoResultType*)a)->DbList), "");
	soap_out_PointerTons4__DbInfoType(soap, "ns4:DbInfo", -1, &(((ns4__eInfoResultType*)a)->DbInfo), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__eInfoResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__eInfoResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__eInfoResultType * SOAP_FMAC4 soap_get_ns4__eInfoResultType(struct soap *soap, ns4__eInfoResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__eInfoResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__eInfoResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__eInfoResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__eInfoResultType * SOAP_FMAC4 soap_in_ns4__eInfoResultType(struct soap *soap, const char *tag, ns4__eInfoResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__eInfoResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__eInfoResultType, sizeof(ns4__eInfoResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__eInfoResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__eInfoResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1, soap_flag_DbList1 = 1, soap_flag_DbInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns4:ERROR_", &(((ns4__eInfoResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap_flag_DbList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DbListType(soap, "ns4:DbList", &(((ns4__eInfoResultType*)a)->DbList), "ns4:DbListType"))
				{	soap_flag_DbList1--;
					continue;
				}
			if (soap_flag_DbInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DbInfoType(soap, "ns4:DbInfo", &(((ns4__eInfoResultType*)a)->DbInfo), "ns4:DbInfoType"))
				{	soap_flag_DbInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__eInfoResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__eInfoResultType, 0, sizeof(ns4__eInfoResultType), 0, soap_copy_ns4__eInfoResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__eInfoResultType * SOAP_FMAC6 soap_new_ns4__eInfoResultType(struct soap *soap, int n)
{	return soap_instantiate_ns4__eInfoResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__eInfoResultType(struct soap *soap, ns4__eInfoResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__eInfoResultType * SOAP_FMAC4 soap_instantiate_ns4__eInfoResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__eInfoResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__eInfoResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__eInfoResultType;
		if (size)
			*size = sizeof(ns4__eInfoResultType);
		((ns4__eInfoResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__eInfoResultType[n];
		if (size)
			*size = n * sizeof(ns4__eInfoResultType);
		for (int i = 0; i < n; i++)
			((ns4__eInfoResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__eInfoResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__eInfoResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__eInfoResultType %p -> %p\n", q, p));
	*(ns4__eInfoResultType*)p = *(ns4__eInfoResultType*)q;
}

void ns4__LinkListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__LinkType(soap, &((ns4__LinkListType*)this)->Link);
	/* transient soap skipped */
}

void ns4__LinkListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__LinkType(soap, &((ns4__LinkListType*)this)->Link);
	/* transient soap skipped */
}

int ns4__LinkListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__LinkListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__LinkListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__LinkListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LinkListType(struct soap *soap, const char *tag, int id, const ns4__LinkListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__LinkListType), type);
	soap_out_std__vectorTemplateOfPointerTons4__LinkType(soap, "ns4:Link", -1, &(((ns4__LinkListType*)a)->Link), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__LinkListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__LinkListType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__LinkListType * SOAP_FMAC4 soap_get_ns4__LinkListType(struct soap *soap, ns4__LinkListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LinkListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__LinkListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__LinkListType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__LinkListType * SOAP_FMAC4 soap_in_ns4__LinkListType(struct soap *soap, const char *tag, ns4__LinkListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__LinkListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LinkListType, sizeof(ns4__LinkListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__LinkListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__LinkListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__LinkType(soap, "ns4:Link", &(((ns4__LinkListType*)a)->Link), "ns4:LinkType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__LinkListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__LinkListType, 0, sizeof(ns4__LinkListType), 0, soap_copy_ns4__LinkListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__LinkListType * SOAP_FMAC6 soap_new_ns4__LinkListType(struct soap *soap, int n)
{	return soap_instantiate_ns4__LinkListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__LinkListType(struct soap *soap, ns4__LinkListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__LinkListType * SOAP_FMAC4 soap_instantiate_ns4__LinkListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__LinkListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__LinkListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__LinkListType;
		if (size)
			*size = sizeof(ns4__LinkListType);
		((ns4__LinkListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__LinkListType[n];
		if (size)
			*size = n * sizeof(ns4__LinkListType);
		for (int i = 0; i < n; i++)
			((ns4__LinkListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__LinkListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__LinkListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__LinkListType %p -> %p\n", q, p));
	*(ns4__LinkListType*)p = *(ns4__LinkListType*)q;
}

void ns4__LinkType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns4__LinkType*)this)->Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__LinkType*)this)->Name);
	soap_embedded(soap, &((ns4__LinkType*)this)->Menu, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__LinkType*)this)->Menu);
	soap_embedded(soap, &((ns4__LinkType*)this)->Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__LinkType*)this)->Description);
	soap_embedded(soap, &((ns4__LinkType*)this)->DbTo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__LinkType*)this)->DbTo);
	/* transient soap skipped */
}

void ns4__LinkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns4__LinkType*)this)->Name);
	soap_default_std__string(soap, &((ns4__LinkType*)this)->Menu);
	soap_default_std__string(soap, &((ns4__LinkType*)this)->Description);
	soap_default_std__string(soap, &((ns4__LinkType*)this)->DbTo);
	/* transient soap skipped */
}

int ns4__LinkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__LinkType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__LinkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__LinkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LinkType(struct soap *soap, const char *tag, int id, const ns4__LinkType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__LinkType), type);
	soap_out_std__string(soap, "ns4:Name", -1, &(((ns4__LinkType*)a)->Name), "");
	soap_out_std__string(soap, "ns4:Menu", -1, &(((ns4__LinkType*)a)->Menu), "");
	soap_out_std__string(soap, "ns4:Description", -1, &(((ns4__LinkType*)a)->Description), "");
	soap_out_std__string(soap, "ns4:DbTo", -1, &(((ns4__LinkType*)a)->DbTo), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__LinkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__LinkType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__LinkType * SOAP_FMAC4 soap_get_ns4__LinkType(struct soap *soap, ns4__LinkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__LinkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__LinkType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__LinkType * SOAP_FMAC4 soap_in_ns4__LinkType(struct soap *soap, const char *tag, ns4__LinkType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__LinkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LinkType, sizeof(ns4__LinkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__LinkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__LinkType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Name1 = 1, soap_flag_Menu1 = 1, soap_flag_Description1 = 1, soap_flag_DbTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Name", &(((ns4__LinkType*)a)->Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Menu1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Menu", &(((ns4__LinkType*)a)->Menu), "xsd:string"))
				{	soap_flag_Menu1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Description", &(((ns4__LinkType*)a)->Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_DbTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:DbTo", &(((ns4__LinkType*)a)->DbTo), "xsd:string"))
				{	soap_flag_DbTo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Menu1 > 0 || soap_flag_Description1 > 0 || soap_flag_DbTo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__LinkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__LinkType, 0, sizeof(ns4__LinkType), 0, soap_copy_ns4__LinkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__LinkType * SOAP_FMAC6 soap_new_ns4__LinkType(struct soap *soap, int n)
{	return soap_instantiate_ns4__LinkType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__LinkType(struct soap *soap, ns4__LinkType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__LinkType * SOAP_FMAC4 soap_instantiate_ns4__LinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__LinkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__LinkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__LinkType;
		if (size)
			*size = sizeof(ns4__LinkType);
		((ns4__LinkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__LinkType[n];
		if (size)
			*size = n * sizeof(ns4__LinkType);
		for (int i = 0; i < n; i++)
			((ns4__LinkType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__LinkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__LinkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__LinkType %p -> %p\n", q, p));
	*(ns4__LinkType*)p = *(ns4__LinkType*)q;
}

void ns4__FieldListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__FieldType(soap, &((ns4__FieldListType*)this)->Field);
	/* transient soap skipped */
}

void ns4__FieldListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__FieldType(soap, &((ns4__FieldListType*)this)->Field);
	/* transient soap skipped */
}

int ns4__FieldListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FieldListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FieldListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FieldListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FieldListType(struct soap *soap, const char *tag, int id, const ns4__FieldListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FieldListType), type);
	soap_out_std__vectorTemplateOfPointerTons4__FieldType(soap, "ns4:Field", -1, &(((ns4__FieldListType*)a)->Field), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__FieldListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FieldListType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FieldListType * SOAP_FMAC4 soap_get_ns4__FieldListType(struct soap *soap, ns4__FieldListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FieldListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__FieldListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FieldListType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FieldListType * SOAP_FMAC4 soap_in_ns4__FieldListType(struct soap *soap, const char *tag, ns4__FieldListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__FieldListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FieldListType, sizeof(ns4__FieldListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FieldListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__FieldListType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__FieldType(soap, "ns4:Field", &(((ns4__FieldListType*)a)->Field), "ns4:FieldType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__FieldListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FieldListType, 0, sizeof(ns4__FieldListType), 0, soap_copy_ns4__FieldListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__FieldListType * SOAP_FMAC6 soap_new_ns4__FieldListType(struct soap *soap, int n)
{	return soap_instantiate_ns4__FieldListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__FieldListType(struct soap *soap, ns4__FieldListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__FieldListType * SOAP_FMAC4 soap_instantiate_ns4__FieldListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FieldListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FieldListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FieldListType;
		if (size)
			*size = sizeof(ns4__FieldListType);
		((ns4__FieldListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FieldListType[n];
		if (size)
			*size = n * sizeof(ns4__FieldListType);
		for (int i = 0; i < n; i++)
			((ns4__FieldListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FieldListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FieldListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FieldListType %p -> %p\n", q, p));
	*(ns4__FieldListType*)p = *(ns4__FieldListType*)q;
}

void ns4__FieldType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns4__FieldType*)this)->Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->Name);
	soap_embedded(soap, &((ns4__FieldType*)this)->Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->Description);
	soap_embedded(soap, &((ns4__FieldType*)this)->TermCount, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->TermCount);
	soap_embedded(soap, &((ns4__FieldType*)this)->IsDate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->IsDate);
	soap_embedded(soap, &((ns4__FieldType*)this)->IsNumerical, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->IsNumerical);
	soap_embedded(soap, &((ns4__FieldType*)this)->SingleToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->SingleToken);
	soap_embedded(soap, &((ns4__FieldType*)this)->Hierarchy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__FieldType*)this)->Hierarchy);
	/* transient soap skipped */
}

void ns4__FieldType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns4__FieldType*)this)->Name);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->Description);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->TermCount);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->IsDate);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->IsNumerical);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->SingleToken);
	soap_default_std__string(soap, &((ns4__FieldType*)this)->Hierarchy);
	/* transient soap skipped */
}

int ns4__FieldType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__FieldType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__FieldType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__FieldType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FieldType(struct soap *soap, const char *tag, int id, const ns4__FieldType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FieldType), type);
	soap_out_std__string(soap, "ns4:Name", -1, &(((ns4__FieldType*)a)->Name), "");
	soap_out_std__string(soap, "ns4:Description", -1, &(((ns4__FieldType*)a)->Description), "");
	soap_out_std__string(soap, "ns4:TermCount", -1, &(((ns4__FieldType*)a)->TermCount), "");
	soap_out_std__string(soap, "ns4:IsDate", -1, &(((ns4__FieldType*)a)->IsDate), "");
	soap_out_std__string(soap, "ns4:IsNumerical", -1, &(((ns4__FieldType*)a)->IsNumerical), "");
	soap_out_std__string(soap, "ns4:SingleToken", -1, &(((ns4__FieldType*)a)->SingleToken), "");
	soap_out_std__string(soap, "ns4:Hierarchy", -1, &(((ns4__FieldType*)a)->Hierarchy), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__FieldType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__FieldType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__FieldType * SOAP_FMAC4 soap_get_ns4__FieldType(struct soap *soap, ns4__FieldType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FieldType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__FieldType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__FieldType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__FieldType * SOAP_FMAC4 soap_in_ns4__FieldType(struct soap *soap, const char *tag, ns4__FieldType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__FieldType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FieldType, sizeof(ns4__FieldType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__FieldType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__FieldType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Name1 = 1, soap_flag_Description1 = 1, soap_flag_TermCount1 = 1, soap_flag_IsDate1 = 1, soap_flag_IsNumerical1 = 1, soap_flag_SingleToken1 = 1, soap_flag_Hierarchy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Name", &(((ns4__FieldType*)a)->Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Description", &(((ns4__FieldType*)a)->Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_TermCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:TermCount", &(((ns4__FieldType*)a)->TermCount), "xsd:string"))
				{	soap_flag_TermCount1--;
					continue;
				}
			if (soap_flag_IsDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:IsDate", &(((ns4__FieldType*)a)->IsDate), "xsd:string"))
				{	soap_flag_IsDate1--;
					continue;
				}
			if (soap_flag_IsNumerical1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:IsNumerical", &(((ns4__FieldType*)a)->IsNumerical), "xsd:string"))
				{	soap_flag_IsNumerical1--;
					continue;
				}
			if (soap_flag_SingleToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:SingleToken", &(((ns4__FieldType*)a)->SingleToken), "xsd:string"))
				{	soap_flag_SingleToken1--;
					continue;
				}
			if (soap_flag_Hierarchy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Hierarchy", &(((ns4__FieldType*)a)->Hierarchy), "xsd:string"))
				{	soap_flag_Hierarchy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Description1 > 0 || soap_flag_TermCount1 > 0 || soap_flag_IsDate1 > 0 || soap_flag_IsNumerical1 > 0 || soap_flag_SingleToken1 > 0 || soap_flag_Hierarchy1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__FieldType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FieldType, 0, sizeof(ns4__FieldType), 0, soap_copy_ns4__FieldType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__FieldType * SOAP_FMAC6 soap_new_ns4__FieldType(struct soap *soap, int n)
{	return soap_instantiate_ns4__FieldType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__FieldType(struct soap *soap, ns4__FieldType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__FieldType * SOAP_FMAC4 soap_instantiate_ns4__FieldType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__FieldType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__FieldType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__FieldType;
		if (size)
			*size = sizeof(ns4__FieldType);
		((ns4__FieldType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__FieldType[n];
		if (size)
			*size = n * sizeof(ns4__FieldType);
		for (int i = 0; i < n; i++)
			((ns4__FieldType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__FieldType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__FieldType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__FieldType %p -> %p\n", q, p));
	*(ns4__FieldType*)p = *(ns4__FieldType*)q;
}

void ns4__DbListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns4__union_DbListType(soap, ((ns4__DbListType*)this)->__union_DbListType, &((ns4__DbListType*)this)->union_DbListType);
	/* transient soap skipped */
}

void ns4__DbListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__DbListType*)this)->__union_DbListType = 0;
	/* transient soap skipped */
}

int ns4__DbListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__DbListType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__DbListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DbListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DbListType(struct soap *soap, const char *tag, int id, const ns4__DbListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DbListType), type);
	soap_out__ns4__union_DbListType(soap, ((ns4__DbListType*)a)->__union_DbListType, &((ns4__DbListType*)a)->union_DbListType);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__DbListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DbListType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DbListType * SOAP_FMAC4 soap_get_ns4__DbListType(struct soap *soap, ns4__DbListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DbListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__DbListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DbListType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DbListType * SOAP_FMAC4 soap_in_ns4__DbListType(struct soap *soap, const char *tag, ns4__DbListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__DbListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DbListType, sizeof(ns4__DbListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__DbListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__DbListType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_union_DbListType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DbListType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns4__union_DbListType(soap, &((ns4__DbListType*)a)->__union_DbListType, &((ns4__DbListType*)a)->union_DbListType))
				{	soap_flag_union_DbListType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DbListType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__DbListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DbListType, 0, sizeof(ns4__DbListType), 0, soap_copy_ns4__DbListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__DbListType * SOAP_FMAC6 soap_new_ns4__DbListType(struct soap *soap, int n)
{	return soap_instantiate_ns4__DbListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__DbListType(struct soap *soap, ns4__DbListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__DbListType * SOAP_FMAC4 soap_instantiate_ns4__DbListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DbListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__DbListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__DbListType;
		if (size)
			*size = sizeof(ns4__DbListType);
		((ns4__DbListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__DbListType[n];
		if (size)
			*size = n * sizeof(ns4__DbListType);
		for (int i = 0; i < n; i++)
			((ns4__DbListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__DbListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DbListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DbListType %p -> %p\n", q, p));
	*(ns4__DbListType*)p = *(ns4__DbListType*)q;
}

void ns4__DbInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns4__DbInfoType*)this)->DbName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__DbInfoType*)this)->DbName);
	soap_embedded(soap, &((ns4__DbInfoType*)this)->MenuName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__DbInfoType*)this)->MenuName);
	soap_embedded(soap, &((ns4__DbInfoType*)this)->Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__DbInfoType*)this)->Description);
	soap_embedded(soap, &((ns4__DbInfoType*)this)->Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__DbInfoType*)this)->Count);
	soap_embedded(soap, &((ns4__DbInfoType*)this)->LastUpdate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns4__DbInfoType*)this)->LastUpdate);
	soap_serialize_PointerTons4__FieldListType(soap, &((ns4__DbInfoType*)this)->FieldList);
	soap_serialize_PointerTons4__LinkListType(soap, &((ns4__DbInfoType*)this)->LinkList);
	/* transient soap skipped */
}

void ns4__DbInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns4__DbInfoType*)this)->DbName);
	soap_default_std__string(soap, &((ns4__DbInfoType*)this)->MenuName);
	soap_default_std__string(soap, &((ns4__DbInfoType*)this)->Description);
	soap_default_std__string(soap, &((ns4__DbInfoType*)this)->Count);
	soap_default_std__string(soap, &((ns4__DbInfoType*)this)->LastUpdate);
	((ns4__DbInfoType*)this)->FieldList = NULL;
	((ns4__DbInfoType*)this)->LinkList = NULL;
	/* transient soap skipped */
}

int ns4__DbInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__DbInfoType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__DbInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__DbInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DbInfoType(struct soap *soap, const char *tag, int id, const ns4__DbInfoType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DbInfoType), type);
	soap_out_std__string(soap, "ns4:DbName", -1, &(((ns4__DbInfoType*)a)->DbName), "");
	soap_out_std__string(soap, "ns4:MenuName", -1, &(((ns4__DbInfoType*)a)->MenuName), "");
	soap_out_std__string(soap, "ns4:Description", -1, &(((ns4__DbInfoType*)a)->Description), "");
	soap_out_std__string(soap, "ns4:Count", -1, &(((ns4__DbInfoType*)a)->Count), "");
	soap_out_std__string(soap, "ns4:LastUpdate", -1, &(((ns4__DbInfoType*)a)->LastUpdate), "");
	soap_out_PointerTons4__FieldListType(soap, "ns4:FieldList", -1, &(((ns4__DbInfoType*)a)->FieldList), "");
	soap_out_PointerTons4__LinkListType(soap, "ns4:LinkList", -1, &(((ns4__DbInfoType*)a)->LinkList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__DbInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__DbInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__DbInfoType * SOAP_FMAC4 soap_get_ns4__DbInfoType(struct soap *soap, ns4__DbInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DbInfoType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__DbInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__DbInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__DbInfoType * SOAP_FMAC4 soap_in_ns4__DbInfoType(struct soap *soap, const char *tag, ns4__DbInfoType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__DbInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DbInfoType, sizeof(ns4__DbInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__DbInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__DbInfoType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DbName1 = 1, soap_flag_MenuName1 = 1, soap_flag_Description1 = 1, soap_flag_Count1 = 1, soap_flag_LastUpdate1 = 1, soap_flag_FieldList1 = 1, soap_flag_LinkList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:DbName", &(((ns4__DbInfoType*)a)->DbName), "xsd:string"))
				{	soap_flag_DbName1--;
					continue;
				}
			if (soap_flag_MenuName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:MenuName", &(((ns4__DbInfoType*)a)->MenuName), "xsd:string"))
				{	soap_flag_MenuName1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Description", &(((ns4__DbInfoType*)a)->Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:Count", &(((ns4__DbInfoType*)a)->Count), "xsd:string"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_LastUpdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns4:LastUpdate", &(((ns4__DbInfoType*)a)->LastUpdate), "xsd:string"))
				{	soap_flag_LastUpdate1--;
					continue;
				}
			if (soap_flag_FieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FieldListType(soap, "ns4:FieldList", &(((ns4__DbInfoType*)a)->FieldList), "ns4:FieldListType"))
				{	soap_flag_FieldList1--;
					continue;
				}
			if (soap_flag_LinkList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__LinkListType(soap, "ns4:LinkList", &(((ns4__DbInfoType*)a)->LinkList), "ns4:LinkListType"))
				{	soap_flag_LinkList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DbName1 > 0 || soap_flag_MenuName1 > 0 || soap_flag_Description1 > 0 || soap_flag_Count1 > 0 || soap_flag_LastUpdate1 > 0 || soap_flag_FieldList1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__DbInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DbInfoType, 0, sizeof(ns4__DbInfoType), 0, soap_copy_ns4__DbInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__DbInfoType * SOAP_FMAC6 soap_new_ns4__DbInfoType(struct soap *soap, int n)
{	return soap_instantiate_ns4__DbInfoType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__DbInfoType(struct soap *soap, ns4__DbInfoType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__DbInfoType * SOAP_FMAC4 soap_instantiate_ns4__DbInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__DbInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__DbInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__DbInfoType;
		if (size)
			*size = sizeof(ns4__DbInfoType);
		((ns4__DbInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__DbInfoType[n];
		if (size)
			*size = n * sizeof(ns4__DbInfoType);
		for (int i = 0; i < n; i++)
			((ns4__DbInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__DbInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__DbInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__DbInfoType %p -> %p\n", q, p));
	*(ns4__DbInfoType*)p = *(ns4__DbInfoType*)q;
}

void _ns3__ResultMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__GQueryResultType(soap, &((_ns3__ResultMS*)this)->Result);
	/* transient soap skipped */
}

void _ns3__ResultMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns3__ResultMS*)this)->Result = NULL;
	/* transient soap skipped */
}

int _ns3__ResultMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__ResultMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__ResultMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ResultMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ResultMS(struct soap *soap, const char *tag, int id, const _ns3__ResultMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ResultMS), type);
	if (a->Result)
		soap_element_result(soap, "ns3:Result");
	soap_out_PointerTons3__GQueryResultType(soap, "ns3:Result", -1, &(((_ns3__ResultMS*)a)->Result), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns3__ResultMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ResultMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ResultMS * SOAP_FMAC4 soap_get__ns3__ResultMS(struct soap *soap, _ns3__ResultMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns3__ResultMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__ResultMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ResultMS * SOAP_FMAC4 soap_in__ns3__ResultMS(struct soap *soap, const char *tag, _ns3__ResultMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ResultMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ResultMS, sizeof(_ns3__ResultMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__ResultMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__ResultMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__GQueryResultType(soap, "ns3:Result", &(((_ns3__ResultMS*)a)->Result), "ns3:GQueryResultType"))
				{	soap_flag_Result1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ResultMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ResultMS, 0, sizeof(_ns3__ResultMS), 0, soap_copy__ns3__ResultMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns3__ResultMS * SOAP_FMAC6 soap_new__ns3__ResultMS(struct soap *soap, int n)
{	return soap_instantiate__ns3__ResultMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns3__ResultMS(struct soap *soap, _ns3__ResultMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns3__ResultMS * SOAP_FMAC4 soap_instantiate__ns3__ResultMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ResultMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__ResultMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__ResultMS;
		if (size)
			*size = sizeof(_ns3__ResultMS);
		((_ns3__ResultMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__ResultMS[n];
		if (size)
			*size = n * sizeof(_ns3__ResultMS);
		for (int i = 0; i < n; i++)
			((_ns3__ResultMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__ResultMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__ResultMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__ResultMS %p -> %p\n", q, p));
	*(_ns3__ResultMS*)p = *(_ns3__ResultMS*)q;
}

void _ns3__eGqueryRequestMS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequestMS*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequestMS*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequestMS*)this)->email);
	/* transient soap skipped */
}

void _ns3__eGqueryRequestMS::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns3__eGqueryRequestMS*)this)->term = NULL;
	((_ns3__eGqueryRequestMS*)this)->tool = NULL;
	((_ns3__eGqueryRequestMS*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns3__eGqueryRequestMS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__eGqueryRequestMS);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__eGqueryRequestMS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__eGqueryRequestMS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__eGqueryRequestMS(struct soap *soap, const char *tag, int id, const _ns3__eGqueryRequestMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__eGqueryRequestMS), type);
	soap_out_PointerTostd__string(soap, "ns3:term", -1, &(((_ns3__eGqueryRequestMS*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns3:tool", -1, &(((_ns3__eGqueryRequestMS*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns3:email", -1, &(((_ns3__eGqueryRequestMS*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns3__eGqueryRequestMS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__eGqueryRequestMS(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__eGqueryRequestMS * SOAP_FMAC4 soap_get__ns3__eGqueryRequestMS(struct soap *soap, _ns3__eGqueryRequestMS *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__eGqueryRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns3__eGqueryRequestMS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__eGqueryRequestMS(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__eGqueryRequestMS * SOAP_FMAC4 soap_in__ns3__eGqueryRequestMS(struct soap *soap, const char *tag, _ns3__eGqueryRequestMS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__eGqueryRequestMS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__eGqueryRequestMS, sizeof(_ns3__eGqueryRequestMS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__eGqueryRequestMS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__eGqueryRequestMS *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_term1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:term", &(((_ns3__eGqueryRequestMS*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:tool", &(((_ns3__eGqueryRequestMS*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:email", &(((_ns3__eGqueryRequestMS*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__eGqueryRequestMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__eGqueryRequestMS, 0, sizeof(_ns3__eGqueryRequestMS), 0, soap_copy__ns3__eGqueryRequestMS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns3__eGqueryRequestMS * SOAP_FMAC6 soap_new__ns3__eGqueryRequestMS(struct soap *soap, int n)
{	return soap_instantiate__ns3__eGqueryRequestMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns3__eGqueryRequestMS(struct soap *soap, _ns3__eGqueryRequestMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns3__eGqueryRequestMS * SOAP_FMAC4 soap_instantiate__ns3__eGqueryRequestMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__eGqueryRequestMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__eGqueryRequestMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__eGqueryRequestMS;
		if (size)
			*size = sizeof(_ns3__eGqueryRequestMS);
		((_ns3__eGqueryRequestMS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__eGqueryRequestMS[n];
		if (size)
			*size = n * sizeof(_ns3__eGqueryRequestMS);
		for (int i = 0; i < n; i++)
			((_ns3__eGqueryRequestMS*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__eGqueryRequestMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__eGqueryRequestMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__eGqueryRequestMS %p -> %p\n", q, p));
	*(_ns3__eGqueryRequestMS*)p = *(_ns3__eGqueryRequestMS*)q;
}

void _ns3__eGqueryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequest*)this)->term);
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequest*)this)->tool);
	soap_serialize_PointerTostd__string(soap, &((_ns3__eGqueryRequest*)this)->email);
	/* transient soap skipped */
}

void _ns3__eGqueryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns3__eGqueryRequest*)this)->term = NULL;
	((_ns3__eGqueryRequest*)this)->tool = NULL;
	((_ns3__eGqueryRequest*)this)->email = NULL;
	/* transient soap skipped */
}

int _ns3__eGqueryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__eGqueryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__eGqueryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__eGqueryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__eGqueryRequest(struct soap *soap, const char *tag, int id, const _ns3__eGqueryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__eGqueryRequest), type);
	soap_out_PointerTostd__string(soap, "ns3:term", -1, &(((_ns3__eGqueryRequest*)a)->term), "");
	soap_out_PointerTostd__string(soap, "ns3:tool", -1, &(((_ns3__eGqueryRequest*)a)->tool), "");
	soap_out_PointerTostd__string(soap, "ns3:email", -1, &(((_ns3__eGqueryRequest*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns3__eGqueryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__eGqueryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__eGqueryRequest * SOAP_FMAC4 soap_get__ns3__eGqueryRequest(struct soap *soap, _ns3__eGqueryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__eGqueryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns3__eGqueryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__eGqueryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__eGqueryRequest * SOAP_FMAC4 soap_in__ns3__eGqueryRequest(struct soap *soap, const char *tag, _ns3__eGqueryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__eGqueryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__eGqueryRequest, sizeof(_ns3__eGqueryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__eGqueryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__eGqueryRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_term1 = 1, soap_flag_tool1 = 1, soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:term", &(((_ns3__eGqueryRequest*)a)->term), "xsd:string"))
				{	soap_flag_term1--;
					continue;
				}
			if (soap_flag_tool1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:tool", &(((_ns3__eGqueryRequest*)a)->tool), "xsd:string"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:email", &(((_ns3__eGqueryRequest*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__eGqueryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__eGqueryRequest, 0, sizeof(_ns3__eGqueryRequest), 0, soap_copy__ns3__eGqueryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns3__eGqueryRequest * SOAP_FMAC6 soap_new__ns3__eGqueryRequest(struct soap *soap, int n)
{	return soap_instantiate__ns3__eGqueryRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns3__eGqueryRequest(struct soap *soap, _ns3__eGqueryRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns3__eGqueryRequest * SOAP_FMAC4 soap_instantiate__ns3__eGqueryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__eGqueryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__eGqueryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__eGqueryRequest;
		if (size)
			*size = sizeof(_ns3__eGqueryRequest);
		((_ns3__eGqueryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__eGqueryRequest[n];
		if (size)
			*size = n * sizeof(_ns3__eGqueryRequest);
		for (int i = 0; i < n; i++)
			((_ns3__eGqueryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__eGqueryRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__eGqueryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__eGqueryRequest %p -> %p\n", q, p));
	*(_ns3__eGqueryRequest*)p = *(_ns3__eGqueryRequest*)q;
}

void _ns3__Result::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ns3__Result*)this)->Term, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ns3__Result*)this)->Term);
	soap_serialize_PointerTons3__eGQueryResultType(soap, &((_ns3__Result*)this)->eGQueryResult);
	/* transient soap skipped */
}

void _ns3__Result::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ns3__Result*)this)->Term);
	((_ns3__Result*)this)->eGQueryResult = NULL;
	/* transient soap skipped */
}

int _ns3__Result::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__Result);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__Result::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Result(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Result(struct soap *soap, const char *tag, int id, const _ns3__Result *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Result), type);
	soap_element_result(soap, "ns3:Term");
	soap_out_std__string(soap, "ns3:Term", -1, &(((_ns3__Result*)a)->Term), "");
	soap_out_PointerTons3__eGQueryResultType(soap, "ns3:eGQueryResult", -1, &(((_ns3__Result*)a)->eGQueryResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns3__Result::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Result(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Result * SOAP_FMAC4 soap_get__ns3__Result(struct soap *soap, _ns3__Result *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Result(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns3__Result::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Result(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Result * SOAP_FMAC4 soap_in__ns3__Result(struct soap *soap, const char *tag, _ns3__Result *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Result *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Result, sizeof(_ns3__Result), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__Result)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__Result *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Term1 = 1, soap_flag_eGQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Term", &(((_ns3__Result*)a)->Term), "xsd:string"))
				{	soap_flag_Term1--;
					continue;
				}
			if (soap_flag_eGQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__eGQueryResultType(soap, "ns3:eGQueryResult", &(((_ns3__Result*)a)->eGQueryResult), "ns3:eGQueryResultType"))
				{	soap_flag_eGQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:Term");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Term1 > 0 || soap_flag_eGQueryResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Result, 0, sizeof(_ns3__Result), 0, soap_copy__ns3__Result);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns3__Result * SOAP_FMAC6 soap_new__ns3__Result(struct soap *soap, int n)
{	return soap_instantiate__ns3__Result(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns3__Result(struct soap *soap, _ns3__Result *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns3__Result * SOAP_FMAC4 soap_instantiate__ns3__Result(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Result(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__Result, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__Result;
		if (size)
			*size = sizeof(_ns3__Result);
		((_ns3__Result*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__Result[n];
		if (size)
			*size = n * sizeof(_ns3__Result);
		for (int i = 0; i < n; i++)
			((_ns3__Result*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__Result*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__Result(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__Result %p -> %p\n", q, p));
	*(_ns3__Result*)p = *(_ns3__Result*)q;
}

void ns3__GQueryResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns3__GQueryResultType*)this)->Term, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns3__GQueryResultType*)this)->Term);
	soap_serialize_PointerTons3__eGQueryResultType(soap, &((ns3__GQueryResultType*)this)->eGQueryResult);
	/* transient soap skipped */
}

void ns3__GQueryResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns3__GQueryResultType*)this)->Term);
	((ns3__GQueryResultType*)this)->eGQueryResult = NULL;
	/* transient soap skipped */
}

int ns3__GQueryResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__GQueryResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__GQueryResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__GQueryResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__GQueryResultType(struct soap *soap, const char *tag, int id, const ns3__GQueryResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__GQueryResultType), type);
	soap_out_std__string(soap, "ns3:Term", -1, &(((ns3__GQueryResultType*)a)->Term), "");
	soap_out_PointerTons3__eGQueryResultType(soap, "ns3:eGQueryResult", -1, &(((ns3__GQueryResultType*)a)->eGQueryResult), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__GQueryResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__GQueryResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__GQueryResultType * SOAP_FMAC4 soap_get_ns3__GQueryResultType(struct soap *soap, ns3__GQueryResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__GQueryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__GQueryResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__GQueryResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__GQueryResultType * SOAP_FMAC4 soap_in_ns3__GQueryResultType(struct soap *soap, const char *tag, ns3__GQueryResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__GQueryResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__GQueryResultType, sizeof(ns3__GQueryResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__GQueryResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__GQueryResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Term1 = 1, soap_flag_eGQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Term", &(((ns3__GQueryResultType*)a)->Term), "xsd:string"))
				{	soap_flag_Term1--;
					continue;
				}
			if (soap_flag_eGQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__eGQueryResultType(soap, "ns3:eGQueryResult", &(((ns3__GQueryResultType*)a)->eGQueryResult), "ns3:eGQueryResultType"))
				{	soap_flag_eGQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Term1 > 0 || soap_flag_eGQueryResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__GQueryResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__GQueryResultType, 0, sizeof(ns3__GQueryResultType), 0, soap_copy_ns3__GQueryResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__GQueryResultType * SOAP_FMAC6 soap_new_ns3__GQueryResultType(struct soap *soap, int n)
{	return soap_instantiate_ns3__GQueryResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__GQueryResultType(struct soap *soap, ns3__GQueryResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__GQueryResultType * SOAP_FMAC4 soap_instantiate_ns3__GQueryResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__GQueryResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__GQueryResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__GQueryResultType;
		if (size)
			*size = sizeof(ns3__GQueryResultType);
		((ns3__GQueryResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__GQueryResultType[n];
		if (size)
			*size = n * sizeof(ns3__GQueryResultType);
		for (int i = 0; i < n; i++)
			((ns3__GQueryResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__GQueryResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__GQueryResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__GQueryResultType %p -> %p\n", q, p));
	*(ns3__GQueryResultType*)p = *(ns3__GQueryResultType*)q;
}

void ns3__eGQueryResultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns3__eGQueryResultType*)this)->ERROR_);
	soap_serialize_std__vectorTemplateOfPointerTons3__ResultItemType(soap, &((ns3__eGQueryResultType*)this)->ResultItem);
	/* transient soap skipped */
}

void ns3__eGQueryResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__eGQueryResultType*)this)->ERROR_ = NULL;
	soap_default_std__vectorTemplateOfPointerTons3__ResultItemType(soap, &((ns3__eGQueryResultType*)this)->ResultItem);
	/* transient soap skipped */
}

int ns3__eGQueryResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__eGQueryResultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__eGQueryResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__eGQueryResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__eGQueryResultType(struct soap *soap, const char *tag, int id, const ns3__eGQueryResultType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__eGQueryResultType), type);
	soap_out_PointerTostd__string(soap, "ns3:ERROR_", -1, &(((ns3__eGQueryResultType*)a)->ERROR_), "");
	soap_out_std__vectorTemplateOfPointerTons3__ResultItemType(soap, "ns3:ResultItem", -1, &(((ns3__eGQueryResultType*)a)->ResultItem), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__eGQueryResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__eGQueryResultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__eGQueryResultType * SOAP_FMAC4 soap_get_ns3__eGQueryResultType(struct soap *soap, ns3__eGQueryResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__eGQueryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__eGQueryResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__eGQueryResultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__eGQueryResultType * SOAP_FMAC4 soap_in_ns3__eGQueryResultType(struct soap *soap, const char *tag, ns3__eGQueryResultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__eGQueryResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__eGQueryResultType, sizeof(ns3__eGQueryResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__eGQueryResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__eGQueryResultType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ERROR_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ERROR_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns3:ERROR_", &(((ns3__eGQueryResultType*)a)->ERROR_), "xsd:string"))
				{	soap_flag_ERROR_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__ResultItemType(soap, "ns3:ResultItem", &(((ns3__eGQueryResultType*)a)->ResultItem), "ns3:ResultItemType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__eGQueryResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__eGQueryResultType, 0, sizeof(ns3__eGQueryResultType), 0, soap_copy_ns3__eGQueryResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__eGQueryResultType * SOAP_FMAC6 soap_new_ns3__eGQueryResultType(struct soap *soap, int n)
{	return soap_instantiate_ns3__eGQueryResultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__eGQueryResultType(struct soap *soap, ns3__eGQueryResultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__eGQueryResultType * SOAP_FMAC4 soap_instantiate_ns3__eGQueryResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__eGQueryResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__eGQueryResultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__eGQueryResultType;
		if (size)
			*size = sizeof(ns3__eGQueryResultType);
		((ns3__eGQueryResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__eGQueryResultType[n];
		if (size)
			*size = n * sizeof(ns3__eGQueryResultType);
		for (int i = 0; i < n; i++)
			((ns3__eGQueryResultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__eGQueryResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__eGQueryResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__eGQueryResultType %p -> %p\n", q, p));
	*(ns3__eGQueryResultType*)p = *(ns3__eGQueryResultType*)q;
}

void ns3__ResultItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns3__ResultItemType*)this)->DbName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns3__ResultItemType*)this)->DbName);
	soap_embedded(soap, &((ns3__ResultItemType*)this)->MenuName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns3__ResultItemType*)this)->MenuName);
	soap_embedded(soap, &((ns3__ResultItemType*)this)->Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns3__ResultItemType*)this)->Count);
	soap_embedded(soap, &((ns3__ResultItemType*)this)->Status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns3__ResultItemType*)this)->Status);
	/* transient soap skipped */
}

void ns3__ResultItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns3__ResultItemType*)this)->DbName);
	soap_default_std__string(soap, &((ns3__ResultItemType*)this)->MenuName);
	soap_default_std__string(soap, &((ns3__ResultItemType*)this)->Count);
	soap_default_std__string(soap, &((ns3__ResultItemType*)this)->Status);
	/* transient soap skipped */
}

int ns3__ResultItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ResultItemType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ResultItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ResultItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ResultItemType(struct soap *soap, const char *tag, int id, const ns3__ResultItemType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ResultItemType), type);
	soap_out_std__string(soap, "ns3:DbName", -1, &(((ns3__ResultItemType*)a)->DbName), "");
	soap_out_std__string(soap, "ns3:MenuName", -1, &(((ns3__ResultItemType*)a)->MenuName), "");
	soap_out_std__string(soap, "ns3:Count", -1, &(((ns3__ResultItemType*)a)->Count), "");
	soap_out_std__string(soap, "ns3:Status", -1, &(((ns3__ResultItemType*)a)->Status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__ResultItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ResultItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ResultItemType * SOAP_FMAC4 soap_get_ns3__ResultItemType(struct soap *soap, ns3__ResultItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ResultItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__ResultItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ResultItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ResultItemType * SOAP_FMAC4 soap_in_ns3__ResultItemType(struct soap *soap, const char *tag, ns3__ResultItemType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ResultItemType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ResultItemType, sizeof(ns3__ResultItemType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ResultItemType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ResultItemType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_DbName1 = 1, soap_flag_MenuName1 = 1, soap_flag_Count1 = 1, soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DbName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:DbName", &(((ns3__ResultItemType*)a)->DbName), "xsd:string"))
				{	soap_flag_DbName1--;
					continue;
				}
			if (soap_flag_MenuName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:MenuName", &(((ns3__ResultItemType*)a)->MenuName), "xsd:string"))
				{	soap_flag_MenuName1--;
					continue;
				}
			if (soap_flag_Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Count", &(((ns3__ResultItemType*)a)->Count), "xsd:string"))
				{	soap_flag_Count1--;
					continue;
				}
			if (soap_flag_Status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns3:Status", &(((ns3__ResultItemType*)a)->Status), "xsd:string"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DbName1 > 0 || soap_flag_MenuName1 > 0 || soap_flag_Count1 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ResultItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ResultItemType, 0, sizeof(ns3__ResultItemType), 0, soap_copy_ns3__ResultItemType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__ResultItemType * SOAP_FMAC6 soap_new_ns3__ResultItemType(struct soap *soap, int n)
{	return soap_instantiate_ns3__ResultItemType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__ResultItemType(struct soap *soap, ns3__ResultItemType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__ResultItemType * SOAP_FMAC4 soap_instantiate_ns3__ResultItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ResultItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ResultItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ResultItemType;
		if (size)
			*size = sizeof(ns3__ResultItemType);
		((ns3__ResultItemType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ResultItemType[n];
		if (size)
			*size = n * sizeof(ns3__ResultItemType);
		for (int i = 0; i < n; i++)
			((ns3__ResultItemType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ResultItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ResultItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ResultItemType %p -> %p\n", q, p));
	*(ns3__ResultItemType*)p = *(ns3__ResultItemType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NMTOKEN(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NMTOKEN, 0, sizeof(std::string), 0, soap_copy_xsd__NMTOKEN);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__NMTOKEN(struct soap *soap, int n)
{	return soap_instantiate_xsd__NMTOKEN(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NMTOKEN(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__NMTOKEN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NMTOKEN(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__NMTOKEN, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NMTOKEN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSpell_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns8__eSpellRequestMS(soap, &a->ns8__eSpellRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSpell_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns8__eSpellRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSpell_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSpell_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSpell_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns8__eSpellRequestMS(soap, "ns8:eSpellRequestMS", -1, &a->ns8__eSpellRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSpell_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSpell_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSpell_USCOREMS *a, const char *type)
{
	short soap_flag_ns8__eSpellRequestMS = 1;
	a = (struct __ns1__run_USCOREeSpell_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSpell_USCOREMS, sizeof(struct __ns1__run_USCOREeSpell_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSpell_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns8__eSpellRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns8__eSpellRequestMS(soap, "ns8:eSpellRequestMS", &a->ns8__eSpellRequestMS, ""))
				{	soap_flag_ns8__eSpellRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSpell_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSpell_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSpell_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSpell_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSpell_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSpell_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSpell_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSpell_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSpell_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSpell_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSpell_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSpell_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSpell_USCOREMS*)p = *(struct __ns1__run_USCOREeSpell_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSpell(struct soap *soap, const struct __ns1__run_USCOREeSpell *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns8__eSpellRequest(soap, &a->ns8__eSpellRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSpell(struct soap *soap, struct __ns1__run_USCOREeSpell *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns8__eSpellRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSpell(struct soap *soap, const struct __ns1__run_USCOREeSpell *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSpell(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSpell(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSpell *a, const char *type)
{
	soap_out_PointerTo_ns8__eSpellRequest(soap, "ns8:eSpellRequest", -1, &a->ns8__eSpellRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell * SOAP_FMAC4 soap_get___ns1__run_USCOREeSpell(struct soap *soap, struct __ns1__run_USCOREeSpell *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSpell(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell * SOAP_FMAC4 soap_in___ns1__run_USCOREeSpell(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSpell *a, const char *type)
{
	short soap_flag_ns8__eSpellRequest = 1;
	a = (struct __ns1__run_USCOREeSpell *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSpell, sizeof(struct __ns1__run_USCOREeSpell), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSpell(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns8__eSpellRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns8__eSpellRequest(soap, "ns8:eSpellRequest", &a->ns8__eSpellRequest, ""))
				{	soap_flag_ns8__eSpellRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSpell * SOAP_FMAC6 soap_new___ns1__run_USCOREeSpell(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSpell(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSpell(struct soap *soap, struct __ns1__run_USCOREeSpell *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSpell * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSpell(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSpell(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSpell, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSpell;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSpell);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSpell[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSpell);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSpell*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSpell(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSpell %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSpell*)p = *(struct __ns1__run_USCOREeSpell*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeLink_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__eLinkRequestMS(soap, &a->ns7__eLinkRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeLink_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__eLinkRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeLink_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeLink_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeLink_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns7__eLinkRequestMS(soap, "ns7:eLinkRequestMS", -1, &a->ns7__eLinkRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeLink_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeLink_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeLink_USCOREMS *a, const char *type)
{
	short soap_flag_ns7__eLinkRequestMS = 1;
	a = (struct __ns1__run_USCOREeLink_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeLink_USCOREMS, sizeof(struct __ns1__run_USCOREeLink_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeLink_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__eLinkRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__eLinkRequestMS(soap, "ns7:eLinkRequestMS", &a->ns7__eLinkRequestMS, ""))
				{	soap_flag_ns7__eLinkRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeLink_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeLink_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeLink_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeLink_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeLink_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeLink_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeLink_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeLink_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeLink_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeLink_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeLink_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeLink_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeLink_USCOREMS*)p = *(struct __ns1__run_USCOREeLink_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeLink(struct soap *soap, const struct __ns1__run_USCOREeLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__eLinkRequest(soap, &a->ns7__eLinkRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeLink(struct soap *soap, struct __ns1__run_USCOREeLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__eLinkRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeLink(struct soap *soap, const struct __ns1__run_USCOREeLink *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeLink(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeLink(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeLink *a, const char *type)
{
	soap_out_PointerTo_ns7__eLinkRequest(soap, "ns7:eLinkRequest", -1, &a->ns7__eLinkRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink * SOAP_FMAC4 soap_get___ns1__run_USCOREeLink(struct soap *soap, struct __ns1__run_USCOREeLink *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeLink(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink * SOAP_FMAC4 soap_in___ns1__run_USCOREeLink(struct soap *soap, const char *tag, struct __ns1__run_USCOREeLink *a, const char *type)
{
	short soap_flag_ns7__eLinkRequest = 1;
	a = (struct __ns1__run_USCOREeLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeLink, sizeof(struct __ns1__run_USCOREeLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeLink(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__eLinkRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__eLinkRequest(soap, "ns7:eLinkRequest", &a->ns7__eLinkRequest, ""))
				{	soap_flag_ns7__eLinkRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeLink * SOAP_FMAC6 soap_new___ns1__run_USCOREeLink(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeLink(struct soap *soap, struct __ns1__run_USCOREeLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeLink * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeLink;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeLink);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeLink[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeLink %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeLink*)p = *(struct __ns1__run_USCOREeLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSummary_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__eSummaryRequestMS(soap, &a->ns6__eSummaryRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSummary_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__eSummaryRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSummary_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSummary_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSummary_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns6__eSummaryRequestMS(soap, "ns6:eSummaryRequestMS", -1, &a->ns6__eSummaryRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSummary_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSummary_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSummary_USCOREMS *a, const char *type)
{
	short soap_flag_ns6__eSummaryRequestMS = 1;
	a = (struct __ns1__run_USCOREeSummary_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSummary_USCOREMS, sizeof(struct __ns1__run_USCOREeSummary_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSummary_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__eSummaryRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__eSummaryRequestMS(soap, "ns6:eSummaryRequestMS", &a->ns6__eSummaryRequestMS, ""))
				{	soap_flag_ns6__eSummaryRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSummary_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSummary_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSummary_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSummary_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSummary_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSummary_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSummary_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSummary_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSummary_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSummary_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSummary_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSummary_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSummary_USCOREMS*)p = *(struct __ns1__run_USCOREeSummary_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSummary(struct soap *soap, const struct __ns1__run_USCOREeSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__eSummaryRequest(soap, &a->ns6__eSummaryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSummary(struct soap *soap, struct __ns1__run_USCOREeSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__eSummaryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSummary(struct soap *soap, const struct __ns1__run_USCOREeSummary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSummary(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSummary(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSummary *a, const char *type)
{
	soap_out_PointerTo_ns6__eSummaryRequest(soap, "ns6:eSummaryRequest", -1, &a->ns6__eSummaryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary * SOAP_FMAC4 soap_get___ns1__run_USCOREeSummary(struct soap *soap, struct __ns1__run_USCOREeSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSummary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary * SOAP_FMAC4 soap_in___ns1__run_USCOREeSummary(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSummary *a, const char *type)
{
	short soap_flag_ns6__eSummaryRequest = 1;
	a = (struct __ns1__run_USCOREeSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSummary, sizeof(struct __ns1__run_USCOREeSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSummary(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__eSummaryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__eSummaryRequest(soap, "ns6:eSummaryRequest", &a->ns6__eSummaryRequest, ""))
				{	soap_flag_ns6__eSummaryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSummary * SOAP_FMAC6 soap_new___ns1__run_USCOREeSummary(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSummary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSummary(struct soap *soap, struct __ns1__run_USCOREeSummary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSummary * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSummary;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSummary);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSummary[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSummary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSummary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSummary %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSummary*)p = *(struct __ns1__run_USCOREeSummary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSearch_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__eSearchRequestMS(soap, &a->ns5__eSearchRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSearch_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__eSearchRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeSearch_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSearch_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSearch_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns5__eSearchRequestMS(soap, "ns5:eSearchRequestMS", -1, &a->ns5__eSearchRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSearch_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSearch_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSearch_USCOREMS *a, const char *type)
{
	short soap_flag_ns5__eSearchRequestMS = 1;
	a = (struct __ns1__run_USCOREeSearch_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSearch_USCOREMS, sizeof(struct __ns1__run_USCOREeSearch_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSearch_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__eSearchRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__eSearchRequestMS(soap, "ns5:eSearchRequestMS", &a->ns5__eSearchRequestMS, ""))
				{	soap_flag_ns5__eSearchRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSearch_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSearch_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeSearch_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSearch_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSearch_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSearch_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSearch_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSearch_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSearch_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSearch_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSearch_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSearch_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSearch_USCOREMS*)p = *(struct __ns1__run_USCOREeSearch_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeSearch(struct soap *soap, const struct __ns1__run_USCOREeSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__eSearchRequest(soap, &a->ns5__eSearchRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeSearch(struct soap *soap, struct __ns1__run_USCOREeSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__eSearchRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeSearch(struct soap *soap, const struct __ns1__run_USCOREeSearch *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeSearch(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeSearch(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeSearch *a, const char *type)
{
	soap_out_PointerTo_ns5__eSearchRequest(soap, "ns5:eSearchRequest", -1, &a->ns5__eSearchRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch * SOAP_FMAC4 soap_get___ns1__run_USCOREeSearch(struct soap *soap, struct __ns1__run_USCOREeSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeSearch(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch * SOAP_FMAC4 soap_in___ns1__run_USCOREeSearch(struct soap *soap, const char *tag, struct __ns1__run_USCOREeSearch *a, const char *type)
{
	short soap_flag_ns5__eSearchRequest = 1;
	a = (struct __ns1__run_USCOREeSearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeSearch, sizeof(struct __ns1__run_USCOREeSearch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeSearch(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__eSearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__eSearchRequest(soap, "ns5:eSearchRequest", &a->ns5__eSearchRequest, ""))
				{	soap_flag_ns5__eSearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeSearch * SOAP_FMAC6 soap_new___ns1__run_USCOREeSearch(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeSearch(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeSearch(struct soap *soap, struct __ns1__run_USCOREeSearch *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeSearch * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeSearch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeSearch, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSearch;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeSearch);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeSearch[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeSearch);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeSearch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeSearch %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeSearch*)p = *(struct __ns1__run_USCOREeSearch*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeInfo_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__eInfoRequestMS(soap, &a->ns4__eInfoRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeInfo_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__eInfoRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeInfo_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeInfo_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeInfo_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns4__eInfoRequestMS(soap, "ns4:eInfoRequestMS", -1, &a->ns4__eInfoRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeInfo_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeInfo_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeInfo_USCOREMS *a, const char *type)
{
	short soap_flag_ns4__eInfoRequestMS = 1;
	a = (struct __ns1__run_USCOREeInfo_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeInfo_USCOREMS, sizeof(struct __ns1__run_USCOREeInfo_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeInfo_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__eInfoRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__eInfoRequestMS(soap, "ns4:eInfoRequestMS", &a->ns4__eInfoRequestMS, ""))
				{	soap_flag_ns4__eInfoRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeInfo_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeInfo_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeInfo_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeInfo_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeInfo_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeInfo_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeInfo_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeInfo_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeInfo_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeInfo_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeInfo_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeInfo_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeInfo_USCOREMS*)p = *(struct __ns1__run_USCOREeInfo_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeInfo(struct soap *soap, const struct __ns1__run_USCOREeInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__eInfoRequest(soap, &a->ns4__eInfoRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeInfo(struct soap *soap, struct __ns1__run_USCOREeInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__eInfoRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeInfo(struct soap *soap, const struct __ns1__run_USCOREeInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeInfo(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeInfo *a, const char *type)
{
	soap_out_PointerTo_ns4__eInfoRequest(soap, "ns4:eInfoRequest", -1, &a->ns4__eInfoRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo * SOAP_FMAC4 soap_get___ns1__run_USCOREeInfo(struct soap *soap, struct __ns1__run_USCOREeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo * SOAP_FMAC4 soap_in___ns1__run_USCOREeInfo(struct soap *soap, const char *tag, struct __ns1__run_USCOREeInfo *a, const char *type)
{
	short soap_flag_ns4__eInfoRequest = 1;
	a = (struct __ns1__run_USCOREeInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeInfo, sizeof(struct __ns1__run_USCOREeInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeInfo(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__eInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__eInfoRequest(soap, "ns4:eInfoRequest", &a->ns4__eInfoRequest, ""))
				{	soap_flag_ns4__eInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeInfo * SOAP_FMAC6 soap_new___ns1__run_USCOREeInfo(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeInfo(struct soap *soap, struct __ns1__run_USCOREeInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeInfo * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeInfo;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeInfo[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeInfo %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeInfo*)p = *(struct __ns1__run_USCOREeInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeGquery_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__eGqueryRequestMS(soap, &a->ns3__eGqueryRequestMS);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeGquery_USCOREMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__eGqueryRequestMS = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, const struct __ns1__run_USCOREeGquery_USCOREMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeGquery_USCOREMS(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeGquery_USCOREMS *a, const char *type)
{
	soap_out_PointerTo_ns3__eGqueryRequestMS(soap, "ns3:eGqueryRequestMS", -1, &a->ns3__eGqueryRequestMS, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery_USCOREMS * SOAP_FMAC4 soap_get___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeGquery_USCOREMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeGquery_USCOREMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery_USCOREMS * SOAP_FMAC4 soap_in___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, const char *tag, struct __ns1__run_USCOREeGquery_USCOREMS *a, const char *type)
{
	short soap_flag_ns3__eGqueryRequestMS = 1;
	a = (struct __ns1__run_USCOREeGquery_USCOREMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeGquery_USCOREMS, sizeof(struct __ns1__run_USCOREeGquery_USCOREMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeGquery_USCOREMS(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__eGqueryRequestMS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__eGqueryRequestMS(soap, "ns3:eGqueryRequestMS", &a->ns3__eGqueryRequestMS, ""))
				{	soap_flag_ns3__eGqueryRequestMS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeGquery_USCOREMS * SOAP_FMAC6 soap_new___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeGquery_USCOREMS(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, struct __ns1__run_USCOREeGquery_USCOREMS *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery_USCOREMS * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeGquery_USCOREMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeGquery_USCOREMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeGquery_USCOREMS;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeGquery_USCOREMS);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeGquery_USCOREMS[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeGquery_USCOREMS);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeGquery_USCOREMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeGquery_USCOREMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeGquery_USCOREMS %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeGquery_USCOREMS*)p = *(struct __ns1__run_USCOREeGquery_USCOREMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__run_USCOREeGquery(struct soap *soap, const struct __ns1__run_USCOREeGquery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__eGqueryRequest(soap, &a->ns3__eGqueryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__run_USCOREeGquery(struct soap *soap, struct __ns1__run_USCOREeGquery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__eGqueryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__run_USCOREeGquery(struct soap *soap, const struct __ns1__run_USCOREeGquery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__run_USCOREeGquery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__run_USCOREeGquery(struct soap *soap, const char *tag, int id, const struct __ns1__run_USCOREeGquery *a, const char *type)
{
	soap_out_PointerTo_ns3__eGqueryRequest(soap, "ns3:eGqueryRequest", -1, &a->ns3__eGqueryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery * SOAP_FMAC4 soap_get___ns1__run_USCOREeGquery(struct soap *soap, struct __ns1__run_USCOREeGquery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__run_USCOREeGquery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery * SOAP_FMAC4 soap_in___ns1__run_USCOREeGquery(struct soap *soap, const char *tag, struct __ns1__run_USCOREeGquery *a, const char *type)
{
	short soap_flag_ns3__eGqueryRequest = 1;
	a = (struct __ns1__run_USCOREeGquery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__run_USCOREeGquery, sizeof(struct __ns1__run_USCOREeGquery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__run_USCOREeGquery(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__eGqueryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__eGqueryRequest(soap, "ns3:eGqueryRequest", &a->ns3__eGqueryRequest, ""))
				{	soap_flag_ns3__eGqueryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__run_USCOREeGquery * SOAP_FMAC6 soap_new___ns1__run_USCOREeGquery(struct soap *soap, int n)
{	return soap_instantiate___ns1__run_USCOREeGquery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__run_USCOREeGquery(struct soap *soap, struct __ns1__run_USCOREeGquery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__run_USCOREeGquery * SOAP_FMAC4 soap_instantiate___ns1__run_USCOREeGquery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__run_USCOREeGquery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__run_USCOREeGquery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeGquery;
		if (size)
			*size = sizeof(struct __ns1__run_USCOREeGquery);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__run_USCOREeGquery[n];
		if (size)
			*size = n * sizeof(struct __ns1__run_USCOREeGquery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__run_USCOREeGquery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__run_USCOREeGquery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__run_USCOREeGquery %p -> %p\n", q, p));
	*(struct __ns1__run_USCOREeGquery*)p = *(struct __ns1__run_USCOREeGquery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_SpelledQueryType(struct soap *soap, const struct __ns8__union_SpelledQueryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns8__union_SpelledQueryType(soap, a->__union_SpelledQueryType, &a->union_SpelledQueryType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_SpelledQueryType = 0;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_SpelledQueryType(struct soap *soap, const struct __ns8__union_SpelledQueryType *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns8__union_SpelledQueryType(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_SpelledQueryType(struct soap *soap, const char *tag, int id, const struct __ns8__union_SpelledQueryType *a, const char *type)
{
	soap_out__ns8__union_SpelledQueryType(soap, a->__union_SpelledQueryType, &a->union_SpelledQueryType);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_SpelledQueryType * SOAP_FMAC4 soap_get___ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__union_SpelledQueryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns8__union_SpelledQueryType * SOAP_FMAC4 soap_in___ns8__union_SpelledQueryType(struct soap *soap, const char *tag, struct __ns8__union_SpelledQueryType *a, const char *type)
{
	a = (struct __ns8__union_SpelledQueryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns8__union_SpelledQueryType, sizeof(struct __ns8__union_SpelledQueryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__union_SpelledQueryType(soap, a);
		if (!soap_in__ns8__union_SpelledQueryType(soap, &a->__union_SpelledQueryType, &a->union_SpelledQueryType))
			return NULL;
	return a;
}

SOAP_FMAC5 struct __ns8__union_SpelledQueryType * SOAP_FMAC6 soap_new___ns8__union_SpelledQueryType(struct soap *soap, int n)
{	return soap_instantiate___ns8__union_SpelledQueryType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns8__union_SpelledQueryType * SOAP_FMAC4 soap_instantiate___ns8__union_SpelledQueryType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns8__union_SpelledQueryType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns8__union_SpelledQueryType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns8__union_SpelledQueryType;
		if (size)
			*size = sizeof(struct __ns8__union_SpelledQueryType);
	}
	else
	{	cp->ptr = (void*)new struct __ns8__union_SpelledQueryType[n];
		if (size)
			*size = n * sizeof(struct __ns8__union_SpelledQueryType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns8__union_SpelledQueryType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns8__union_SpelledQueryType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns8__union_SpelledQueryType %p -> %p\n", q, p));
	*(struct __ns8__union_SpelledQueryType*)p = *(struct __ns8__union_SpelledQueryType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__union_IdCheckListType(struct soap *soap, const struct __ns7__union_IdCheckListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns7__union_IdCheckListType(soap, a->__union_IdCheckListType, &a->union_IdCheckListType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_IdCheckListType = 0;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__union_IdCheckListType(struct soap *soap, const struct __ns7__union_IdCheckListType *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__union_IdCheckListType(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__union_IdCheckListType(struct soap *soap, const char *tag, int id, const struct __ns7__union_IdCheckListType *a, const char *type)
{
	soap_out__ns7__union_IdCheckListType(soap, a->__union_IdCheckListType, &a->union_IdCheckListType);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__union_IdCheckListType * SOAP_FMAC4 soap_get___ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__union_IdCheckListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns7__union_IdCheckListType * SOAP_FMAC4 soap_in___ns7__union_IdCheckListType(struct soap *soap, const char *tag, struct __ns7__union_IdCheckListType *a, const char *type)
{
	a = (struct __ns7__union_IdCheckListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns7__union_IdCheckListType, sizeof(struct __ns7__union_IdCheckListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__union_IdCheckListType(soap, a);
		if (!soap_in__ns7__union_IdCheckListType(soap, &a->__union_IdCheckListType, &a->union_IdCheckListType))
			return NULL;
	return a;
}

SOAP_FMAC5 struct __ns7__union_IdCheckListType * SOAP_FMAC6 soap_new___ns7__union_IdCheckListType(struct soap *soap, int n)
{	return soap_instantiate___ns7__union_IdCheckListType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns7__union_IdCheckListType * SOAP_FMAC4 soap_instantiate___ns7__union_IdCheckListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__union_IdCheckListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__union_IdCheckListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns7__union_IdCheckListType;
		if (size)
			*size = sizeof(struct __ns7__union_IdCheckListType);
	}
	else
	{	cp->ptr = (void*)new struct __ns7__union_IdCheckListType[n];
		if (size)
			*size = n * sizeof(struct __ns7__union_IdCheckListType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__union_IdCheckListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__union_IdCheckListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__union_IdCheckListType %p -> %p\n", q, p));
	*(struct __ns7__union_IdCheckListType*)p = *(struct __ns7__union_IdCheckListType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__union_ItemType(struct soap *soap, const struct __ns6__union_ItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns6__union_ItemType(soap, a->__union_ItemType, &a->union_ItemType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_ItemType = 0;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__union_ItemType(struct soap *soap, const struct __ns6__union_ItemType *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__union_ItemType(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__union_ItemType(struct soap *soap, const char *tag, int id, const struct __ns6__union_ItemType *a, const char *type)
{
	soap_out__ns6__union_ItemType(soap, a->__union_ItemType, &a->union_ItemType);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__union_ItemType * SOAP_FMAC4 soap_get___ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__union_ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns6__union_ItemType * SOAP_FMAC4 soap_in___ns6__union_ItemType(struct soap *soap, const char *tag, struct __ns6__union_ItemType *a, const char *type)
{
	a = (struct __ns6__union_ItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns6__union_ItemType, sizeof(struct __ns6__union_ItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__union_ItemType(soap, a);
		if (!soap_in__ns6__union_ItemType(soap, &a->__union_ItemType, &a->union_ItemType))
			return NULL;
	return a;
}

SOAP_FMAC5 struct __ns6__union_ItemType * SOAP_FMAC6 soap_new___ns6__union_ItemType(struct soap *soap, int n)
{	return soap_instantiate___ns6__union_ItemType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns6__union_ItemType * SOAP_FMAC4 soap_instantiate___ns6__union_ItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__union_ItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__union_ItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__union_ItemType;
		if (size)
			*size = sizeof(struct __ns6__union_ItemType);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__union_ItemType[n];
		if (size)
			*size = n * sizeof(struct __ns6__union_ItemType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__union_ItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__union_ItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__union_ItemType %p -> %p\n", q, p));
	*(struct __ns6__union_ItemType*)p = *(struct __ns6__union_ItemType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__union_TranslationStackType(struct soap *soap, const struct __ns5__union_TranslationStackType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns5__union_TranslationStackType(soap, a->__union_TranslationStackType, &a->union_TranslationStackType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_TranslationStackType = 0;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__union_TranslationStackType(struct soap *soap, const struct __ns5__union_TranslationStackType *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__union_TranslationStackType(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__union_TranslationStackType(struct soap *soap, const char *tag, int id, const struct __ns5__union_TranslationStackType *a, const char *type)
{
	soap_out__ns5__union_TranslationStackType(soap, a->__union_TranslationStackType, &a->union_TranslationStackType);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__union_TranslationStackType * SOAP_FMAC4 soap_get___ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__union_TranslationStackType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns5__union_TranslationStackType * SOAP_FMAC4 soap_in___ns5__union_TranslationStackType(struct soap *soap, const char *tag, struct __ns5__union_TranslationStackType *a, const char *type)
{
	a = (struct __ns5__union_TranslationStackType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns5__union_TranslationStackType, sizeof(struct __ns5__union_TranslationStackType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__union_TranslationStackType(soap, a);
		if (!soap_in__ns5__union_TranslationStackType(soap, &a->__union_TranslationStackType, &a->union_TranslationStackType))
			return NULL;
	return a;
}

SOAP_FMAC5 struct __ns5__union_TranslationStackType * SOAP_FMAC6 soap_new___ns5__union_TranslationStackType(struct soap *soap, int n)
{	return soap_instantiate___ns5__union_TranslationStackType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns5__union_TranslationStackType * SOAP_FMAC4 soap_instantiate___ns5__union_TranslationStackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__union_TranslationStackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__union_TranslationStackType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns5__union_TranslationStackType;
		if (size)
			*size = sizeof(struct __ns5__union_TranslationStackType);
	}
	else
	{	cp->ptr = (void*)new struct __ns5__union_TranslationStackType[n];
		if (size)
			*size = n * sizeof(struct __ns5__union_TranslationStackType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns5__union_TranslationStackType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__union_TranslationStackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__union_TranslationStackType %p -> %p\n", q, p));
	*(struct __ns5__union_TranslationStackType*)p = *(struct __ns5__union_TranslationStackType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_SpelledQueryType(struct soap *soap, int choice, const union _ns8__union_SpelledQueryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns8__union_SpelledQueryType_Replaced:
		soap_serialize_PointerTostd__string(soap, &a->Replaced);
		break;
	case SOAP_UNION__ns8__union_SpelledQueryType_Original:
		soap_serialize_PointerTostd__string(soap, &a->Original);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_SpelledQueryType(struct soap *soap, int choice, const union _ns8__union_SpelledQueryType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns8__union_SpelledQueryType_Replaced:
		return soap_out_PointerTostd__string(soap, "ns8:Replaced", -1, &a->Replaced, "");
	case SOAP_UNION__ns8__union_SpelledQueryType_Original:
		return soap_out_PointerTostd__string(soap, "ns8:Original", -1, &a->Original, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_SpelledQueryType * SOAP_FMAC4 soap_in__ns8__union_SpelledQueryType(struct soap *soap, int *choice, union _ns8__union_SpelledQueryType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Replaced = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns8:Replaced", &a->Replaced, "xsd:string"))
	{	*choice = SOAP_UNION__ns8__union_SpelledQueryType_Replaced;
		return a;
	}
	a->Original = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns8:Original", &a->Original, "xsd:string"))
	{	*choice = SOAP_UNION__ns8__union_SpelledQueryType_Original;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_LinkSetDbType(struct soap *soap, int choice, const union _ns7__union_LinkSetDbType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns7__union_LinkSetDbType_Link:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons7__LinkType(soap, &a->Link);
		break;
	case SOAP_UNION__ns7__union_LinkSetDbType_Info:
		soap_serialize_PointerTostd__string(soap, &a->Info);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__union_LinkSetDbType(struct soap *soap, int choice, const union _ns7__union_LinkSetDbType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns7__union_LinkSetDbType_Link:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons7__LinkType(soap, "ns7:Link", -1, &a->Link, "");
	case SOAP_UNION__ns7__union_LinkSetDbType_Info:
		return soap_out_PointerTostd__string(soap, "ns7:Info", -1, &a->Info, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_LinkSetDbType * SOAP_FMAC4 soap_in__ns7__union_LinkSetDbType(struct soap *soap, int *choice, union _ns7__union_LinkSetDbType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Link = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons7__LinkType(soap, "ns7:Link", &a->Link, "ns7:LinkType"))
	{	*choice = SOAP_UNION__ns7__union_LinkSetDbType_Link;
		return a;
	}
	a->Info = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns7:Info", &a->Info, "xsd:string"))
	{	*choice = SOAP_UNION__ns7__union_LinkSetDbType_Info;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_IdUrlSetType(struct soap *soap, int choice, const union _ns7__union_IdUrlSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns7__union_IdUrlSetType_ObjUrl:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(soap, &a->ObjUrl);
		break;
	case SOAP_UNION__ns7__union_IdUrlSetType_Info:
		soap_serialize_PointerTostd__string(soap, &a->Info);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__union_IdUrlSetType(struct soap *soap, int choice, const union _ns7__union_IdUrlSetType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns7__union_IdUrlSetType_ObjUrl:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(soap, "ns7:ObjUrl", -1, &a->ObjUrl, "");
	case SOAP_UNION__ns7__union_IdUrlSetType_Info:
		return soap_out_PointerTostd__string(soap, "ns7:Info", -1, &a->Info, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_IdUrlSetType * SOAP_FMAC4 soap_in__ns7__union_IdUrlSetType(struct soap *soap, int *choice, union _ns7__union_IdUrlSetType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->ObjUrl = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(soap, "ns7:ObjUrl", &a->ObjUrl, "ns7:ObjUrlType"))
	{	*choice = SOAP_UNION__ns7__union_IdUrlSetType_ObjUrl;
		return a;
	}
	a->Info = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns7:Info", &a->Info, "xsd:string"))
	{	*choice = SOAP_UNION__ns7__union_IdUrlSetType_Info;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_IdCheckListType(struct soap *soap, int choice, const union _ns7__union_IdCheckListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns7__union_IdCheckListType_Id:
		soap_serialize_PointerTons7__IdType(soap, &a->Id);
		break;
	case SOAP_UNION__ns7__union_IdCheckListType_IdLinkSet:
		soap_serialize_PointerTons7__IdLinkSetType(soap, &a->IdLinkSet);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__union_IdCheckListType(struct soap *soap, int choice, const union _ns7__union_IdCheckListType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns7__union_IdCheckListType_Id:
		return soap_out_PointerTons7__IdType(soap, "ns7:Id", -1, &a->Id, "");
	case SOAP_UNION__ns7__union_IdCheckListType_IdLinkSet:
		return soap_out_PointerTons7__IdLinkSetType(soap, "ns7:IdLinkSet", -1, &a->IdLinkSet, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_IdCheckListType * SOAP_FMAC4 soap_in__ns7__union_IdCheckListType(struct soap *soap, int *choice, union _ns7__union_IdCheckListType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Id = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__IdType(soap, "ns7:Id", &a->Id, "ns7:IdType"))
	{	*choice = SOAP_UNION__ns7__union_IdCheckListType_Id;
		return a;
	}
	a->IdLinkSet = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__IdLinkSetType(soap, "ns7:IdLinkSet", &a->IdLinkSet, "ns7:IdLinkSetType"))
	{	*choice = SOAP_UNION__ns7__union_IdCheckListType_IdLinkSet;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__union_ItemType(struct soap *soap, int choice, const union _ns6__union_ItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns6__union_ItemType_Item:
		soap_serialize_PointerTons6__ItemType(soap, &a->Item);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__union_ItemType(struct soap *soap, int choice, const union _ns6__union_ItemType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns6__union_ItemType_Item:
		return soap_out_PointerTons6__ItemType(soap, "ns6:Item", -1, &a->Item, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns6__union_ItemType * SOAP_FMAC4 soap_in__ns6__union_ItemType(struct soap *soap, int *choice, union _ns6__union_ItemType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Item = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__ItemType(soap, "ns6:Item", &a->Item, "ns6:ItemType"))
	{	*choice = SOAP_UNION__ns6__union_ItemType_Item;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__union_TranslationStackType(struct soap *soap, int choice, const union _ns5__union_TranslationStackType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns5__union_TranslationStackType_TermSet:
		soap_serialize_PointerTons5__TermSetType(soap, &a->TermSet);
		break;
	case SOAP_UNION__ns5__union_TranslationStackType_OP:
		soap_serialize_PointerTostd__string(soap, &a->OP);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__union_TranslationStackType(struct soap *soap, int choice, const union _ns5__union_TranslationStackType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns5__union_TranslationStackType_TermSet:
		return soap_out_PointerTons5__TermSetType(soap, "ns5:TermSet", -1, &a->TermSet, "");
	case SOAP_UNION__ns5__union_TranslationStackType_OP:
		return soap_out_PointerTostd__string(soap, "ns5:OP", -1, &a->OP, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns5__union_TranslationStackType * SOAP_FMAC4 soap_in__ns5__union_TranslationStackType(struct soap *soap, int *choice, union _ns5__union_TranslationStackType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->TermSet = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons5__TermSetType(soap, "ns5:TermSet", &a->TermSet, "ns5:TermSetType"))
	{	*choice = SOAP_UNION__ns5__union_TranslationStackType_TermSet;
		return a;
	}
	a->OP = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "ns5:OP", &a->OP, "xsd:string"))
	{	*choice = SOAP_UNION__ns5__union_TranslationStackType_OP;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__union_DbListType(struct soap *soap, int choice, const union _ns4__union_DbListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns4__union_DbListType_DbName:
		soap_serialize_PointerTostd__vectorTemplateOfstd__string(soap, &a->DbName);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__union_DbListType(struct soap *soap, int choice, const union _ns4__union_DbListType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns4__union_DbListType_DbName:
		return soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "ns4:DbName", -1, &a->DbName, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns4__union_DbListType * SOAP_FMAC4 soap_in__ns4__union_DbListType(struct soap *soap, int *choice, union _ns4__union_DbListType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->DbName = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "ns4:DbName", &a->DbName, "xsd:string"))
	{	*choice = SOAP_UNION__ns4__union_DbListType_DbName;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__eSpellResultMS(struct soap *soap, _ns8__eSpellResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns8__eSpellResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__eSpellResultMS(struct soap *soap, _ns8__eSpellResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__eSpellResultMS);
	if (soap_out_PointerTo_ns8__eSpellResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns8__eSpellResultMS(struct soap *soap, const char *tag, int id, _ns8__eSpellResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__eSpellResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__eSpellResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns8__eSpellResultMS(struct soap *soap, _ns8__eSpellResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns8__eSpellResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns8__eSpellResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns8__eSpellResultMS(struct soap *soap, const char *tag, _ns8__eSpellResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns8__eSpellResultMS **)soap_malloc(soap, sizeof(_ns8__eSpellResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns8__eSpellResultMS *)soap_instantiate__ns8__eSpellResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__eSpellResultMS, sizeof(_ns8__eSpellResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__eSpellRequestMS(struct soap *soap, _ns8__eSpellRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns8__eSpellRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__eSpellRequestMS(struct soap *soap, _ns8__eSpellRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__eSpellRequestMS);
	if (soap_out_PointerTo_ns8__eSpellRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns8__eSpellRequestMS(struct soap *soap, const char *tag, int id, _ns8__eSpellRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__eSpellRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__eSpellRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns8__eSpellRequestMS(struct soap *soap, _ns8__eSpellRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns8__eSpellRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns8__eSpellRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns8__eSpellRequestMS(struct soap *soap, const char *tag, _ns8__eSpellRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns8__eSpellRequestMS **)soap_malloc(soap, sizeof(_ns8__eSpellRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns8__eSpellRequestMS *)soap_instantiate__ns8__eSpellRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__eSpellRequestMS, sizeof(_ns8__eSpellRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__eSpellResult(struct soap *soap, _ns8__eSpellResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns8__eSpellResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__eSpellResult(struct soap *soap, _ns8__eSpellResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__eSpellResult);
	if (soap_out_PointerTo_ns8__eSpellResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns8__eSpellResult(struct soap *soap, const char *tag, int id, _ns8__eSpellResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__eSpellResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__eSpellResult ** SOAP_FMAC4 soap_get_PointerTo_ns8__eSpellResult(struct soap *soap, _ns8__eSpellResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns8__eSpellResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns8__eSpellResult ** SOAP_FMAC4 soap_in_PointerTo_ns8__eSpellResult(struct soap *soap, const char *tag, _ns8__eSpellResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns8__eSpellResult **)soap_malloc(soap, sizeof(_ns8__eSpellResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns8__eSpellResult *)soap_instantiate__ns8__eSpellResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__eSpellResult, sizeof(_ns8__eSpellResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__eSpellRequest(struct soap *soap, _ns8__eSpellRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns8__eSpellRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__eSpellRequest(struct soap *soap, _ns8__eSpellRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__eSpellRequest);
	if (soap_out_PointerTo_ns8__eSpellRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns8__eSpellRequest(struct soap *soap, const char *tag, int id, _ns8__eSpellRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__eSpellRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__eSpellRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__eSpellRequest(struct soap *soap, _ns8__eSpellRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns8__eSpellRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns8__eSpellRequest ** SOAP_FMAC4 soap_in_PointerTo_ns8__eSpellRequest(struct soap *soap, const char *tag, _ns8__eSpellRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns8__eSpellRequest **)soap_malloc(soap, sizeof(_ns8__eSpellRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns8__eSpellRequest *)soap_instantiate__ns8__eSpellRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns8__eSpellRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__eSpellRequest, sizeof(_ns8__eSpellRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__eLinkResultMS(struct soap *soap, _ns7__eLinkResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__eLinkResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__eLinkResultMS(struct soap *soap, _ns7__eLinkResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__eLinkResultMS);
	if (soap_out_PointerTo_ns7__eLinkResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__eLinkResultMS(struct soap *soap, const char *tag, int id, _ns7__eLinkResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__eLinkResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__eLinkResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns7__eLinkResultMS(struct soap *soap, _ns7__eLinkResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__eLinkResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns7__eLinkResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns7__eLinkResultMS(struct soap *soap, const char *tag, _ns7__eLinkResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__eLinkResultMS **)soap_malloc(soap, sizeof(_ns7__eLinkResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__eLinkResultMS *)soap_instantiate__ns7__eLinkResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__eLinkResultMS, sizeof(_ns7__eLinkResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__eLinkRequestMS(struct soap *soap, _ns7__eLinkRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__eLinkRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__eLinkRequestMS(struct soap *soap, _ns7__eLinkRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__eLinkRequestMS);
	if (soap_out_PointerTo_ns7__eLinkRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__eLinkRequestMS(struct soap *soap, const char *tag, int id, _ns7__eLinkRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__eLinkRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__eLinkRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns7__eLinkRequestMS(struct soap *soap, _ns7__eLinkRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__eLinkRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns7__eLinkRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns7__eLinkRequestMS(struct soap *soap, const char *tag, _ns7__eLinkRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__eLinkRequestMS **)soap_malloc(soap, sizeof(_ns7__eLinkRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__eLinkRequestMS *)soap_instantiate__ns7__eLinkRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__eLinkRequestMS, sizeof(_ns7__eLinkRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__eLinkResult(struct soap *soap, _ns7__eLinkResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__eLinkResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__eLinkResult(struct soap *soap, _ns7__eLinkResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__eLinkResult);
	if (soap_out_PointerTo_ns7__eLinkResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__eLinkResult(struct soap *soap, const char *tag, int id, _ns7__eLinkResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__eLinkResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__eLinkResult ** SOAP_FMAC4 soap_get_PointerTo_ns7__eLinkResult(struct soap *soap, _ns7__eLinkResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__eLinkResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns7__eLinkResult ** SOAP_FMAC4 soap_in_PointerTo_ns7__eLinkResult(struct soap *soap, const char *tag, _ns7__eLinkResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__eLinkResult **)soap_malloc(soap, sizeof(_ns7__eLinkResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__eLinkResult *)soap_instantiate__ns7__eLinkResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__eLinkResult, sizeof(_ns7__eLinkResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__eLinkRequest(struct soap *soap, _ns7__eLinkRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__eLinkRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__eLinkRequest(struct soap *soap, _ns7__eLinkRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__eLinkRequest);
	if (soap_out_PointerTo_ns7__eLinkRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__eLinkRequest(struct soap *soap, const char *tag, int id, _ns7__eLinkRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__eLinkRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__eLinkRequest ** SOAP_FMAC4 soap_get_PointerTo_ns7__eLinkRequest(struct soap *soap, _ns7__eLinkRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__eLinkRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns7__eLinkRequest ** SOAP_FMAC4 soap_in_PointerTo_ns7__eLinkRequest(struct soap *soap, const char *tag, _ns7__eLinkRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__eLinkRequest **)soap_malloc(soap, sizeof(_ns7__eLinkRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__eLinkRequest *)soap_instantiate__ns7__eLinkRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns7__eLinkRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__eLinkRequest, sizeof(_ns7__eLinkRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__eSummaryResultMS(struct soap *soap, _ns6__eSummaryResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__eSummaryResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__eSummaryResultMS(struct soap *soap, _ns6__eSummaryResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__eSummaryResultMS);
	if (soap_out_PointerTo_ns6__eSummaryResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__eSummaryResultMS(struct soap *soap, const char *tag, int id, _ns6__eSummaryResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__eSummaryResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__eSummaryResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns6__eSummaryResultMS(struct soap *soap, _ns6__eSummaryResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__eSummaryResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns6__eSummaryResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns6__eSummaryResultMS(struct soap *soap, const char *tag, _ns6__eSummaryResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__eSummaryResultMS **)soap_malloc(soap, sizeof(_ns6__eSummaryResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__eSummaryResultMS *)soap_instantiate__ns6__eSummaryResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__eSummaryResultMS, sizeof(_ns6__eSummaryResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__eSummaryRequestMS(struct soap *soap, _ns6__eSummaryRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__eSummaryRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__eSummaryRequestMS(struct soap *soap, _ns6__eSummaryRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__eSummaryRequestMS);
	if (soap_out_PointerTo_ns6__eSummaryRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__eSummaryRequestMS(struct soap *soap, const char *tag, int id, _ns6__eSummaryRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__eSummaryRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__eSummaryRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns6__eSummaryRequestMS(struct soap *soap, _ns6__eSummaryRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__eSummaryRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns6__eSummaryRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns6__eSummaryRequestMS(struct soap *soap, const char *tag, _ns6__eSummaryRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__eSummaryRequestMS **)soap_malloc(soap, sizeof(_ns6__eSummaryRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__eSummaryRequestMS *)soap_instantiate__ns6__eSummaryRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__eSummaryRequestMS, sizeof(_ns6__eSummaryRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__eSummaryResult(struct soap *soap, _ns6__eSummaryResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__eSummaryResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__eSummaryResult(struct soap *soap, _ns6__eSummaryResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__eSummaryResult);
	if (soap_out_PointerTo_ns6__eSummaryResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__eSummaryResult(struct soap *soap, const char *tag, int id, _ns6__eSummaryResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__eSummaryResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__eSummaryResult ** SOAP_FMAC4 soap_get_PointerTo_ns6__eSummaryResult(struct soap *soap, _ns6__eSummaryResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__eSummaryResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns6__eSummaryResult ** SOAP_FMAC4 soap_in_PointerTo_ns6__eSummaryResult(struct soap *soap, const char *tag, _ns6__eSummaryResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__eSummaryResult **)soap_malloc(soap, sizeof(_ns6__eSummaryResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__eSummaryResult *)soap_instantiate__ns6__eSummaryResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__eSummaryResult, sizeof(_ns6__eSummaryResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__eSummaryRequest(struct soap *soap, _ns6__eSummaryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__eSummaryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__eSummaryRequest(struct soap *soap, _ns6__eSummaryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__eSummaryRequest);
	if (soap_out_PointerTo_ns6__eSummaryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__eSummaryRequest(struct soap *soap, const char *tag, int id, _ns6__eSummaryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__eSummaryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__eSummaryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns6__eSummaryRequest(struct soap *soap, _ns6__eSummaryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__eSummaryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns6__eSummaryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns6__eSummaryRequest(struct soap *soap, const char *tag, _ns6__eSummaryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__eSummaryRequest **)soap_malloc(soap, sizeof(_ns6__eSummaryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__eSummaryRequest *)soap_instantiate__ns6__eSummaryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns6__eSummaryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__eSummaryRequest, sizeof(_ns6__eSummaryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__eSearchResultMS(struct soap *soap, _ns5__eSearchResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__eSearchResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__eSearchResultMS(struct soap *soap, _ns5__eSearchResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__eSearchResultMS);
	if (soap_out_PointerTo_ns5__eSearchResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__eSearchResultMS(struct soap *soap, const char *tag, int id, _ns5__eSearchResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__eSearchResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__eSearchResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns5__eSearchResultMS(struct soap *soap, _ns5__eSearchResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__eSearchResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns5__eSearchResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns5__eSearchResultMS(struct soap *soap, const char *tag, _ns5__eSearchResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__eSearchResultMS **)soap_malloc(soap, sizeof(_ns5__eSearchResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__eSearchResultMS *)soap_instantiate__ns5__eSearchResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__eSearchResultMS, sizeof(_ns5__eSearchResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__eSearchRequestMS(struct soap *soap, _ns5__eSearchRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__eSearchRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__eSearchRequestMS(struct soap *soap, _ns5__eSearchRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__eSearchRequestMS);
	if (soap_out_PointerTo_ns5__eSearchRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__eSearchRequestMS(struct soap *soap, const char *tag, int id, _ns5__eSearchRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__eSearchRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__eSearchRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns5__eSearchRequestMS(struct soap *soap, _ns5__eSearchRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__eSearchRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns5__eSearchRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns5__eSearchRequestMS(struct soap *soap, const char *tag, _ns5__eSearchRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__eSearchRequestMS **)soap_malloc(soap, sizeof(_ns5__eSearchRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__eSearchRequestMS *)soap_instantiate__ns5__eSearchRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__eSearchRequestMS, sizeof(_ns5__eSearchRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__eSearchResult(struct soap *soap, _ns5__eSearchResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__eSearchResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__eSearchResult(struct soap *soap, _ns5__eSearchResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__eSearchResult);
	if (soap_out_PointerTo_ns5__eSearchResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__eSearchResult(struct soap *soap, const char *tag, int id, _ns5__eSearchResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__eSearchResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__eSearchResult ** SOAP_FMAC4 soap_get_PointerTo_ns5__eSearchResult(struct soap *soap, _ns5__eSearchResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__eSearchResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns5__eSearchResult ** SOAP_FMAC4 soap_in_PointerTo_ns5__eSearchResult(struct soap *soap, const char *tag, _ns5__eSearchResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__eSearchResult **)soap_malloc(soap, sizeof(_ns5__eSearchResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__eSearchResult *)soap_instantiate__ns5__eSearchResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__eSearchResult, sizeof(_ns5__eSearchResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__eSearchRequest(struct soap *soap, _ns5__eSearchRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__eSearchRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__eSearchRequest(struct soap *soap, _ns5__eSearchRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__eSearchRequest);
	if (soap_out_PointerTo_ns5__eSearchRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__eSearchRequest(struct soap *soap, const char *tag, int id, _ns5__eSearchRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__eSearchRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__eSearchRequest ** SOAP_FMAC4 soap_get_PointerTo_ns5__eSearchRequest(struct soap *soap, _ns5__eSearchRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__eSearchRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns5__eSearchRequest ** SOAP_FMAC4 soap_in_PointerTo_ns5__eSearchRequest(struct soap *soap, const char *tag, _ns5__eSearchRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__eSearchRequest **)soap_malloc(soap, sizeof(_ns5__eSearchRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__eSearchRequest *)soap_instantiate__ns5__eSearchRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns5__eSearchRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__eSearchRequest, sizeof(_ns5__eSearchRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__eInfoResultMS(struct soap *soap, _ns4__eInfoResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__eInfoResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__eInfoResultMS(struct soap *soap, _ns4__eInfoResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__eInfoResultMS);
	if (soap_out_PointerTo_ns4__eInfoResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__eInfoResultMS(struct soap *soap, const char *tag, int id, _ns4__eInfoResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__eInfoResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__eInfoResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns4__eInfoResultMS(struct soap *soap, _ns4__eInfoResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__eInfoResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns4__eInfoResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns4__eInfoResultMS(struct soap *soap, const char *tag, _ns4__eInfoResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__eInfoResultMS **)soap_malloc(soap, sizeof(_ns4__eInfoResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__eInfoResultMS *)soap_instantiate__ns4__eInfoResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__eInfoResultMS, sizeof(_ns4__eInfoResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__eInfoRequestMS(struct soap *soap, _ns4__eInfoRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__eInfoRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__eInfoRequestMS(struct soap *soap, _ns4__eInfoRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__eInfoRequestMS);
	if (soap_out_PointerTo_ns4__eInfoRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__eInfoRequestMS(struct soap *soap, const char *tag, int id, _ns4__eInfoRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__eInfoRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__eInfoRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns4__eInfoRequestMS(struct soap *soap, _ns4__eInfoRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__eInfoRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns4__eInfoRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns4__eInfoRequestMS(struct soap *soap, const char *tag, _ns4__eInfoRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__eInfoRequestMS **)soap_malloc(soap, sizeof(_ns4__eInfoRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__eInfoRequestMS *)soap_instantiate__ns4__eInfoRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__eInfoRequestMS, sizeof(_ns4__eInfoRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__eInfoResult(struct soap *soap, _ns4__eInfoResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__eInfoResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__eInfoResult(struct soap *soap, _ns4__eInfoResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__eInfoResult);
	if (soap_out_PointerTo_ns4__eInfoResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__eInfoResult(struct soap *soap, const char *tag, int id, _ns4__eInfoResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__eInfoResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__eInfoResult ** SOAP_FMAC4 soap_get_PointerTo_ns4__eInfoResult(struct soap *soap, _ns4__eInfoResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__eInfoResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns4__eInfoResult ** SOAP_FMAC4 soap_in_PointerTo_ns4__eInfoResult(struct soap *soap, const char *tag, _ns4__eInfoResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__eInfoResult **)soap_malloc(soap, sizeof(_ns4__eInfoResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__eInfoResult *)soap_instantiate__ns4__eInfoResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__eInfoResult, sizeof(_ns4__eInfoResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__eInfoRequest(struct soap *soap, _ns4__eInfoRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__eInfoRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__eInfoRequest(struct soap *soap, _ns4__eInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__eInfoRequest);
	if (soap_out_PointerTo_ns4__eInfoRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__eInfoRequest(struct soap *soap, const char *tag, int id, _ns4__eInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__eInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__eInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns4__eInfoRequest(struct soap *soap, _ns4__eInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__eInfoRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns4__eInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns4__eInfoRequest(struct soap *soap, const char *tag, _ns4__eInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__eInfoRequest **)soap_malloc(soap, sizeof(_ns4__eInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__eInfoRequest *)soap_instantiate__ns4__eInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns4__eInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__eInfoRequest, sizeof(_ns4__eInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__ResultMS(struct soap *soap, _ns3__ResultMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__ResultMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__ResultMS(struct soap *soap, _ns3__ResultMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__ResultMS);
	if (soap_out_PointerTo_ns3__ResultMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__ResultMS(struct soap *soap, const char *tag, int id, _ns3__ResultMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__ResultMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__ResultMS ** SOAP_FMAC4 soap_get_PointerTo_ns3__ResultMS(struct soap *soap, _ns3__ResultMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__ResultMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns3__ResultMS ** SOAP_FMAC4 soap_in_PointerTo_ns3__ResultMS(struct soap *soap, const char *tag, _ns3__ResultMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__ResultMS **)soap_malloc(soap, sizeof(_ns3__ResultMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__ResultMS *)soap_instantiate__ns3__ResultMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns3__ResultMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__ResultMS, sizeof(_ns3__ResultMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__eGqueryRequestMS(struct soap *soap, _ns3__eGqueryRequestMS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__eGqueryRequestMS))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__eGqueryRequestMS(struct soap *soap, _ns3__eGqueryRequestMS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__eGqueryRequestMS);
	if (soap_out_PointerTo_ns3__eGqueryRequestMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__eGqueryRequestMS(struct soap *soap, const char *tag, int id, _ns3__eGqueryRequestMS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__eGqueryRequestMS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__eGqueryRequestMS ** SOAP_FMAC4 soap_get_PointerTo_ns3__eGqueryRequestMS(struct soap *soap, _ns3__eGqueryRequestMS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__eGqueryRequestMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns3__eGqueryRequestMS ** SOAP_FMAC4 soap_in_PointerTo_ns3__eGqueryRequestMS(struct soap *soap, const char *tag, _ns3__eGqueryRequestMS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__eGqueryRequestMS **)soap_malloc(soap, sizeof(_ns3__eGqueryRequestMS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__eGqueryRequestMS *)soap_instantiate__ns3__eGqueryRequestMS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns3__eGqueryRequestMS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__eGqueryRequestMS, sizeof(_ns3__eGqueryRequestMS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Result(struct soap *soap, _ns3__Result *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Result))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Result(struct soap *soap, _ns3__Result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__Result);
	if (soap_out_PointerTo_ns3__Result(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Result(struct soap *soap, const char *tag, int id, _ns3__Result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Result);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__Result ** SOAP_FMAC4 soap_get_PointerTo_ns3__Result(struct soap *soap, _ns3__Result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__Result(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns3__Result ** SOAP_FMAC4 soap_in_PointerTo_ns3__Result(struct soap *soap, const char *tag, _ns3__Result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__Result **)soap_malloc(soap, sizeof(_ns3__Result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__Result *)soap_instantiate__ns3__Result(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns3__Result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Result, sizeof(_ns3__Result), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__eGqueryRequest(struct soap *soap, _ns3__eGqueryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__eGqueryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__eGqueryRequest(struct soap *soap, _ns3__eGqueryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__eGqueryRequest);
	if (soap_out_PointerTo_ns3__eGqueryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__eGqueryRequest(struct soap *soap, const char *tag, int id, _ns3__eGqueryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__eGqueryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__eGqueryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__eGqueryRequest(struct soap *soap, _ns3__eGqueryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__eGqueryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns3__eGqueryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__eGqueryRequest(struct soap *soap, const char *tag, _ns3__eGqueryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__eGqueryRequest **)soap_malloc(soap, sizeof(_ns3__eGqueryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__eGqueryRequest *)soap_instantiate__ns3__eGqueryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns3__eGqueryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__eGqueryRequest, sizeof(_ns3__eGqueryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__eSpellResultType(struct soap *soap, ns8__eSpellResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__eSpellResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__eSpellResultType(struct soap *soap, ns8__eSpellResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__eSpellResultType);
	if (soap_out_PointerTons8__eSpellResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__eSpellResultType(struct soap *soap, const char *tag, int id, ns8__eSpellResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__eSpellResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns8__eSpellResultType ** SOAP_FMAC4 soap_get_PointerTons8__eSpellResultType(struct soap *soap, ns8__eSpellResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__eSpellResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns8__eSpellResultType ** SOAP_FMAC4 soap_in_PointerTons8__eSpellResultType(struct soap *soap, const char *tag, ns8__eSpellResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns8__eSpellResultType **)soap_malloc(soap, sizeof(ns8__eSpellResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns8__eSpellResultType *)soap_instantiate_ns8__eSpellResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns8__eSpellResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__eSpellResultType, sizeof(ns8__eSpellResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__SpelledQueryType(struct soap *soap, ns8__SpelledQueryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__SpelledQueryType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__SpelledQueryType(struct soap *soap, ns8__SpelledQueryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__SpelledQueryType);
	if (soap_out_PointerTons8__SpelledQueryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__SpelledQueryType(struct soap *soap, const char *tag, int id, ns8__SpelledQueryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__SpelledQueryType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns8__SpelledQueryType ** SOAP_FMAC4 soap_get_PointerTons8__SpelledQueryType(struct soap *soap, ns8__SpelledQueryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__SpelledQueryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns8__SpelledQueryType ** SOAP_FMAC4 soap_in_PointerTons8__SpelledQueryType(struct soap *soap, const char *tag, ns8__SpelledQueryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns8__SpelledQueryType **)soap_malloc(soap, sizeof(ns8__SpelledQueryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns8__SpelledQueryType *)soap_instantiate_ns8__SpelledQueryType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns8__SpelledQueryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__SpelledQueryType, sizeof(ns8__SpelledQueryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_SpelledQueryType))
		soap_serialize___ns8__union_SpelledQueryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_SpelledQueryType);
	if (soap_out_PointerTo__ns8__union_SpelledQueryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_SpelledQueryType(struct soap *soap, const char *tag, int id, struct __ns8__union_SpelledQueryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_SpelledQueryType);
	if (id < 0)
		return soap->error;
	return soap_out___ns8__union_SpelledQueryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_SpelledQueryType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_SpelledQueryType(struct soap *soap, struct __ns8__union_SpelledQueryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns8__union_SpelledQueryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns8__union_SpelledQueryType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_SpelledQueryType(struct soap *soap, const char *tag, struct __ns8__union_SpelledQueryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns8__union_SpelledQueryType **)soap_malloc(soap, sizeof(struct __ns8__union_SpelledQueryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns8__union_SpelledQueryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns8__union_SpelledQueryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_SpelledQueryType, sizeof(struct __ns8__union_SpelledQueryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__eLinkResultType(struct soap *soap, ns7__eLinkResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__eLinkResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__eLinkResultType(struct soap *soap, ns7__eLinkResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__eLinkResultType);
	if (soap_out_PointerTons7__eLinkResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__eLinkResultType(struct soap *soap, const char *tag, int id, ns7__eLinkResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__eLinkResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__eLinkResultType ** SOAP_FMAC4 soap_get_PointerTons7__eLinkResultType(struct soap *soap, ns7__eLinkResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__eLinkResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__eLinkResultType ** SOAP_FMAC4 soap_in_PointerTons7__eLinkResultType(struct soap *soap, const char *tag, ns7__eLinkResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__eLinkResultType **)soap_malloc(soap, sizeof(ns7__eLinkResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__eLinkResultType *)soap_instantiate_ns7__eLinkResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__eLinkResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__eLinkResultType, sizeof(ns7__eLinkResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__LinkSetType(struct soap *soap, ns7__LinkSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__LinkSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__LinkSetType(struct soap *soap, ns7__LinkSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__LinkSetType);
	if (soap_out_PointerTons7__LinkSetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__LinkSetType(struct soap *soap, const char *tag, int id, ns7__LinkSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__LinkSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__LinkSetType ** SOAP_FMAC4 soap_get_PointerTons7__LinkSetType(struct soap *soap, ns7__LinkSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__LinkSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__LinkSetType ** SOAP_FMAC4 soap_in_PointerTons7__LinkSetType(struct soap *soap, const char *tag, ns7__LinkSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__LinkSetType **)soap_malloc(soap, sizeof(ns7__LinkSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__LinkSetType *)soap_instantiate_ns7__LinkSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__LinkSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LinkSetType, sizeof(ns7__LinkSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ProviderType(struct soap *soap, ns7__ProviderType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ProviderType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ProviderType(struct soap *soap, ns7__ProviderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ProviderType);
	if (soap_out_PointerTons7__ProviderType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ProviderType(struct soap *soap, const char *tag, int id, ns7__ProviderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ProviderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ProviderType ** SOAP_FMAC4 soap_get_PointerTons7__ProviderType(struct soap *soap, ns7__ProviderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ProviderType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__ProviderType ** SOAP_FMAC4 soap_in_PointerTons7__ProviderType(struct soap *soap, const char *tag, ns7__ProviderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ProviderType **)soap_malloc(soap, sizeof(ns7__ProviderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ProviderType *)soap_instantiate_ns7__ProviderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__ProviderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ProviderType, sizeof(ns7__ProviderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, std::vector<ns7__LinkType * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType))
		soap_serialize_std__vectorTemplateOfPointerTons7__LinkType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, std::vector<ns7__LinkType * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons7__LinkType);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons7__LinkType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, const char *tag, int id, std::vector<ns7__LinkType * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons7__LinkType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns7__LinkType * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, std::vector<ns7__LinkType * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons7__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns7__LinkType * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, const char *tag, std::vector<ns7__LinkType * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns7__LinkType * >**)soap_malloc(soap, sizeof(std::vector<ns7__LinkType * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons7__LinkType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__LinkType(struct soap *soap, ns7__LinkType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__LinkType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__LinkType(struct soap *soap, ns7__LinkType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__LinkType);
	if (soap_out_PointerTons7__LinkType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__LinkType(struct soap *soap, const char *tag, int id, ns7__LinkType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__LinkType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__LinkType ** SOAP_FMAC4 soap_get_PointerTons7__LinkType(struct soap *soap, ns7__LinkType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__LinkType ** SOAP_FMAC4 soap_in_PointerTons7__LinkType(struct soap *soap, const char *tag, ns7__LinkType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__LinkType **)soap_malloc(soap, sizeof(ns7__LinkType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__LinkType *)soap_instantiate_ns7__LinkType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__LinkType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LinkType, sizeof(ns7__LinkType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdCheckListType(struct soap *soap, ns7__IdCheckListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdCheckListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdCheckListType(struct soap *soap, ns7__IdCheckListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdCheckListType);
	if (soap_out_PointerTons7__IdCheckListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdCheckListType(struct soap *soap, const char *tag, int id, ns7__IdCheckListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdCheckListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdCheckListType ** SOAP_FMAC4 soap_get_PointerTons7__IdCheckListType(struct soap *soap, ns7__IdCheckListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdCheckListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdCheckListType ** SOAP_FMAC4 soap_in_PointerTons7__IdCheckListType(struct soap *soap, const char *tag, ns7__IdCheckListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdCheckListType **)soap_malloc(soap, sizeof(ns7__IdCheckListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdCheckListType *)soap_instantiate_ns7__IdCheckListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdCheckListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdCheckListType, sizeof(ns7__IdCheckListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdUrlListType(struct soap *soap, ns7__IdUrlListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdUrlListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdUrlListType(struct soap *soap, ns7__IdUrlListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdUrlListType);
	if (soap_out_PointerTons7__IdUrlListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdUrlListType(struct soap *soap, const char *tag, int id, ns7__IdUrlListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdUrlListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdUrlListType ** SOAP_FMAC4 soap_get_PointerTons7__IdUrlListType(struct soap *soap, ns7__IdUrlListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdUrlListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdUrlListType ** SOAP_FMAC4 soap_in_PointerTons7__IdUrlListType(struct soap *soap, const char *tag, ns7__IdUrlListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdUrlListType **)soap_malloc(soap, sizeof(ns7__IdUrlListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdUrlListType *)soap_instantiate_ns7__IdUrlListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdUrlListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdUrlListType, sizeof(ns7__IdUrlListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__LinkSetDbType(struct soap *soap, ns7__LinkSetDbType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__LinkSetDbType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__LinkSetDbType(struct soap *soap, ns7__LinkSetDbType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__LinkSetDbType);
	if (soap_out_PointerTons7__LinkSetDbType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__LinkSetDbType(struct soap *soap, const char *tag, int id, ns7__LinkSetDbType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__LinkSetDbType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__LinkSetDbType ** SOAP_FMAC4 soap_get_PointerTons7__LinkSetDbType(struct soap *soap, ns7__LinkSetDbType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__LinkSetDbType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__LinkSetDbType ** SOAP_FMAC4 soap_in_PointerTons7__LinkSetDbType(struct soap *soap, const char *tag, ns7__LinkSetDbType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__LinkSetDbType **)soap_malloc(soap, sizeof(ns7__LinkSetDbType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__LinkSetDbType *)soap_instantiate_ns7__LinkSetDbType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__LinkSetDbType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LinkSetDbType, sizeof(ns7__LinkSetDbType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdListType(struct soap *soap, ns7__IdListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdListType(struct soap *soap, ns7__IdListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdListType);
	if (soap_out_PointerTons7__IdListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdListType(struct soap *soap, const char *tag, int id, ns7__IdListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdListType ** SOAP_FMAC4 soap_get_PointerTons7__IdListType(struct soap *soap, ns7__IdListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdListType ** SOAP_FMAC4 soap_in_PointerTons7__IdListType(struct soap *soap, const char *tag, ns7__IdListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdListType **)soap_malloc(soap, sizeof(ns7__IdListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdListType *)soap_instantiate_ns7__IdListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdListType, sizeof(ns7__IdListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, std::vector<ns7__ObjUrlType * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType))
		soap_serialize_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, std::vector<ns7__ObjUrlType * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, const char *tag, int id, std::vector<ns7__ObjUrlType * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns7__ObjUrlType * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, std::vector<ns7__ObjUrlType * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns7__ObjUrlType * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, const char *tag, std::vector<ns7__ObjUrlType * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns7__ObjUrlType * >**)soap_malloc(soap, sizeof(std::vector<ns7__ObjUrlType * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ObjUrlType(struct soap *soap, ns7__ObjUrlType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ObjUrlType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ObjUrlType(struct soap *soap, ns7__ObjUrlType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ObjUrlType);
	if (soap_out_PointerTons7__ObjUrlType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ObjUrlType(struct soap *soap, const char *tag, int id, ns7__ObjUrlType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ObjUrlType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ObjUrlType ** SOAP_FMAC4 soap_get_PointerTons7__ObjUrlType(struct soap *soap, ns7__ObjUrlType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ObjUrlType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__ObjUrlType ** SOAP_FMAC4 soap_in_PointerTons7__ObjUrlType(struct soap *soap, const char *tag, ns7__ObjUrlType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__ObjUrlType **)soap_malloc(soap, sizeof(ns7__ObjUrlType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__ObjUrlType *)soap_instantiate_ns7__ObjUrlType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__ObjUrlType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ObjUrlType, sizeof(ns7__ObjUrlType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdUrlSetType(struct soap *soap, ns7__IdUrlSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdUrlSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdUrlSetType(struct soap *soap, ns7__IdUrlSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdUrlSetType);
	if (soap_out_PointerTons7__IdUrlSetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdUrlSetType(struct soap *soap, const char *tag, int id, ns7__IdUrlSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdUrlSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdUrlSetType ** SOAP_FMAC4 soap_get_PointerTons7__IdUrlSetType(struct soap *soap, ns7__IdUrlSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdUrlSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdUrlSetType ** SOAP_FMAC4 soap_in_PointerTons7__IdUrlSetType(struct soap *soap, const char *tag, ns7__IdUrlSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdUrlSetType **)soap_malloc(soap, sizeof(ns7__IdUrlSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdUrlSetType *)soap_instantiate_ns7__IdUrlSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdUrlSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdUrlSetType, sizeof(ns7__IdUrlSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__LinkInfoType(struct soap *soap, ns7__LinkInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__LinkInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__LinkInfoType(struct soap *soap, ns7__LinkInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__LinkInfoType);
	if (soap_out_PointerTons7__LinkInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__LinkInfoType(struct soap *soap, const char *tag, int id, ns7__LinkInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__LinkInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__LinkInfoType ** SOAP_FMAC4 soap_get_PointerTons7__LinkInfoType(struct soap *soap, ns7__LinkInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__LinkInfoType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__LinkInfoType ** SOAP_FMAC4 soap_in_PointerTons7__LinkInfoType(struct soap *soap, const char *tag, ns7__LinkInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__LinkInfoType **)soap_malloc(soap, sizeof(ns7__LinkInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__LinkInfoType *)soap_instantiate_ns7__LinkInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__LinkInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LinkInfoType, sizeof(ns7__LinkInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns7__union_IdCheckListType))
		soap_serialize___ns7__union_IdCheckListType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns7__union_IdCheckListType);
	if (soap_out_PointerTo__ns7__union_IdCheckListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns7__union_IdCheckListType(struct soap *soap, const char *tag, int id, struct __ns7__union_IdCheckListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns7__union_IdCheckListType);
	if (id < 0)
		return soap->error;
	return soap_out___ns7__union_IdCheckListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns7__union_IdCheckListType ** SOAP_FMAC4 soap_get_PointerTo__ns7__union_IdCheckListType(struct soap *soap, struct __ns7__union_IdCheckListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns7__union_IdCheckListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns7__union_IdCheckListType ** SOAP_FMAC4 soap_in_PointerTo__ns7__union_IdCheckListType(struct soap *soap, const char *tag, struct __ns7__union_IdCheckListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns7__union_IdCheckListType **)soap_malloc(soap, sizeof(struct __ns7__union_IdCheckListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns7__union_IdCheckListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns7__union_IdCheckListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns7__union_IdCheckListType, sizeof(struct __ns7__union_IdCheckListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdLinkSetType(struct soap *soap, ns7__IdLinkSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdLinkSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdLinkSetType(struct soap *soap, ns7__IdLinkSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdLinkSetType);
	if (soap_out_PointerTons7__IdLinkSetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdLinkSetType(struct soap *soap, const char *tag, int id, ns7__IdLinkSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdLinkSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdLinkSetType ** SOAP_FMAC4 soap_get_PointerTons7__IdLinkSetType(struct soap *soap, ns7__IdLinkSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdLinkSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdLinkSetType ** SOAP_FMAC4 soap_in_PointerTons7__IdLinkSetType(struct soap *soap, const char *tag, ns7__IdLinkSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdLinkSetType **)soap_malloc(soap, sizeof(ns7__IdLinkSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdLinkSetType *)soap_instantiate_ns7__IdLinkSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdLinkSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdLinkSetType, sizeof(ns7__IdLinkSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__IdType(struct soap *soap, ns7__IdType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__IdType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__IdType(struct soap *soap, ns7__IdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__IdType);
	if (soap_out_PointerTons7__IdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__IdType(struct soap *soap, const char *tag, int id, ns7__IdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__IdType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__IdType ** SOAP_FMAC4 soap_get_PointerTons7__IdType(struct soap *soap, ns7__IdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__IdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__IdType ** SOAP_FMAC4 soap_in_PointerTons7__IdType(struct soap *soap, const char *tag, ns7__IdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__IdType **)soap_malloc(soap, sizeof(ns7__IdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__IdType *)soap_instantiate_ns7__IdType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__IdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__IdType, sizeof(ns7__IdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__eSummaryResultType(struct soap *soap, ns6__eSummaryResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__eSummaryResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__eSummaryResultType(struct soap *soap, ns6__eSummaryResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__eSummaryResultType);
	if (soap_out_PointerTons6__eSummaryResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__eSummaryResultType(struct soap *soap, const char *tag, int id, ns6__eSummaryResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__eSummaryResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__eSummaryResultType ** SOAP_FMAC4 soap_get_PointerTons6__eSummaryResultType(struct soap *soap, ns6__eSummaryResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__eSummaryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns6__eSummaryResultType ** SOAP_FMAC4 soap_in_PointerTons6__eSummaryResultType(struct soap *soap, const char *tag, ns6__eSummaryResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__eSummaryResultType **)soap_malloc(soap, sizeof(ns6__eSummaryResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__eSummaryResultType *)soap_instantiate_ns6__eSummaryResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns6__eSummaryResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__eSummaryResultType, sizeof(ns6__eSummaryResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocSumType(struct soap *soap, ns6__DocSumType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DocSumType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocSumType(struct soap *soap, ns6__DocSumType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocSumType);
	if (soap_out_PointerTons6__DocSumType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DocSumType(struct soap *soap, const char *tag, int id, ns6__DocSumType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocSumType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DocSumType ** SOAP_FMAC4 soap_get_PointerTons6__DocSumType(struct soap *soap, ns6__DocSumType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DocSumType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns6__DocSumType ** SOAP_FMAC4 soap_in_PointerTons6__DocSumType(struct soap *soap, const char *tag, ns6__DocSumType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DocSumType **)soap_malloc(soap, sizeof(ns6__DocSumType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DocSumType *)soap_instantiate_ns6__DocSumType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns6__DocSumType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocSumType, sizeof(ns6__DocSumType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns6__union_ItemType))
		soap_serialize___ns6__union_ItemType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns6__union_ItemType);
	if (soap_out_PointerTo__ns6__union_ItemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns6__union_ItemType(struct soap *soap, const char *tag, int id, struct __ns6__union_ItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns6__union_ItemType);
	if (id < 0)
		return soap->error;
	return soap_out___ns6__union_ItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns6__union_ItemType ** SOAP_FMAC4 soap_get_PointerTo__ns6__union_ItemType(struct soap *soap, struct __ns6__union_ItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns6__union_ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns6__union_ItemType ** SOAP_FMAC4 soap_in_PointerTo__ns6__union_ItemType(struct soap *soap, const char *tag, struct __ns6__union_ItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns6__union_ItemType **)soap_malloc(soap, sizeof(struct __ns6__union_ItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns6__union_ItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns6__union_ItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns6__union_ItemType, sizeof(struct __ns6__union_ItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ItemType(struct soap *soap, ns6__ItemType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ItemType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ItemType(struct soap *soap, ns6__ItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ItemType);
	if (soap_out_PointerTons6__ItemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ItemType(struct soap *soap, const char *tag, int id, ns6__ItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ItemType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ItemType ** SOAP_FMAC4 soap_get_PointerTons6__ItemType(struct soap *soap, ns6__ItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns6__ItemType ** SOAP_FMAC4 soap_in_PointerTons6__ItemType(struct soap *soap, const char *tag, ns6__ItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ItemType **)soap_malloc(soap, sizeof(ns6__ItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ItemType *)soap_instantiate_ns6__ItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns6__ItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ItemType, sizeof(ns6__ItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__eSearchResultType(struct soap *soap, ns5__eSearchResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__eSearchResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__eSearchResultType(struct soap *soap, ns5__eSearchResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__eSearchResultType);
	if (soap_out_PointerTons5__eSearchResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__eSearchResultType(struct soap *soap, const char *tag, int id, ns5__eSearchResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__eSearchResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__eSearchResultType ** SOAP_FMAC4 soap_get_PointerTons5__eSearchResultType(struct soap *soap, ns5__eSearchResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__eSearchResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__eSearchResultType ** SOAP_FMAC4 soap_in_PointerTons5__eSearchResultType(struct soap *soap, const char *tag, ns5__eSearchResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__eSearchResultType **)soap_malloc(soap, sizeof(ns5__eSearchResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__eSearchResultType *)soap_instantiate_ns5__eSearchResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__eSearchResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__eSearchResultType, sizeof(ns5__eSearchResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TranslationStackType(struct soap *soap, ns5__TranslationStackType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TranslationStackType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TranslationStackType(struct soap *soap, ns5__TranslationStackType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__TranslationStackType);
	if (soap_out_PointerTons5__TranslationStackType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TranslationStackType(struct soap *soap, const char *tag, int id, ns5__TranslationStackType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TranslationStackType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TranslationStackType ** SOAP_FMAC4 soap_get_PointerTons5__TranslationStackType(struct soap *soap, ns5__TranslationStackType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TranslationStackType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__TranslationStackType ** SOAP_FMAC4 soap_in_PointerTons5__TranslationStackType(struct soap *soap, const char *tag, ns5__TranslationStackType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TranslationStackType **)soap_malloc(soap, sizeof(ns5__TranslationStackType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TranslationStackType *)soap_instantiate_ns5__TranslationStackType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__TranslationStackType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TranslationStackType, sizeof(ns5__TranslationStackType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TranslationSetType(struct soap *soap, ns5__TranslationSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TranslationSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TranslationSetType(struct soap *soap, ns5__TranslationSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__TranslationSetType);
	if (soap_out_PointerTons5__TranslationSetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TranslationSetType(struct soap *soap, const char *tag, int id, ns5__TranslationSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TranslationSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TranslationSetType ** SOAP_FMAC4 soap_get_PointerTons5__TranslationSetType(struct soap *soap, ns5__TranslationSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TranslationSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__TranslationSetType ** SOAP_FMAC4 soap_in_PointerTons5__TranslationSetType(struct soap *soap, const char *tag, ns5__TranslationSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TranslationSetType **)soap_malloc(soap, sizeof(ns5__TranslationSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TranslationSetType *)soap_instantiate_ns5__TranslationSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__TranslationSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TranslationSetType, sizeof(ns5__TranslationSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__IdListType(struct soap *soap, ns5__IdListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__IdListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__IdListType(struct soap *soap, ns5__IdListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__IdListType);
	if (soap_out_PointerTons5__IdListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__IdListType(struct soap *soap, const char *tag, int id, ns5__IdListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__IdListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__IdListType ** SOAP_FMAC4 soap_get_PointerTons5__IdListType(struct soap *soap, ns5__IdListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__IdListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__IdListType ** SOAP_FMAC4 soap_in_PointerTons5__IdListType(struct soap *soap, const char *tag, ns5__IdListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__IdListType **)soap_malloc(soap, sizeof(ns5__IdListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__IdListType *)soap_instantiate_ns5__IdListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__IdListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__IdListType, sizeof(ns5__IdListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__WarningListType(struct soap *soap, ns5__WarningListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__WarningListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__WarningListType(struct soap *soap, ns5__WarningListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__WarningListType);
	if (soap_out_PointerTons5__WarningListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__WarningListType(struct soap *soap, const char *tag, int id, ns5__WarningListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__WarningListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__WarningListType ** SOAP_FMAC4 soap_get_PointerTons5__WarningListType(struct soap *soap, ns5__WarningListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__WarningListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__WarningListType ** SOAP_FMAC4 soap_in_PointerTons5__WarningListType(struct soap *soap, const char *tag, ns5__WarningListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__WarningListType **)soap_malloc(soap, sizeof(ns5__WarningListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__WarningListType *)soap_instantiate_ns5__WarningListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__WarningListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__WarningListType, sizeof(ns5__WarningListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ErrorListType(struct soap *soap, ns5__ErrorListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ErrorListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ErrorListType(struct soap *soap, ns5__ErrorListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ErrorListType);
	if (soap_out_PointerTons5__ErrorListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ErrorListType(struct soap *soap, const char *tag, int id, ns5__ErrorListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ErrorListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ErrorListType ** SOAP_FMAC4 soap_get_PointerTons5__ErrorListType(struct soap *soap, ns5__ErrorListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ErrorListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__ErrorListType ** SOAP_FMAC4 soap_in_PointerTons5__ErrorListType(struct soap *soap, const char *tag, ns5__ErrorListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ErrorListType **)soap_malloc(soap, sizeof(ns5__ErrorListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ErrorListType *)soap_instantiate_ns5__ErrorListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__ErrorListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ErrorListType, sizeof(ns5__ErrorListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns5__union_TranslationStackType))
		soap_serialize___ns5__union_TranslationStackType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns5__union_TranslationStackType);
	if (soap_out_PointerTo__ns5__union_TranslationStackType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns5__union_TranslationStackType(struct soap *soap, const char *tag, int id, struct __ns5__union_TranslationStackType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns5__union_TranslationStackType);
	if (id < 0)
		return soap->error;
	return soap_out___ns5__union_TranslationStackType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns5__union_TranslationStackType ** SOAP_FMAC4 soap_get_PointerTo__ns5__union_TranslationStackType(struct soap *soap, struct __ns5__union_TranslationStackType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns5__union_TranslationStackType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns5__union_TranslationStackType ** SOAP_FMAC4 soap_in_PointerTo__ns5__union_TranslationStackType(struct soap *soap, const char *tag, struct __ns5__union_TranslationStackType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns5__union_TranslationStackType **)soap_malloc(soap, sizeof(struct __ns5__union_TranslationStackType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns5__union_TranslationStackType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns5__union_TranslationStackType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns5__union_TranslationStackType, sizeof(struct __ns5__union_TranslationStackType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TermSetType(struct soap *soap, ns5__TermSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TermSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TermSetType(struct soap *soap, ns5__TermSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__TermSetType);
	if (soap_out_PointerTons5__TermSetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TermSetType(struct soap *soap, const char *tag, int id, ns5__TermSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TermSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TermSetType ** SOAP_FMAC4 soap_get_PointerTons5__TermSetType(struct soap *soap, ns5__TermSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TermSetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__TermSetType ** SOAP_FMAC4 soap_in_PointerTons5__TermSetType(struct soap *soap, const char *tag, ns5__TermSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TermSetType **)soap_malloc(soap, sizeof(ns5__TermSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TermSetType *)soap_instantiate_ns5__TermSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__TermSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TermSetType, sizeof(ns5__TermSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TranslationType(struct soap *soap, ns5__TranslationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TranslationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TranslationType(struct soap *soap, ns5__TranslationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__TranslationType);
	if (soap_out_PointerTons5__TranslationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TranslationType(struct soap *soap, const char *tag, int id, ns5__TranslationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TranslationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__TranslationType ** SOAP_FMAC4 soap_get_PointerTons5__TranslationType(struct soap *soap, ns5__TranslationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TranslationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__TranslationType ** SOAP_FMAC4 soap_in_PointerTons5__TranslationType(struct soap *soap, const char *tag, ns5__TranslationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TranslationType **)soap_malloc(soap, sizeof(ns5__TranslationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TranslationType *)soap_instantiate_ns5__TranslationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__TranslationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TranslationType, sizeof(ns5__TranslationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__eInfoResultType(struct soap *soap, ns4__eInfoResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__eInfoResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__eInfoResultType(struct soap *soap, ns4__eInfoResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__eInfoResultType);
	if (soap_out_PointerTons4__eInfoResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__eInfoResultType(struct soap *soap, const char *tag, int id, ns4__eInfoResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__eInfoResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__eInfoResultType ** SOAP_FMAC4 soap_get_PointerTons4__eInfoResultType(struct soap *soap, ns4__eInfoResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__eInfoResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__eInfoResultType ** SOAP_FMAC4 soap_in_PointerTons4__eInfoResultType(struct soap *soap, const char *tag, ns4__eInfoResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__eInfoResultType **)soap_malloc(soap, sizeof(ns4__eInfoResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__eInfoResultType *)soap_instantiate_ns4__eInfoResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__eInfoResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__eInfoResultType, sizeof(ns4__eInfoResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DbInfoType(struct soap *soap, ns4__DbInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__DbInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DbInfoType(struct soap *soap, ns4__DbInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DbInfoType);
	if (soap_out_PointerTons4__DbInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DbInfoType(struct soap *soap, const char *tag, int id, ns4__DbInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DbInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__DbInfoType ** SOAP_FMAC4 soap_get_PointerTons4__DbInfoType(struct soap *soap, ns4__DbInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DbInfoType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__DbInfoType ** SOAP_FMAC4 soap_in_PointerTons4__DbInfoType(struct soap *soap, const char *tag, ns4__DbInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__DbInfoType **)soap_malloc(soap, sizeof(ns4__DbInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__DbInfoType *)soap_instantiate_ns4__DbInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__DbInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DbInfoType, sizeof(ns4__DbInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DbListType(struct soap *soap, ns4__DbListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__DbListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DbListType(struct soap *soap, ns4__DbListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DbListType);
	if (soap_out_PointerTons4__DbListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DbListType(struct soap *soap, const char *tag, int id, ns4__DbListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DbListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__DbListType ** SOAP_FMAC4 soap_get_PointerTons4__DbListType(struct soap *soap, ns4__DbListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DbListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__DbListType ** SOAP_FMAC4 soap_in_PointerTons4__DbListType(struct soap *soap, const char *tag, ns4__DbListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__DbListType **)soap_malloc(soap, sizeof(ns4__DbListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__DbListType *)soap_instantiate_ns4__DbListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__DbListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DbListType, sizeof(ns4__DbListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__LinkType(struct soap *soap, ns4__LinkType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__LinkType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__LinkType(struct soap *soap, ns4__LinkType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__LinkType);
	if (soap_out_PointerTons4__LinkType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__LinkType(struct soap *soap, const char *tag, int id, ns4__LinkType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__LinkType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__LinkType ** SOAP_FMAC4 soap_get_PointerTons4__LinkType(struct soap *soap, ns4__LinkType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__LinkType ** SOAP_FMAC4 soap_in_PointerTons4__LinkType(struct soap *soap, const char *tag, ns4__LinkType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__LinkType **)soap_malloc(soap, sizeof(ns4__LinkType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__LinkType *)soap_instantiate_ns4__LinkType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__LinkType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LinkType, sizeof(ns4__LinkType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FieldType(struct soap *soap, ns4__FieldType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FieldType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FieldType(struct soap *soap, ns4__FieldType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FieldType);
	if (soap_out_PointerTons4__FieldType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FieldType(struct soap *soap, const char *tag, int id, ns4__FieldType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FieldType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__FieldType ** SOAP_FMAC4 soap_get_PointerTons4__FieldType(struct soap *soap, ns4__FieldType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FieldType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__FieldType ** SOAP_FMAC4 soap_in_PointerTons4__FieldType(struct soap *soap, const char *tag, ns4__FieldType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__FieldType **)soap_malloc(soap, sizeof(ns4__FieldType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__FieldType *)soap_instantiate_ns4__FieldType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__FieldType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FieldType, sizeof(ns4__FieldType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_serialize_std__vectorTemplateOfstd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfstd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfstd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfstd__string(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__LinkListType(struct soap *soap, ns4__LinkListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__LinkListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__LinkListType(struct soap *soap, ns4__LinkListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__LinkListType);
	if (soap_out_PointerTons4__LinkListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__LinkListType(struct soap *soap, const char *tag, int id, ns4__LinkListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__LinkListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__LinkListType ** SOAP_FMAC4 soap_get_PointerTons4__LinkListType(struct soap *soap, ns4__LinkListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__LinkListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__LinkListType ** SOAP_FMAC4 soap_in_PointerTons4__LinkListType(struct soap *soap, const char *tag, ns4__LinkListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__LinkListType **)soap_malloc(soap, sizeof(ns4__LinkListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__LinkListType *)soap_instantiate_ns4__LinkListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__LinkListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LinkListType, sizeof(ns4__LinkListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FieldListType(struct soap *soap, ns4__FieldListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FieldListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FieldListType(struct soap *soap, ns4__FieldListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FieldListType);
	if (soap_out_PointerTons4__FieldListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FieldListType(struct soap *soap, const char *tag, int id, ns4__FieldListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FieldListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__FieldListType ** SOAP_FMAC4 soap_get_PointerTons4__FieldListType(struct soap *soap, ns4__FieldListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FieldListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__FieldListType ** SOAP_FMAC4 soap_in_PointerTons4__FieldListType(struct soap *soap, const char *tag, ns4__FieldListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__FieldListType **)soap_malloc(soap, sizeof(ns4__FieldListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__FieldListType *)soap_instantiate_ns4__FieldListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__FieldListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FieldListType, sizeof(ns4__FieldListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__GQueryResultType(struct soap *soap, ns3__GQueryResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__GQueryResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__GQueryResultType(struct soap *soap, ns3__GQueryResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__GQueryResultType);
	if (soap_out_PointerTons3__GQueryResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__GQueryResultType(struct soap *soap, const char *tag, int id, ns3__GQueryResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__GQueryResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__GQueryResultType ** SOAP_FMAC4 soap_get_PointerTons3__GQueryResultType(struct soap *soap, ns3__GQueryResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__GQueryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__GQueryResultType ** SOAP_FMAC4 soap_in_PointerTons3__GQueryResultType(struct soap *soap, const char *tag, ns3__GQueryResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__GQueryResultType **)soap_malloc(soap, sizeof(ns3__GQueryResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__GQueryResultType *)soap_instantiate_ns3__GQueryResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__GQueryResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__GQueryResultType, sizeof(ns3__GQueryResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__eGQueryResultType(struct soap *soap, ns3__eGQueryResultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__eGQueryResultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__eGQueryResultType(struct soap *soap, ns3__eGQueryResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__eGQueryResultType);
	if (soap_out_PointerTons3__eGQueryResultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__eGQueryResultType(struct soap *soap, const char *tag, int id, ns3__eGQueryResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__eGQueryResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__eGQueryResultType ** SOAP_FMAC4 soap_get_PointerTons3__eGQueryResultType(struct soap *soap, ns3__eGQueryResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__eGQueryResultType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__eGQueryResultType ** SOAP_FMAC4 soap_in_PointerTons3__eGQueryResultType(struct soap *soap, const char *tag, ns3__eGQueryResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__eGQueryResultType **)soap_malloc(soap, sizeof(ns3__eGQueryResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__eGQueryResultType *)soap_instantiate_ns3__eGQueryResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__eGQueryResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__eGQueryResultType, sizeof(ns3__eGQueryResultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ResultItemType(struct soap *soap, ns3__ResultItemType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ResultItemType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ResultItemType(struct soap *soap, ns3__ResultItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ResultItemType);
	if (soap_out_PointerTons3__ResultItemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ResultItemType(struct soap *soap, const char *tag, int id, ns3__ResultItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ResultItemType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ResultItemType ** SOAP_FMAC4 soap_get_PointerTons3__ResultItemType(struct soap *soap, ns3__ResultItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ResultItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__ResultItemType ** SOAP_FMAC4 soap_in_PointerTons3__ResultItemType(struct soap *soap, const char *tag, ns3__ResultItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ResultItemType **)soap_malloc(soap, sizeof(ns3__ResultItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ResultItemType *)soap_instantiate_ns3__ResultItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__ResultItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ResultItemType, sizeof(ns3__ResultItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, const std::vector<ns7__LinkSetType * >*a)
{
	for (std::vector<ns7__LinkSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__LinkSetType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, std::vector<ns7__LinkSetType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, const char *tag, int id, const std::vector<ns7__LinkSetType * >*a, const char *type)
{
	for (std::vector<ns7__LinkSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__LinkSetType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__LinkSetType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, const char *tag, std::vector<ns7__LinkSetType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__LinkSetType(soap, -1)))
		return NULL;
	ns7__LinkSetType *n;
	ns7__LinkSetType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__LinkSetType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetType, sizeof(ns7__LinkSetType), 1))
				break;
			if (!(p = soap_in_PointerTons7__LinkSetType(soap, tag, NULL, "ns7:LinkSetType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__LinkSetType(soap, tag, &n, "ns7:LinkSetType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__LinkSetType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, std::vector<ns7__LinkSetType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__LinkSetType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__LinkSetType * >;
		if (size)
			*size = sizeof(std::vector<ns7__LinkSetType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__LinkSetType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__LinkSetType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__LinkSetType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__LinkSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__LinkSetType * > %p -> %p\n", q, p));
	*(std::vector<ns7__LinkSetType * >*)p = *(std::vector<ns7__LinkSetType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, const std::vector<ns7__LinkType * >*a)
{
	for (std::vector<ns7__LinkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__LinkType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, std::vector<ns7__LinkType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, const char *tag, int id, const std::vector<ns7__LinkType * >*a, const char *type)
{
	for (std::vector<ns7__LinkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__LinkType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__LinkType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, const char *tag, std::vector<ns7__LinkType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__LinkType(soap, -1)))
		return NULL;
	ns7__LinkType *n;
	ns7__LinkType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__LinkType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType, sizeof(ns7__LinkType), 1))
				break;
			if (!(p = soap_in_PointerTons7__LinkType(soap, tag, NULL, "ns7:LinkType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__LinkType(soap, tag, &n, "ns7:LinkType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__LinkType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__LinkType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, std::vector<ns7__LinkType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__LinkType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__LinkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__LinkType * >;
		if (size)
			*size = sizeof(std::vector<ns7__LinkType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__LinkType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__LinkType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__LinkType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__LinkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__LinkType * > %p -> %p\n", q, p));
	*(std::vector<ns7__LinkType * >*)p = *(std::vector<ns7__LinkType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, const std::vector<ns7__LinkSetDbType * >*a)
{
	for (std::vector<ns7__LinkSetDbType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__LinkSetDbType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, std::vector<ns7__LinkSetDbType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, const char *tag, int id, const std::vector<ns7__LinkSetDbType * >*a, const char *type)
{
	for (std::vector<ns7__LinkSetDbType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__LinkSetDbType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__LinkSetDbType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, const char *tag, std::vector<ns7__LinkSetDbType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, -1)))
		return NULL;
	ns7__LinkSetDbType *n;
	ns7__LinkSetDbType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__LinkSetDbType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetDbType, sizeof(ns7__LinkSetDbType), 1))
				break;
			if (!(p = soap_in_PointerTons7__LinkSetDbType(soap, tag, NULL, "ns7:LinkSetDbType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__LinkSetDbType(soap, tag, &n, "ns7:LinkSetDbType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__LinkSetDbType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetDbType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, std::vector<ns7__LinkSetDbType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__LinkSetDbType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__LinkSetDbType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkSetDbType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__LinkSetDbType * >;
		if (size)
			*size = sizeof(std::vector<ns7__LinkSetDbType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__LinkSetDbType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__LinkSetDbType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__LinkSetDbType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__LinkSetDbType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__LinkSetDbType * > %p -> %p\n", q, p));
	*(std::vector<ns7__LinkSetDbType * >*)p = *(std::vector<ns7__LinkSetDbType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, const std::vector<ns7__ObjUrlType * >*a)
{
	for (std::vector<ns7__ObjUrlType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__ObjUrlType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, std::vector<ns7__ObjUrlType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, const char *tag, int id, const std::vector<ns7__ObjUrlType * >*a, const char *type)
{
	for (std::vector<ns7__ObjUrlType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__ObjUrlType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__ObjUrlType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, const char *tag, std::vector<ns7__ObjUrlType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, -1)))
		return NULL;
	ns7__ObjUrlType *n;
	ns7__ObjUrlType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__ObjUrlType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType, sizeof(ns7__ObjUrlType), 1))
				break;
			if (!(p = soap_in_PointerTons7__ObjUrlType(soap, tag, NULL, "ns7:ObjUrlType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__ObjUrlType(soap, tag, &n, "ns7:ObjUrlType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__ObjUrlType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__ObjUrlType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, std::vector<ns7__ObjUrlType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__ObjUrlType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__ObjUrlType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__ObjUrlType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__ObjUrlType * >;
		if (size)
			*size = sizeof(std::vector<ns7__ObjUrlType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__ObjUrlType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__ObjUrlType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__ObjUrlType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__ObjUrlType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__ObjUrlType * > %p -> %p\n", q, p));
	*(std::vector<ns7__ObjUrlType * >*)p = *(std::vector<ns7__ObjUrlType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, const std::vector<ns7__IdUrlSetType * >*a)
{
	for (std::vector<ns7__IdUrlSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__IdUrlSetType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, std::vector<ns7__IdUrlSetType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, const char *tag, int id, const std::vector<ns7__IdUrlSetType * >*a, const char *type)
{
	for (std::vector<ns7__IdUrlSetType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__IdUrlSetType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__IdUrlSetType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, const char *tag, std::vector<ns7__IdUrlSetType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, -1)))
		return NULL;
	ns7__IdUrlSetType *n;
	ns7__IdUrlSetType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__IdUrlSetType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdUrlSetType, sizeof(ns7__IdUrlSetType), 1))
				break;
			if (!(p = soap_in_PointerTons7__IdUrlSetType(soap, tag, NULL, "ns7:IdUrlSetType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__IdUrlSetType(soap, tag, &n, "ns7:IdUrlSetType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__IdUrlSetType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__IdUrlSetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, std::vector<ns7__IdUrlSetType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__IdUrlSetType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__IdUrlSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdUrlSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__IdUrlSetType * >;
		if (size)
			*size = sizeof(std::vector<ns7__IdUrlSetType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__IdUrlSetType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__IdUrlSetType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__IdUrlSetType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__IdUrlSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__IdUrlSetType * > %p -> %p\n", q, p));
	*(std::vector<ns7__IdUrlSetType * >*)p = *(std::vector<ns7__IdUrlSetType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, const std::vector<ns7__IdType * >*a)
{
	for (std::vector<ns7__IdType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__IdType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, std::vector<ns7__IdType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, const char *tag, int id, const std::vector<ns7__IdType * >*a, const char *type)
{
	for (std::vector<ns7__IdType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__IdType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__IdType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, const char *tag, std::vector<ns7__IdType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__IdType(soap, -1)))
		return NULL;
	ns7__IdType *n;
	ns7__IdType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__IdType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdType, sizeof(ns7__IdType), 1))
				break;
			if (!(p = soap_in_PointerTons7__IdType(soap, tag, NULL, "ns7:IdType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__IdType(soap, tag, &n, "ns7:IdType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__IdType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__IdType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, std::vector<ns7__IdType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__IdType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__IdType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__IdType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__IdType * >;
		if (size)
			*size = sizeof(std::vector<ns7__IdType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__IdType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__IdType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__IdType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__IdType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__IdType * > %p -> %p\n", q, p));
	*(std::vector<ns7__IdType * >*)p = *(std::vector<ns7__IdType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, const std::vector<ns7__LinkInfoType * >*a)
{
	for (std::vector<ns7__LinkInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__LinkInfoType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, std::vector<ns7__LinkInfoType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, const char *tag, int id, const std::vector<ns7__LinkInfoType * >*a, const char *type)
{
	for (std::vector<ns7__LinkInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__LinkInfoType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__LinkInfoType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, const char *tag, std::vector<ns7__LinkInfoType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, -1)))
		return NULL;
	ns7__LinkInfoType *n;
	ns7__LinkInfoType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns7__LinkInfoType, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkInfoType, sizeof(ns7__LinkInfoType), 1))
				break;
			if (!(p = soap_in_PointerTons7__LinkInfoType(soap, tag, NULL, "ns7:LinkInfoType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons7__LinkInfoType(soap, tag, &n, "ns7:LinkInfoType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns7__LinkInfoType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons7__LinkInfoType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, std::vector<ns7__LinkInfoType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns7__LinkInfoType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__LinkInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons7__LinkInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns7__LinkInfoType * >;
		if (size)
			*size = sizeof(std::vector<ns7__LinkInfoType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns7__LinkInfoType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns7__LinkInfoType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns7__LinkInfoType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons7__LinkInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns7__LinkInfoType * > %p -> %p\n", q, p));
	*(std::vector<ns7__LinkInfoType * >*)p = *(std::vector<ns7__LinkInfoType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, const std::vector<ns6__DocSumType * >*a)
{
	for (std::vector<ns6__DocSumType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__DocSumType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, std::vector<ns6__DocSumType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, const char *tag, int id, const std::vector<ns6__DocSumType * >*a, const char *type)
{
	for (std::vector<ns6__DocSumType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__DocSumType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__DocSumType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, const char *tag, std::vector<ns6__DocSumType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__DocSumType(soap, -1)))
		return NULL;
	ns6__DocSumType *n;
	ns6__DocSumType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__DocSumType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocSumType, sizeof(ns6__DocSumType), 1))
				break;
			if (!(p = soap_in_PointerTons6__DocSumType(soap, tag, NULL, "ns6:DocSumType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons6__DocSumType(soap, tag, &n, "ns6:DocSumType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns6__DocSumType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons6__DocSumType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, std::vector<ns6__DocSumType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns6__DocSumType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__DocSumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocSumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns6__DocSumType * >;
		if (size)
			*size = sizeof(std::vector<ns6__DocSumType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns6__DocSumType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns6__DocSumType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__DocSumType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__DocSumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__DocSumType * > %p -> %p\n", q, p));
	*(std::vector<ns6__DocSumType * >*)p = *(std::vector<ns6__DocSumType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, const std::vector<ns6__ItemType * >*a)
{
	for (std::vector<ns6__ItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__ItemType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, std::vector<ns6__ItemType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, const char *tag, int id, const std::vector<ns6__ItemType * >*a, const char *type)
{
	for (std::vector<ns6__ItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__ItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__ItemType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, const char *tag, std::vector<ns6__ItemType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__ItemType(soap, -1)))
		return NULL;
	ns6__ItemType *n;
	ns6__ItemType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__ItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ItemType, sizeof(ns6__ItemType), 1))
				break;
			if (!(p = soap_in_PointerTons6__ItemType(soap, tag, NULL, "ns6:ItemType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons6__ItemType(soap, tag, &n, "ns6:ItemType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns6__ItemType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons6__ItemType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, std::vector<ns6__ItemType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns6__ItemType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__ItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns6__ItemType * >;
		if (size)
			*size = sizeof(std::vector<ns6__ItemType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns6__ItemType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns6__ItemType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__ItemType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__ItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__ItemType * > %p -> %p\n", q, p));
	*(std::vector<ns6__ItemType * >*)p = *(std::vector<ns6__ItemType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, const std::vector<ns5__TranslationType * >*a)
{
	for (std::vector<ns5__TranslationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__TranslationType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, std::vector<ns5__TranslationType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, const char *tag, int id, const std::vector<ns5__TranslationType * >*a, const char *type)
{
	for (std::vector<ns5__TranslationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__TranslationType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__TranslationType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, const char *tag, std::vector<ns5__TranslationType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__TranslationType(soap, -1)))
		return NULL;
	ns5__TranslationType *n;
	ns5__TranslationType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__TranslationType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__TranslationType, sizeof(ns5__TranslationType), 1))
				break;
			if (!(p = soap_in_PointerTons5__TranslationType(soap, tag, NULL, "ns5:TranslationType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons5__TranslationType(soap, tag, &n, "ns5:TranslationType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns5__TranslationType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons5__TranslationType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, std::vector<ns5__TranslationType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns5__TranslationType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__TranslationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__TranslationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns5__TranslationType * >;
		if (size)
			*size = sizeof(std::vector<ns5__TranslationType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns5__TranslationType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns5__TranslationType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns5__TranslationType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__TranslationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__TranslationType * > %p -> %p\n", q, p));
	*(std::vector<ns5__TranslationType * >*)p = *(std::vector<ns5__TranslationType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, const std::vector<ns4__LinkType * >*a)
{
	for (std::vector<ns4__LinkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__LinkType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, std::vector<ns4__LinkType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, const char *tag, int id, const std::vector<ns4__LinkType * >*a, const char *type)
{
	for (std::vector<ns4__LinkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__LinkType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__LinkType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, const char *tag, std::vector<ns4__LinkType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__LinkType(soap, -1)))
		return NULL;
	ns4__LinkType *n;
	ns4__LinkType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__LinkType, SOAP_TYPE_std__vectorTemplateOfPointerTons4__LinkType, sizeof(ns4__LinkType), 1))
				break;
			if (!(p = soap_in_PointerTons4__LinkType(soap, tag, NULL, "ns4:LinkType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__LinkType(soap, tag, &n, "ns4:LinkType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__LinkType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__LinkType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, std::vector<ns4__LinkType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__LinkType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__LinkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__LinkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__LinkType * >;
		if (size)
			*size = sizeof(std::vector<ns4__LinkType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__LinkType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__LinkType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__LinkType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__LinkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__LinkType * > %p -> %p\n", q, p));
	*(std::vector<ns4__LinkType * >*)p = *(std::vector<ns4__LinkType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, const std::vector<ns4__FieldType * >*a)
{
	for (std::vector<ns4__FieldType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__FieldType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, std::vector<ns4__FieldType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, const char *tag, int id, const std::vector<ns4__FieldType * >*a, const char *type)
{
	for (std::vector<ns4__FieldType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__FieldType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__FieldType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, const char *tag, std::vector<ns4__FieldType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__FieldType(soap, -1)))
		return NULL;
	ns4__FieldType *n;
	ns4__FieldType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__FieldType, SOAP_TYPE_std__vectorTemplateOfPointerTons4__FieldType, sizeof(ns4__FieldType), 1))
				break;
			if (!(p = soap_in_PointerTons4__FieldType(soap, tag, NULL, "ns4:FieldType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons4__FieldType(soap, tag, &n, "ns4:FieldType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns4__FieldType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons4__FieldType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, std::vector<ns4__FieldType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns4__FieldType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__FieldType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__FieldType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns4__FieldType * >;
		if (size)
			*size = sizeof(std::vector<ns4__FieldType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns4__FieldType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns4__FieldType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__FieldType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__FieldType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__FieldType * > %p -> %p\n", q, p));
	*(std::vector<ns4__FieldType * >*)p = *(std::vector<ns4__FieldType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
				break;
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, const std::vector<ns3__ResultItemType * >*a)
{
	for (std::vector<ns3__ResultItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__ResultItemType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, std::vector<ns3__ResultItemType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, const char *tag, int id, const std::vector<ns3__ResultItemType * >*a, const char *type)
{
	for (std::vector<ns3__ResultItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__ResultItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__ResultItemType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, const char *tag, std::vector<ns3__ResultItemType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__ResultItemType(soap, -1)))
		return NULL;
	ns3__ResultItemType *n;
	ns3__ResultItemType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__ResultItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ResultItemType, sizeof(ns3__ResultItemType), 1))
				break;
			if (!(p = soap_in_PointerTons3__ResultItemType(soap, tag, NULL, "ns3:ResultItemType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons3__ResultItemType(soap, tag, &n, "ns3:ResultItemType"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns3__ResultItemType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons3__ResultItemType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, std::vector<ns3__ResultItemType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns3__ResultItemType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__ResultItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ResultItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns3__ResultItemType * >;
		if (size)
			*size = sizeof(std::vector<ns3__ResultItemType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns3__ResultItemType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns3__ResultItemType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__ResultItemType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__ResultItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__ResultItemType * > %p -> %p\n", q, p));
	*(std::vector<ns3__ResultItemType * >*)p = *(std::vector<ns3__ResultItemType * >*)q;
}

/* End of soapC.cpp */
